"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReactDevOverlay: function() {\n        return _ReactDevOverlay.default;\n    },\n    getErrorByType: function() {\n        return _geterrorbytype.getErrorByType;\n    },\n    getServerError: function() {\n        return _nodestackframes.getServerError;\n    },\n    onBeforeRefresh: function() {\n        return onBeforeRefresh;\n    },\n    onBuildError: function() {\n        return onBuildError;\n    },\n    onBuildOk: function() {\n        return onBuildOk;\n    },\n    onRefresh: function() {\n        return onRefresh;\n    },\n    onVersionInfo: function() {\n        return onVersionInfo;\n    },\n    register: function() {\n        return register;\n    },\n    unregister: function() {\n        return unregister;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _bus = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./bus */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/bus.js\"));\nconst _parsestack = __webpack_require__(/*! ../internal/helpers/parse-stack */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-stack.js\");\nconst _parsecomponentstack = __webpack_require__(/*! ../internal/helpers/parse-component-stack */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/parse-component-stack.js\");\nconst _hydrationerrorinfo = __webpack_require__(/*! ../internal/helpers/hydration-error-info */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/hydration-error-info.js\");\nconst _shared = __webpack_require__(/*! ../shared */ \"./node_modules/next/dist/client/components/react-dev-overlay/shared.js\");\nconst _attachhydrationerrorstate = __webpack_require__(/*! ../internal/helpers/attach-hydration-error-state */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/attach-hydration-error-state.js\");\nconst _geterrorbytype = __webpack_require__(/*! ../internal/helpers/get-error-by-type */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/get-error-by-type.js\");\nconst _nodestackframes = __webpack_require__(/*! ../internal/helpers/node-stack-frames */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/node-stack-frames.js\");\nconst _ReactDevOverlay = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./ReactDevOverlay */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/ReactDevOverlay.js\"));\nlet isRegistered = false;\nlet stackTraceLimit = undefined;\nfunction handleError(error) {\n    if (!error || !(error instanceof Error) || typeof error.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    (0, _attachhydrationerrorstate.attachHydrationErrorState)(error);\n    const componentStackTrace = error._componentStack || _hydrationerrorinfo.hydrationErrorState.componentStack;\n    const componentStackFrames = typeof componentStackTrace === 'string' ? (0, _parsecomponentstack.parseComponentStack)(componentStackTrace) : undefined;\n    // Skip ModuleBuildError and ModuleNotFoundError, as it will be sent through onBuildError callback.\n    // This is to avoid same error as different type showing up on client to cause flashing.\n    if (error.name !== 'ModuleBuildError' && error.name !== 'ModuleNotFoundError') {\n        _bus.emit({\n            type: _shared.ACTION_UNHANDLED_ERROR,\n            reason: error,\n            frames: (0, _parsestack.parseStack)(error.stack),\n            componentStackFrames\n        });\n    }\n}\nlet origConsoleError = console.error;\nfunction nextJsHandleConsoleError() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    // See https://github.com/facebook/react/blob/d50323eb845c5fde0d720cae888bf35dedd05506/packages/react-reconciler/src/ReactFiberErrorLogger.js#L78\n    const error =  true ? args[1] : 0;\n    (0, _hydrationerrorinfo.storeHydrationErrorStateFromConsoleArgs)(...args);\n    handleError(error);\n    origConsoleError.apply(window.console, args);\n}\nfunction onUnhandledError(event) {\n    const error = event == null ? void 0 : event.error;\n    handleError(error);\n}\nfunction onUnhandledRejection(ev) {\n    const reason = ev == null ? void 0 : ev.reason;\n    if (!reason || !(reason instanceof Error) || typeof reason.stack !== 'string') {\n        // A non-error was thrown, we don't have anything to show. :-(\n        return;\n    }\n    const e = reason;\n    _bus.emit({\n        type: _shared.ACTION_UNHANDLED_REJECTION,\n        reason: reason,\n        frames: (0, _parsestack.parseStack)(e.stack)\n    });\n}\nfunction register() {\n    if (isRegistered) {\n        return;\n    }\n    isRegistered = true;\n    try {\n        const limit = Error.stackTraceLimit;\n        Error.stackTraceLimit = 50;\n        stackTraceLimit = limit;\n    } catch (e) {}\n    window.addEventListener('error', onUnhandledError);\n    window.addEventListener('unhandledrejection', onUnhandledRejection);\n    window.console.error = nextJsHandleConsoleError;\n}\nfunction unregister() {\n    if (!isRegistered) {\n        return;\n    }\n    isRegistered = false;\n    if (stackTraceLimit !== undefined) {\n        try {\n            Error.stackTraceLimit = stackTraceLimit;\n        } catch (e) {}\n        stackTraceLimit = undefined;\n    }\n    window.removeEventListener('error', onUnhandledError);\n    window.removeEventListener('unhandledrejection', onUnhandledRejection);\n    window.console.error = origConsoleError;\n}\nfunction onBuildOk() {\n    _bus.emit({\n        type: _shared.ACTION_BUILD_OK\n    });\n}\nfunction onBuildError(message) {\n    _bus.emit({\n        type: _shared.ACTION_BUILD_ERROR,\n        message\n    });\n}\nfunction onRefresh() {\n    _bus.emit({\n        type: _shared.ACTION_REFRESH\n    });\n}\nfunction onBeforeRefresh() {\n    _bus.emit({\n        type: _shared.ACTION_BEFORE_REFRESH\n    });\n}\nfunction onVersionInfo(versionInfo) {\n    _bus.emit({\n        type: _shared.ACTION_VERSION_INFO,\n        versionInfo\n    });\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=client.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2NsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7SUE4SW9CQSxlQUFlO2VBQWZBLGlCQUFBQSxPQUFlOztJQUYxQkMsY0FBYztlQUFkQSxnQkFBQUEsY0FBYzs7SUFDZEMsY0FBYztlQUFkQSxpQkFBQUEsY0FBYzs7SUFUUEMsZUFBZTtlQUFmQTs7SUFSQUMsWUFBWTtlQUFaQTs7SUFKQUMsU0FBUztlQUFUQTs7SUFRQUMsU0FBUztlQUFUQTs7SUFRQUMsYUFBYTtlQUFiQTs7SUFuREFDLFFBQVE7ZUFBUkE7O0lBaUJBQyxVQUFVO2VBQVZBOzs7OzsyRUF0R0s7d0NBQ007aURBQ1M7Z0RBSTdCO29DQVNBO3VEQUVtQzs0Q0EySFg7NkNBQ0E7c0ZBQ1k7QUEzSDNDLElBQUlDLGVBQWU7QUFDbkIsSUFBSUMsa0JBQXNDQztBQUUxQyxTQUFTQyxZQUFZQyxLQUFjO0lBQ2pDLElBQUksQ0FBQ0EsU0FBUyxDQUFFQSxDQUFBQSxpQkFBaUJDLEtBQUFBLENBQUksSUFBTSxPQUFPRCxNQUFNRSxLQUFLLEtBQUssVUFBVTtRQUMxRSw4REFBOEQ7UUFDOUQ7SUFDRjtJQUVBQyxDQUFBQSxHQUFBQSwyQkFBQUEseUJBQUFBLEVBQTBCSDtJQUUxQixNQUFNSSxzQkFDSEosTUFBY0ssZUFBZSxJQUFJQyxvQkFBQUEsbUJBQW1CLENBQUNDLGNBQWM7SUFDdEUsTUFBTUMsdUJBQ0osT0FBT0osd0JBQXdCLFdBQzNCSyxDQUFBQSxHQUFBQSxxQkFBQUEsbUJBQW1CLEVBQUNMLHVCQUNwQk47SUFFTixtR0FBbUc7SUFDbkcsd0ZBQXdGO0lBQ3hGLElBQ0VFLE1BQU1VLElBQUksS0FBSyxzQkFDZlYsTUFBTVUsSUFBSSxLQUFLLHVCQUNmO1FBQ0FDLEtBQUlDLElBQUksQ0FBQztZQUNQQyxNQUFNQyxRQUFBQSxzQkFBc0I7WUFDNUJDLFFBQVFmO1lBQ1JnQixRQUFRQyxDQUFBQSxHQUFBQSxZQUFBQSxVQUFBQSxFQUFXakIsTUFBTUUsS0FBSztZQUM5Qk07UUFDRjtJQUNGO0FBQ0Y7QUFFQSxJQUFJVSxtQkFBbUJDLFFBQVFuQixLQUFLO0FBQ3BDLFNBQVNvQjtJQUF5QixpQ0FBR0MsT0FBSDtRQUFHQSxJQUFBQSxDQUFILHVCQUFjOztJQUM5QyxpSkFBaUo7SUFDakosTUFBTXJCLFFBQVFzQixLQUFvQixHQUFvQkQsSUFBSSxDQUFDLEVBQUUsR0FBR0EsQ0FBTztJQUN2RUksQ0FBQUEsR0FBQUEsb0JBQUFBLHVDQUFBQSxLQUEyQ0o7SUFDM0N0QixZQUFZQztJQUNaa0IsaUJBQWlCUSxLQUFLLENBQUNDLE9BQU9SLE9BQU8sRUFBRUU7QUFDekM7QUFFQSxTQUFTTyxpQkFBaUJDLEtBQWlCO0lBQ3pDLE1BQU03QixRQUFRNkIsU0FBQUEsT0FBQUEsS0FBQUEsSUFBQUEsTUFBTzdCLEtBQUs7SUFDMUJELFlBQVlDO0FBQ2Q7QUFFQSxTQUFTOEIscUJBQXFCQyxFQUF5QjtJQUNyRCxNQUFNaEIsU0FBU2dCLE1BQUFBLE9BQUFBLEtBQUFBLElBQUFBLEdBQUloQixNQUFNO0lBQ3pCLElBQ0UsQ0FBQ0EsVUFDRCxDQUFFQSxDQUFBQSxrQkFBa0JkLEtBQUFBLENBQUksSUFDeEIsT0FBT2MsT0FBT2IsS0FBSyxLQUFLLFVBQ3hCO1FBQ0EsOERBQThEO1FBQzlEO0lBQ0Y7SUFFQSxNQUFNOEIsSUFBSWpCO0lBQ1ZKLEtBQUlDLElBQUksQ0FBQztRQUNQQyxNQUFNb0IsUUFBQUEsMEJBQTBCO1FBQ2hDbEIsUUFBUUE7UUFDUkMsUUFBUUMsQ0FBQUEsR0FBQUEsWUFBQUEsVUFBQUEsRUFBV2UsRUFBRTlCLEtBQUs7SUFDNUI7QUFDRjtBQUVPLFNBQVNSO0lBQ2QsSUFBSUUsY0FBYztRQUNoQjtJQUNGO0lBQ0FBLGVBQWU7SUFFZixJQUFJO1FBQ0YsTUFBTXNDLFFBQVFqQyxNQUFNSixlQUFlO1FBQ25DSSxNQUFNSixlQUFlLEdBQUc7UUFDeEJBLGtCQUFrQnFDO0lBQ3BCLEVBQUUsVUFBTSxDQUFDO0lBRVRQLE9BQU9RLGdCQUFnQixDQUFDLFNBQVNQO0lBQ2pDRCxPQUFPUSxnQkFBZ0IsQ0FBQyxzQkFBc0JMO0lBQzlDSCxPQUFPUixPQUFPLENBQUNuQixLQUFLLEdBQUdvQjtBQUN6QjtBQUVPLFNBQVN6QjtJQUNkLElBQUksQ0FBQ0MsY0FBYztRQUNqQjtJQUNGO0lBQ0FBLGVBQWU7SUFFZixJQUFJQyxvQkFBb0JDLFdBQVc7UUFDakMsSUFBSTtZQUNGRyxNQUFNSixlQUFlLEdBQUdBO1FBQzFCLEVBQUUsVUFBTSxDQUFDO1FBQ1RBLGtCQUFrQkM7SUFDcEI7SUFFQTZCLE9BQU9TLG1CQUFtQixDQUFDLFNBQVNSO0lBQ3BDRCxPQUFPUyxtQkFBbUIsQ0FBQyxzQkFBc0JOO0lBQ2pESCxPQUFPUixPQUFPLENBQUNuQixLQUFLLEdBQUdrQjtBQUN6QjtBQUVPLFNBQVMzQjtJQUNkb0IsS0FBSUMsSUFBSSxDQUFDO1FBQUVDLE1BQU13QixRQUFBQSxlQUFlO0lBQUM7QUFDbkM7QUFFTyxTQUFTL0MsYUFBYWdELE9BQWU7SUFDMUMzQixLQUFJQyxJQUFJLENBQUM7UUFBRUMsTUFBTTBCLFFBQUFBLGtCQUFrQjtRQUFFRDtJQUFRO0FBQy9DO0FBRU8sU0FBUzlDO0lBQ2RtQixLQUFJQyxJQUFJLENBQUM7UUFBRUMsTUFBTTJCLFFBQUFBLGNBQWM7SUFBQztBQUNsQztBQUVPLFNBQVNuRDtJQUNkc0IsS0FBSUMsSUFBSSxDQUFDO1FBQUVDLE1BQU00QixRQUFBQSxxQkFBcUI7SUFBQztBQUN6QztBQUVPLFNBQVNoRCxjQUFjaUQsV0FBd0I7SUFDcEQvQixLQUFJQyxJQUFJLENBQUM7UUFBRUMsTUFBTThCLFFBQUFBLG1CQUFtQjtRQUFFRDtJQUFZO0FBQ3BEIiwic291cmNlcyI6WyJDOlxcc3JjXFxjbGllbnRcXGNvbXBvbmVudHNcXHJlYWN0LWRldi1vdmVybGF5XFxwYWdlc1xcY2xpZW50LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ1cyBmcm9tICcuL2J1cydcbmltcG9ydCB7IHBhcnNlU3RhY2sgfSBmcm9tICcuLi9pbnRlcm5hbC9oZWxwZXJzL3BhcnNlLXN0YWNrJ1xuaW1wb3J0IHsgcGFyc2VDb21wb25lbnRTdGFjayB9IGZyb20gJy4uL2ludGVybmFsL2hlbHBlcnMvcGFyc2UtY29tcG9uZW50LXN0YWNrJ1xuaW1wb3J0IHtcbiAgaHlkcmF0aW9uRXJyb3JTdGF0ZSxcbiAgc3RvcmVIeWRyYXRpb25FcnJvclN0YXRlRnJvbUNvbnNvbGVBcmdzLFxufSBmcm9tICcuLi9pbnRlcm5hbC9oZWxwZXJzL2h5ZHJhdGlvbi1lcnJvci1pbmZvJ1xuaW1wb3J0IHtcbiAgQUNUSU9OX0JFRk9SRV9SRUZSRVNILFxuICBBQ1RJT05fQlVJTERfRVJST1IsXG4gIEFDVElPTl9CVUlMRF9PSyxcbiAgQUNUSU9OX1JFRlJFU0gsXG4gIEFDVElPTl9VTkhBTkRMRURfRVJST1IsXG4gIEFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OLFxuICBBQ1RJT05fVkVSU0lPTl9JTkZPLFxufSBmcm9tICcuLi9zaGFyZWQnXG5pbXBvcnQgdHlwZSB7IFZlcnNpb25JbmZvIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2VydmVyL2Rldi9wYXJzZS12ZXJzaW9uLWluZm8nXG5pbXBvcnQgeyBhdHRhY2hIeWRyYXRpb25FcnJvclN0YXRlIH0gZnJvbSAnLi4vaW50ZXJuYWwvaGVscGVycy9hdHRhY2gtaHlkcmF0aW9uLWVycm9yLXN0YXRlJ1xuXG5sZXQgaXNSZWdpc3RlcmVkID0gZmFsc2VcbmxldCBzdGFja1RyYWNlTGltaXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuXG5mdW5jdGlvbiBoYW5kbGVFcnJvcihlcnJvcjogdW5rbm93bikge1xuICBpZiAoIWVycm9yIHx8ICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikgfHwgdHlwZW9mIGVycm9yLnN0YWNrICE9PSAnc3RyaW5nJykge1xuICAgIC8vIEEgbm9uLWVycm9yIHdhcyB0aHJvd24sIHdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gc2hvdy4gOi0oXG4gICAgcmV0dXJuXG4gIH1cblxuICBhdHRhY2hIeWRyYXRpb25FcnJvclN0YXRlKGVycm9yKVxuXG4gIGNvbnN0IGNvbXBvbmVudFN0YWNrVHJhY2UgPVxuICAgIChlcnJvciBhcyBhbnkpLl9jb21wb25lbnRTdGFjayB8fCBoeWRyYXRpb25FcnJvclN0YXRlLmNvbXBvbmVudFN0YWNrXG4gIGNvbnN0IGNvbXBvbmVudFN0YWNrRnJhbWVzID1cbiAgICB0eXBlb2YgY29tcG9uZW50U3RhY2tUcmFjZSA9PT0gJ3N0cmluZydcbiAgICAgID8gcGFyc2VDb21wb25lbnRTdGFjayhjb21wb25lbnRTdGFja1RyYWNlKVxuICAgICAgOiB1bmRlZmluZWRcblxuICAvLyBTa2lwIE1vZHVsZUJ1aWxkRXJyb3IgYW5kIE1vZHVsZU5vdEZvdW5kRXJyb3IsIGFzIGl0IHdpbGwgYmUgc2VudCB0aHJvdWdoIG9uQnVpbGRFcnJvciBjYWxsYmFjay5cbiAgLy8gVGhpcyBpcyB0byBhdm9pZCBzYW1lIGVycm9yIGFzIGRpZmZlcmVudCB0eXBlIHNob3dpbmcgdXAgb24gY2xpZW50IHRvIGNhdXNlIGZsYXNoaW5nLlxuICBpZiAoXG4gICAgZXJyb3IubmFtZSAhPT0gJ01vZHVsZUJ1aWxkRXJyb3InICYmXG4gICAgZXJyb3IubmFtZSAhPT0gJ01vZHVsZU5vdEZvdW5kRXJyb3InXG4gICkge1xuICAgIEJ1cy5lbWl0KHtcbiAgICAgIHR5cGU6IEFDVElPTl9VTkhBTkRMRURfRVJST1IsXG4gICAgICByZWFzb246IGVycm9yLFxuICAgICAgZnJhbWVzOiBwYXJzZVN0YWNrKGVycm9yLnN0YWNrKSxcbiAgICAgIGNvbXBvbmVudFN0YWNrRnJhbWVzLFxuICAgIH0pXG4gIH1cbn1cblxubGV0IG9yaWdDb25zb2xlRXJyb3IgPSBjb25zb2xlLmVycm9yXG5mdW5jdGlvbiBuZXh0SnNIYW5kbGVDb25zb2xlRXJyb3IoLi4uYXJnczogYW55W10pIHtcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2Q1MDMyM2ViODQ1YzVmZGUwZDcyMGNhZTg4OGJmMzVkZWRkMDU1MDYvcGFja2FnZXMvcmVhY3QtcmVjb25jaWxlci9zcmMvUmVhY3RGaWJlckVycm9yTG9nZ2VyLmpzI0w3OFxuICBjb25zdCBlcnJvciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBhcmdzWzFdIDogYXJnc1swXVxuICBzdG9yZUh5ZHJhdGlvbkVycm9yU3RhdGVGcm9tQ29uc29sZUFyZ3MoLi4uYXJncylcbiAgaGFuZGxlRXJyb3IoZXJyb3IpXG4gIG9yaWdDb25zb2xlRXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpXG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkRXJyb3IoZXZlbnQ6IEVycm9yRXZlbnQpIHtcbiAgY29uc3QgZXJyb3IgPSBldmVudD8uZXJyb3JcbiAgaGFuZGxlRXJyb3IoZXJyb3IpXG59XG5cbmZ1bmN0aW9uIG9uVW5oYW5kbGVkUmVqZWN0aW9uKGV2OiBQcm9taXNlUmVqZWN0aW9uRXZlbnQpIHtcbiAgY29uc3QgcmVhc29uID0gZXY/LnJlYXNvblxuICBpZiAoXG4gICAgIXJlYXNvbiB8fFxuICAgICEocmVhc29uIGluc3RhbmNlb2YgRXJyb3IpIHx8XG4gICAgdHlwZW9mIHJlYXNvbi5zdGFjayAhPT0gJ3N0cmluZydcbiAgKSB7XG4gICAgLy8gQSBub24tZXJyb3Igd2FzIHRocm93biwgd2UgZG9uJ3QgaGF2ZSBhbnl0aGluZyB0byBzaG93LiA6LShcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGUgPSByZWFzb25cbiAgQnVzLmVtaXQoe1xuICAgIHR5cGU6IEFDVElPTl9VTkhBTkRMRURfUkVKRUNUSU9OLFxuICAgIHJlYXNvbjogcmVhc29uLFxuICAgIGZyYW1lczogcGFyc2VTdGFjayhlLnN0YWNrISksXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcigpIHtcbiAgaWYgKGlzUmVnaXN0ZXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIGlzUmVnaXN0ZXJlZCA9IHRydWVcblxuICB0cnkge1xuICAgIGNvbnN0IGxpbWl0ID0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0XG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gNTBcbiAgICBzdGFja1RyYWNlTGltaXQgPSBsaW1pdFxuICB9IGNhdGNoIHt9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25VbmhhbmRsZWRFcnJvcilcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIG9uVW5oYW5kbGVkUmVqZWN0aW9uKVxuICB3aW5kb3cuY29uc29sZS5lcnJvciA9IG5leHRKc0hhbmRsZUNvbnNvbGVFcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5yZWdpc3RlcigpIHtcbiAgaWYgKCFpc1JlZ2lzdGVyZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpc1JlZ2lzdGVyZWQgPSBmYWxzZVxuXG4gIGlmIChzdGFja1RyYWNlTGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHRyeSB7XG4gICAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSBzdGFja1RyYWNlTGltaXRcbiAgICB9IGNhdGNoIHt9XG4gICAgc3RhY2tUcmFjZUxpbWl0ID0gdW5kZWZpbmVkXG4gIH1cblxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvblVuaGFuZGxlZEVycm9yKVxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgb25VbmhhbmRsZWRSZWplY3Rpb24pXG4gIHdpbmRvdy5jb25zb2xlLmVycm9yID0gb3JpZ0NvbnNvbGVFcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25CdWlsZE9rKCkge1xuICBCdXMuZW1pdCh7IHR5cGU6IEFDVElPTl9CVUlMRF9PSyB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25CdWlsZEVycm9yKG1lc3NhZ2U6IHN0cmluZykge1xuICBCdXMuZW1pdCh7IHR5cGU6IEFDVElPTl9CVUlMRF9FUlJPUiwgbWVzc2FnZSB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gb25SZWZyZXNoKCkge1xuICBCdXMuZW1pdCh7IHR5cGU6IEFDVElPTl9SRUZSRVNIIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvbkJlZm9yZVJlZnJlc2goKSB7XG4gIEJ1cy5lbWl0KHsgdHlwZTogQUNUSU9OX0JFRk9SRV9SRUZSRVNIIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvblZlcnNpb25JbmZvKHZlcnNpb25JbmZvOiBWZXJzaW9uSW5mbykge1xuICBCdXMuZW1pdCh7IHR5cGU6IEFDVElPTl9WRVJTSU9OX0lORk8sIHZlcnNpb25JbmZvIH0pXG59XG5cbmV4cG9ydCB7IGdldEVycm9yQnlUeXBlIH0gZnJvbSAnLi4vaW50ZXJuYWwvaGVscGVycy9nZXQtZXJyb3ItYnktdHlwZSdcbmV4cG9ydCB7IGdldFNlcnZlckVycm9yIH0gZnJvbSAnLi4vaW50ZXJuYWwvaGVscGVycy9ub2RlLXN0YWNrLWZyYW1lcydcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVhY3REZXZPdmVybGF5IH0gZnJvbSAnLi9SZWFjdERldk92ZXJsYXknXG4iXSwibmFtZXMiOlsiUmVhY3REZXZPdmVybGF5IiwiZ2V0RXJyb3JCeVR5cGUiLCJnZXRTZXJ2ZXJFcnJvciIsIm9uQmVmb3JlUmVmcmVzaCIsIm9uQnVpbGRFcnJvciIsIm9uQnVpbGRPayIsIm9uUmVmcmVzaCIsIm9uVmVyc2lvbkluZm8iLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJpc1JlZ2lzdGVyZWQiLCJzdGFja1RyYWNlTGltaXQiLCJ1bmRlZmluZWQiLCJoYW5kbGVFcnJvciIsImVycm9yIiwiRXJyb3IiLCJzdGFjayIsImF0dGFjaEh5ZHJhdGlvbkVycm9yU3RhdGUiLCJjb21wb25lbnRTdGFja1RyYWNlIiwiX2NvbXBvbmVudFN0YWNrIiwiaHlkcmF0aW9uRXJyb3JTdGF0ZSIsImNvbXBvbmVudFN0YWNrIiwiY29tcG9uZW50U3RhY2tGcmFtZXMiLCJwYXJzZUNvbXBvbmVudFN0YWNrIiwibmFtZSIsIkJ1cyIsImVtaXQiLCJ0eXBlIiwiQUNUSU9OX1VOSEFORExFRF9FUlJPUiIsInJlYXNvbiIsImZyYW1lcyIsInBhcnNlU3RhY2siLCJvcmlnQ29uc29sZUVycm9yIiwiY29uc29sZSIsIm5leHRKc0hhbmRsZUNvbnNvbGVFcnJvciIsImFyZ3MiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJzdG9yZUh5ZHJhdGlvbkVycm9yU3RhdGVGcm9tQ29uc29sZUFyZ3MiLCJhcHBseSIsIndpbmRvdyIsIm9uVW5oYW5kbGVkRXJyb3IiLCJldmVudCIsIm9uVW5oYW5kbGVkUmVqZWN0aW9uIiwiZXYiLCJlIiwiQUNUSU9OX1VOSEFORExFRF9SRUpFQ1RJT04iLCJsaW1pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiQUNUSU9OX0JVSUxEX09LIiwibWVzc2FnZSIsIkFDVElPTl9CVUlMRF9FUlJPUiIsIkFDVElPTl9SRUZSRVNIIiwiQUNUSU9OX0JFRk9SRV9SRUZSRVNIIiwidmVyc2lvbkluZm8iLCJBQ1RJT05fVkVSU0lPTl9JTkZPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/head-manager.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/head-manager.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    default: function() {\n        return initHeadManager;\n    },\n    isEqualNode: function() {\n        return isEqualNode;\n    }\n});\nconst _setattributesfromprops = __webpack_require__(/*! ./set-attributes-from-props */ \"./node_modules/next/dist/client/set-attributes-from-props.js\");\nfunction reactElementToDOM(param) {\n    let { type, props } = param;\n    const el = document.createElement(type);\n    (0, _setattributesfromprops.setAttributesFromProps)(el, props);\n    const { children, dangerouslySetInnerHTML } = props;\n    if (dangerouslySetInnerHTML) {\n        el.innerHTML = dangerouslySetInnerHTML.__html || '';\n    } else if (children) {\n        el.textContent = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n    }\n    return el;\n}\nfunction isEqualNode(oldTag, newTag) {\n    if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n        const nonce = newTag.getAttribute('nonce');\n        // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n        // be stripped if there is no content security policy response header that includes a nonce.\n        if (nonce && !oldTag.getAttribute('nonce')) {\n            const cloneTag = newTag.cloneNode(true);\n            cloneTag.setAttribute('nonce', '');\n            cloneTag.nonce = nonce;\n            return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag);\n        }\n    }\n    return oldTag.isEqualNode(newTag);\n}\nlet updateElements;\nif (true) {\n    updateElements = (type, components)=>{\n        const headEl = document.querySelector('head');\n        if (!headEl) return;\n        const oldTags = new Set(headEl.querySelectorAll(\"\" + type + \"[data-next-head]\"));\n        if (type === 'meta') {\n            const metaCharset = headEl.querySelector('meta[charset]');\n            if (metaCharset !== null) {\n                oldTags.add(metaCharset);\n            }\n        }\n        const newTags = [];\n        for(let i = 0; i < components.length; i++){\n            const component = components[i];\n            const newTag = reactElementToDOM(component);\n            newTag.setAttribute('data-next-head', '');\n            let isNew = true;\n            for (const oldTag of oldTags){\n                if (isEqualNode(oldTag, newTag)) {\n                    oldTags.delete(oldTag);\n                    isNew = false;\n                    break;\n                }\n            }\n            if (isNew) {\n                newTags.push(newTag);\n            }\n        }\n        for (const oldTag of oldTags){\n            var _oldTag_parentNode;\n            (_oldTag_parentNode = oldTag.parentNode) == null ? void 0 : _oldTag_parentNode.removeChild(oldTag);\n        }\n        for (const newTag of newTags){\n            // meta[charset] must be first element so special case\n            if (newTag.tagName.toLowerCase() === 'meta' && newTag.getAttribute('charset') !== null) {\n                headEl.prepend(newTag);\n            }\n            headEl.appendChild(newTag);\n        }\n    };\n} else {}\nfunction initHeadManager() {\n    return {\n        mountedInstances: new Set(),\n        updateHead: (head)=>{\n            const tags = {};\n            head.forEach((h)=>{\n                if (// it won't be inlined. In this case revert to the original behavior\n                h.type === 'link' && h.props['data-optimized-fonts']) {\n                    if (document.querySelector('style[data-href=\"' + h.props['data-href'] + '\"]')) {\n                        return;\n                    } else {\n                        h.props.href = h.props['data-href'];\n                        h.props['data-href'] = undefined;\n                    }\n                }\n                const components = tags[h.type] || [];\n                components.push(h);\n                tags[h.type] = components;\n            });\n            const titleComponent = tags.title ? tags.title[0] : null;\n            let title = '';\n            if (titleComponent) {\n                const { children } = titleComponent.props;\n                title = typeof children === 'string' ? children : Array.isArray(children) ? children.join('') : '';\n            }\n            if (title !== document.title) document.title = title;\n            [\n                'meta',\n                'base',\n                'link',\n                'style',\n                'script'\n            ].forEach((type)=>{\n                updateElements(type, tags[type] || []);\n            });\n        }\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head-manager.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9oZWFkLW1hbmFnZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBeUpBLE9BZ0RDO2VBaER1QkE7O0lBckhSQyxXQUFXO2VBQVhBOzs7b0RBcEN1QjtBQUl2QyxTQUFTQyxrQkFBa0IsS0FBNEI7SUFBNUIsTUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQWUsR0FBNUI7SUFDekIsTUFBTUMsS0FBa0JDLFNBQVNDLGFBQWEsQ0FBQ0o7SUFDL0NLLENBQUFBLEdBQUFBLHdCQUFBQSxzQkFBc0IsRUFBQ0gsSUFBSUQ7SUFFM0IsTUFBTSxFQUFFSyxRQUFRLEVBQUVDLHVCQUF1QixFQUFFLEdBQUdOO0lBQzlDLElBQUlNLHlCQUF5QjtRQUMzQkwsR0FBR00sU0FBUyxHQUFHRCx3QkFBd0JFLE1BQU0sSUFBSTtJQUNuRCxPQUFPLElBQUlILFVBQVU7UUFDbkJKLEdBQUdRLFdBQVcsR0FDWixPQUFPSixhQUFhLFdBQ2hCQSxXQUNBSyxNQUFNQyxPQUFPLENBQUNOLFlBQ1pBLFNBQVNPLElBQUksQ0FBQyxNQUNkO0lBQ1Y7SUFDQSxPQUFPWDtBQUNUO0FBZ0JPLFNBQVNKLFlBQVlnQixNQUFlLEVBQUVDLE1BQWU7SUFDMUQsSUFBSUQsa0JBQWtCRSxlQUFlRCxrQkFBa0JDLGFBQWE7UUFDbEUsTUFBTUMsUUFBUUYsT0FBT0csWUFBWSxDQUFDO1FBQ2xDLDhGQUE4RjtRQUM5Riw0RkFBNEY7UUFDNUYsSUFBSUQsU0FBUyxDQUFDSCxPQUFPSSxZQUFZLENBQUMsVUFBVTtZQUMxQyxNQUFNQyxXQUFXSixPQUFPSyxTQUFTLENBQUM7WUFDbENELFNBQVNFLFlBQVksQ0FBQyxTQUFTO1lBQy9CRixTQUFTRixLQUFLLEdBQUdBO1lBQ2pCLE9BQU9BLFVBQVVILE9BQU9HLEtBQUssSUFBSUgsT0FBT2hCLFdBQVcsQ0FBQ3FCO1FBQ3REO0lBQ0Y7SUFFQSxPQUFPTCxPQUFPaEIsV0FBVyxDQUFDaUI7QUFDNUI7QUFFQSxJ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QkFBUzthQUFTLENBQUNaLE9BQU8sQ0FBQyxDQUFDOUQ7Z0JBQ3BEc0IsZUFBZXRCLE1BQU1xRSxJQUFJLENBQUNyRSxLQUFLLElBQUksRUFBRTtZQUN2QztRQUNGO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsZW9uYVxcUHJvamVjdHNcXHNyY1xcY2xpZW50XFxoZWFkLW1hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2V0QXR0cmlidXRlc0Zyb21Qcm9wcyB9IGZyb20gJy4vc2V0LWF0dHJpYnV0ZXMtZnJvbS1wcm9wcydcblxuaW1wb3J0IHR5cGUgeyBKU1ggfSBmcm9tICdyZWFjdCdcblxuZnVuY3Rpb24gcmVhY3RFbGVtZW50VG9ET00oeyB0eXBlLCBwcm9wcyB9OiBKU1guRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcbiAgY29uc3QgZWw6IEhUTUxFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKVxuICBzZXRBdHRyaWJ1dGVzRnJvbVByb3BzKGVsLCBwcm9wcylcblxuICBjb25zdCB7IGNoaWxkcmVuLCBkYW5nZXJvdXNseVNldElubmVySFRNTCB9ID0gcHJvcHNcbiAgaWYgKGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSB7XG4gICAgZWwuaW5uZXJIVE1MID0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sIHx8ICcnXG4gIH0gZWxzZSBpZiAoY2hpbGRyZW4pIHtcbiAgICBlbC50ZXh0Q29udGVudCA9XG4gICAgICB0eXBlb2YgY2hpbGRyZW4gPT09ICdzdHJpbmcnXG4gICAgICAgID8gY2hpbGRyZW5cbiAgICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgICAgID8gY2hpbGRyZW4uam9pbignJylcbiAgICAgICAgICA6ICcnXG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogV2hlbiBhIGBub25jZWAgaXMgcHJlc2VudCBvbiBhbiBlbGVtZW50LCBicm93c2VycyBzdWNoIGFzIENocm9tZSBhbmQgRmlyZWZveCBzdHJpcCBpdCBvdXQgb2YgdGhlXG4gKiBhY3R1YWwgSFRNTCBhdHRyaWJ1dGVzIGZvciBzZWN1cml0eSByZWFzb25zICp3aGVuIHRoZSBlbGVtZW50IGlzIGFkZGVkIHRvIHRoZSBkb2N1bWVudCouIFRodXMsXG4gKiBnaXZlbiB0d28gZXF1aXZhbGVudCBlbGVtZW50cyB0aGF0IGhhdmUgbm9uY2VzLCBgRWxlbWVudCxpc0VxdWFsTm9kZSgpYCB3aWxsIHJldHVybiBmYWxzZSBpZiBvbmVcbiAqIG9mIHRob3NlIGVsZW1lbnRzIGdldHMgYWRkZWQgdG8gdGhlIGRvY3VtZW50LiBBbHRob3VnaCB0aGUgYGVsZW1lbnQubm9uY2VgIHByb3BlcnR5IHdpbGwgYmUgdGhlXG4gKiBzYW1lIGZvciBib3RoIGVsZW1lbnRzLCB0aGUgb25lIHRoYXQgd2FzIGFkZGVkIHRvIHRoZSBkb2N1bWVudCB3aWxsIHJldHVybiBhbiBlbXB0eSBzdHJpbmcgZm9yXG4gKiBpdHMgbm9uY2UgSFRNTCBhdHRyaWJ1dGUgdmFsdWUuXG4gKlxuICogVGhpcyBjdXN0b20gYGlzRXF1YWxOb2RlKClgIGZ1bmN0aW9uIHRoZXJlZm9yZSByZW1vdmVzIHRoZSBub25jZSB2YWx1ZSBmcm9tIHRoZSBgbmV3VGFnYCBiZWZvcmVcbiAqIGNvbXBhcmluZyBpdCB0byBgb2xkVGFnYCwgcmVzdG9yaW5nIGl0IGFmdGVyd2FyZHMuXG4gKlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTpcbiAqIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMTE0NzEjYzEyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsTm9kZShvbGRUYWc6IEVsZW1lbnQsIG5ld1RhZzogRWxlbWVudCkge1xuICBpZiAob2xkVGFnIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgbmV3VGFnIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICBjb25zdCBub25jZSA9IG5ld1RhZy5nZXRBdHRyaWJ1dGUoJ25vbmNlJylcbiAgICAvLyBPbmx5IHN0cmlwIHRoZSBub25jZSBpZiBgb2xkVGFnYCBoYXMgaGFkIGl0IHN0cmlwcGVkLiBBbiBlbGVtZW50J3Mgbm9uY2UgYXR0cmlidXRlIHdpbGwgbm90XG4gICAgLy8gYmUgc3RyaXBwZWQgaWYgdGhlcmUgaXMgbm8gY29udGVudCBzZWN1cml0eSBwb2xpY3kgcmVzcG9uc2UgaGVhZGVyIHRoYXQgaW5jbHVkZXMgYSBub25jZS5cbiAgICBpZiAobm9uY2UgJiYgIW9sZFRhZy5nZXRBdHRyaWJ1dGUoJ25vbmNlJykpIHtcbiAgICAgIGNvbnN0IGNsb25lVGFnID0gbmV3VGFnLmNsb25lTm9kZSh0cnVlKSBhcyB0eXBlb2YgbmV3VGFnXG4gICAgICBjbG9uZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgJycpXG4gICAgICBjbG9uZVRhZy5ub25jZSA9IG5vbmNlXG4gICAgICByZXR1cm4gbm9uY2UgPT09IG9sZFRhZy5ub25jZSAmJiBvbGRUYWcuaXNFcXVhbE5vZGUoY2xvbmVUYWcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9sZFRhZy5pc0VxdWFsTm9kZShuZXdUYWcpXG59XG5cbmxldCB1cGRhdGVFbGVtZW50czogKHR5cGU6IHN0cmluZywgY29tcG9uZW50czogSlNYLkVsZW1lbnRbXSkgPT4gdm9pZFxuXG5pZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9ORVhUX0hFQUQpIHtcbiAgdXBkYXRlRWxlbWVudHMgPSAodHlwZSwgY29tcG9uZW50cykgPT4ge1xuICAgIGNvbnN0IGhlYWRFbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2hlYWQnKVxuICAgIGlmICghaGVhZEVsKSByZXR1cm5cblxuICAgIGNvbnN0IG9sZFRhZ3MgPSBuZXcgU2V0KGhlYWRFbC5xdWVyeVNlbGVjdG9yQWxsKGAke3R5cGV9W2RhdGEtbmV4dC1oZWFkXWApKVxuXG4gICAgaWYgKHR5cGUgPT09ICdtZXRhJykge1xuICAgICAgY29uc3QgbWV0YUNoYXJzZXQgPSBoZWFkRWwucXVlcnlTZWxlY3RvcignbWV0YVtjaGFyc2V0XScpXG4gICAgICBpZiAobWV0YUNoYXJzZXQgIT09IG51bGwpIHtcbiAgICAgICAgb2xkVGFncy5hZGQobWV0YUNoYXJzZXQpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgbmV3VGFnczogRWxlbWVudFtdID0gW11cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV1cbiAgICAgIGNvbnN0IG5ld1RhZyA9IHJlYWN0RWxlbWVudFRvRE9NKGNvbXBvbmVudClcbiAgICAgIG5ld1RhZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbmV4dC1oZWFkJywgJycpXG5cbiAgICAgIGxldCBpc05ldyA9IHRydWVcbiAgICAgIGZvciAoY29uc3Qgb2xkVGFnIG9mIG9sZFRhZ3MpIHtcbiAgICAgICAgaWYgKGlzRXF1YWxOb2RlKG9sZFRhZywgbmV3VGFnKSkge1xuICAgICAgICAgIG9sZFRhZ3MuZGVsZXRlKG9sZFRhZylcbiAgICAgICAgICBpc05ldyA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgbmV3VGFncy5wdXNoKG5ld1RhZylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IG9sZFRhZyBvZiBvbGRUYWdzKSB7XG4gICAgICBvbGRUYWcucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQob2xkVGFnKVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbmV3VGFnIG9mIG5ld1RhZ3MpIHtcbiAgICAgIC8vIG1ldGFbY2hhcnNldF0gbXVzdCBiZSBmaXJzdCBlbGVtZW50IHNvIHNwZWNpYWwgY2FzZVxuICAgICAgaWYgKFxuICAgICAgICBuZXdUYWcudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnbWV0YScgJiZcbiAgICAgICAgbmV3VGFnLmdldEF0dHJpYnV0ZSgnY2hhcnNldCcpICE9PSBudWxsXG4gICAgICApIHtcbiAgICAgICAgaGVhZEVsLnByZXBlbmQobmV3VGFnKVxuICAgICAgfVxuICAgICAgaGVhZEVsLmFwcGVuZENoaWxkKG5ld1RhZylcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIHVwZGF0ZUVsZW1lbnRzID0gKHR5cGUsIGNvbXBvbmVudHMpID0+IHtcbiAgICBjb25zdCBoZWFkRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdXG4gICAgY29uc3QgaGVhZENvdW50RWw6IEhUTUxNZXRhRWxlbWVudCA9IGhlYWRFbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgJ21ldGFbbmFtZT1uZXh0LWhlYWQtY291bnRdJ1xuICAgICkgYXMgSFRNTE1ldGFFbGVtZW50XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghaGVhZENvdW50RWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAnV2FybmluZzogbmV4dC1oZWFkLWNvdW50IGlzIG1pc3NpbmcuIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaGVhZC1jb3VudC1taXNzaW5nJ1xuICAgICAgICApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGhlYWRDb3VudCA9IE51bWJlcihoZWFkQ291bnRFbC5jb250ZW50KVxuICAgIGNvbnN0IG9sZFRhZ3M6IEVsZW1lbnRbXSA9IFtdXG5cbiAgICBmb3IgKFxuICAgICAgbGV0IGkgPSAwLCBqID0gaGVhZENvdW50RWwucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgIGkgPCBoZWFkQ291bnQ7XG4gICAgICBpKyssIGogPSBqPy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IG51bGxcbiAgICApIHtcbiAgICAgIGlmIChqPy50YWdOYW1lPy50b0xvd2VyQ2FzZSgpID09PSB0eXBlKSB7XG4gICAgICAgIG9sZFRhZ3MucHVzaChqKVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdUYWdzID0gKGNvbXBvbmVudHMubWFwKHJlYWN0RWxlbWVudFRvRE9NKSBhcyBIVE1MRWxlbWVudFtdKS5maWx0ZXIoXG4gICAgICAobmV3VGFnKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwLCBsZW4gPSBvbGRUYWdzLmxlbmd0aDsgayA8IGxlbjsgaysrKSB7XG4gICAgICAgICAgY29uc3Qgb2xkVGFnID0gb2xkVGFnc1trXVxuICAgICAgICAgIGlmIChpc0VxdWFsTm9kZShvbGRUYWcsIG5ld1RhZykpIHtcbiAgICAgICAgICAgIG9sZFRhZ3Muc3BsaWNlKGssIDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICApXG5cbiAgICBvbGRUYWdzLmZvckVhY2goKHQpID0+IHQucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodCkpXG4gICAgbmV3VGFncy5mb3JFYWNoKCh0KSA9PiBoZWFkRWwuaW5zZXJ0QmVmb3JlKHQsIGhlYWRDb3VudEVsKSlcbiAgICBoZWFkQ291bnRFbC5jb250ZW50ID0gKFxuICAgICAgaGVhZENvdW50IC1cbiAgICAgIG9sZFRhZ3MubGVuZ3RoICtcbiAgICAgIG5ld1RhZ3MubGVuZ3RoXG4gICAgKS50b1N0cmluZygpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdEhlYWRNYW5hZ2VyKCk6IHtcbiAgbW91bnRlZEluc3RhbmNlczogU2V0PHVua25vd24+XG4gIHVwZGF0ZUhlYWQ6IChoZWFkOiBKU1guRWxlbWVudFtdKSA9PiB2b2lkXG59IHtcbiAgcmV0dXJuIHtcbiAgICBtb3VudGVkSW5zdGFuY2VzOiBuZXcgU2V0KCksXG4gICAgdXBkYXRlSGVhZDogKGhlYWQ6IEpTWC5FbGVtZW50W10pID0+IHtcbiAgICAgIGNvbnN0IHRhZ3M6IFJlY29yZDxzdHJpbmcsIEpTWC5FbGVtZW50W10+ID0ge31cblxuICAgICAgaGVhZC5mb3JFYWNoKChoKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBJZiB0aGUgZm9udCB0YWcgaXMgbG9hZGVkIG9ubHkgb24gY2xpZW50IG5hdmlnYXRpb25cbiAgICAgICAgICAvLyBpdCB3b24ndCBiZSBpbmxpbmVkLiBJbiB0aGlzIGNhc2UgcmV2ZXJ0IHRvIHRoZSBvcmlnaW5hbCBiZWhhdmlvclxuICAgICAgICAgIGgudHlwZSA9PT0gJ2xpbmsnICYmXG4gICAgICAgICAgaC5wcm9wc1snZGF0YS1vcHRpbWl6ZWQtZm9udHMnXVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzdHlsZVtkYXRhLWhyZWY9XCIke2gucHJvcHNbJ2RhdGEtaHJlZiddfVwiXWApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaC5wcm9wcy5ocmVmID0gaC5wcm9wc1snZGF0YS1ocmVmJ11cbiAgICAgICAgICAgIGgucHJvcHNbJ2RhdGEtaHJlZiddID0gdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHRhZ3NbaC50eXBlXSB8fCBbXVxuICAgICAgICBjb21wb25lbnRzLnB1c2goaClcbiAgICAgICAgdGFnc1toLnR5cGVdID0gY29tcG9uZW50c1xuICAgICAgfSlcblxuICAgICAgY29uc3QgdGl0bGVDb21wb25lbnQgPSB0YWdzLnRpdGxlID8gdGFncy50aXRsZVswXSA6IG51bGxcbiAgICAgIGxldCB0aXRsZSA9ICcnXG4gICAgICBpZiAodGl0bGVDb21wb25lbnQpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGl0bGVDb21wb25lbnQucHJvcHNcbiAgICAgICAgdGl0bGUgPVxuICAgICAgICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gY2hpbGRyZW5cbiAgICAgICAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZHJlbilcbiAgICAgICAgICAgICAgPyBjaGlsZHJlbi5qb2luKCcnKVxuICAgICAgICAgICAgICA6ICcnXG4gICAgICB9XG4gICAgICBpZiAodGl0bGUgIT09IGRvY3VtZW50LnRpdGxlKSBkb2N1bWVudC50aXRsZSA9IHRpdGxlXG4gICAgICA7WydtZXRhJywgJ2Jhc2UnLCAnbGluaycsICdzdHlsZScsICdzY3JpcHQnXS5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHVwZGF0ZUVsZW1lbnRzKHR5cGUsIHRhZ3NbdHlwZV0gfHwgW10pXG4gICAgICB9KVxuICAgIH0sXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbml0SGVhZE1hbmFnZXIiLCJpc0VxdWFsTm9kZSIsInJlYWN0RWxlbWVudFRvRE9NIiwidHlwZSIsInByb3BzIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGVzRnJvbVByb3BzIiwiY2hpbGRyZW4iLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImlubmVySFRNTCIsIl9faHRtbCIsInRleHRDb250ZW50IiwiQXJyYXkiLCJpc0FycmF5Iiwiam9pbiIsIm9sZFRhZyIsIm5ld1RhZyIsIkhUTUxFbGVtZW50Iiwibm9uY2UiLCJnZXRBdHRyaWJ1dGUiLCJjbG9uZVRhZyIsImNsb25lTm9kZSIsInNldEF0dHJpYnV0ZSIsInVwZGF0ZUVsZW1lbnRzIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9TVFJJQ1RfTkVYVF9IRUFEIiwiY29tcG9uZW50cyIsImhlYWRFbCIsInF1ZXJ5U2VsZWN0b3IiLCJvbGRUYWdzIiwiU2V0IiwicXVlcnlTZWxlY3RvckFsbCIsIm1ldGFDaGFyc2V0IiwiYWRkIiwibmV3VGFncyIsImkiLCJsZW5ndGgiLCJjb21wb25lbnQiLCJpc05ldyIsImRlbGV0ZSIsInB1c2giLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJwcmVwZW5kIiwiYXBwZW5kQ2hpbGQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImhlYWRDb3VudEVsIiwiTk9ERV9FTlYiLCJjb25zb2xlIiwiZXJyb3IiLCJoZWFkQ291bnQiLCJOdW1iZXIiLCJjb250ZW50IiwiaiIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJtYXAiLCJmaWx0ZXIiLCJrIiwibGVuIiwic3BsaWNlIiwiZm9yRWFjaCIsInQiLCJpbnNlcnRCZWZvcmUiLCJ0b1N0cmluZyIsIm1vdW50ZWRJbnN0YW5jZXMiLCJ1cGRhdGVIZWFkIiwiaGVhZCIsInRhZ3MiLCJoIiwiaHJlZiIsInVuZGVmaW5lZCIsInRpdGxlQ29tcG9uZW50IiwidGl0bGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/head-manager.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/index.js":
/*!************************************************!*\
  !*** ./node_modules/next/dist/client/index.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* global location */ // imports polyfill from `@next/polyfill-module` after build.\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    emitter: function() {\n        return emitter;\n    },\n    hydrate: function() {\n        return hydrate;\n    },\n    initialize: function() {\n        return initialize;\n    },\n    router: function() {\n        return router;\n    },\n    version: function() {\n        return version;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n__webpack_require__(/*! ../build/polyfills/polyfill-module */ \"./node_modules/next/dist/build/polyfills/polyfill-module.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _client = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom/client */ \"./node_modules/react-dom/client.js\"));\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ../shared/lib/head-manager-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../shared/lib/router/utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _querystring = __webpack_require__(/*! ../shared/lib/router/utils/querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\");\nconst _runtimeconfigexternal = __webpack_require__(/*! ../shared/lib/runtime-config.external */ \"./node_modules/next/dist/shared/lib/runtime-config.external.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _portal = __webpack_require__(/*! ./portal */ \"./node_modules/next/dist/client/portal/index.js\");\nconst _headmanager = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./head-manager */ \"./node_modules/next/dist/client/head-manager.js\"));\nconst _pageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./page-loader */ \"./node_modules/next/dist/client/page-loader.js\"));\nconst _routeannouncer = __webpack_require__(/*! ./route-announcer */ \"./node_modules/next/dist/client/route-announcer.js\");\nconst _router = __webpack_require__(/*! ./router */ \"./node_modules/next/dist/client/router.js\");\nconst _iserror = __webpack_require__(/*! ../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _removebasepath = __webpack_require__(/*! ./remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nconst _hasbasepath = __webpack_require__(/*! ./has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../shared/lib/app-router-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _adapters = __webpack_require__(/*! ../shared/lib/router/adapters */ \"./node_modules/next/dist/shared/lib/router/adapters.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../shared/lib/hooks-client-context.shared-runtime */ \"./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _shared = __webpack_require__(/*! ./react-client-callbacks/shared */ \"./node_modules/next/dist/client/react-client-callbacks/shared.js\");\nconst _tracer = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/tracer */ \"./node_modules/next/dist/client/tracing/tracer.js\"));\nconst _reporttosocket = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./tracing/report-to-socket */ \"./node_modules/next/dist/client/tracing/report-to-socket.js\"));\nconst _isnextroutererror = __webpack_require__(/*! ./components/is-next-router-error */ \"./node_modules/next/dist/client/components/is-next-router-error.js\");\nconst version = \"15.1.6\";\nlet router;\nconst emitter = (0, _mitt.default)();\nconst looseToArray = (input)=>[].slice.call(input);\nlet initialData;\nlet defaultLocale = undefined;\nlet asPath;\nlet pageLoader;\nlet appElement;\nlet headManager;\nlet initialMatchesMiddleware = false;\nlet lastAppProps;\nlet lastRenderReject;\nlet devClient;\nlet CachedApp, onPerfEntry;\nlet CachedComponent;\nclass Container extends _react.default.Component {\n    componentDidCatch(componentErr, info) {\n        this.props.fn(componentErr, info);\n    }\n    componentDidMount() {\n        this.scrollToHash();\n        // We need to replace the router state if:\n        // - the page was (auto) exported and has a query string or search (hash)\n        // - it was auto exported and is a dynamic route (to provide params)\n        // - if it is a client-side skeleton (fallback render)\n        // - if middleware matches the current page (may have rewrite params)\n        // - if rewrites in next.config.js match (may have rewrite params)\n        if (router.isSsr && (initialData.isFallback || initialData.nextExport && ((0, _isdynamic.isDynamicRoute)(router.pathname) || location.search || false || initialMatchesMiddleware) || initialData.props && initialData.props.__N_SSG && (location.search || false || initialMatchesMiddleware))) {\n            // update query on mount for exported pages\n            router.replace(router.pathname + '?' + String((0, _querystring.assign)((0, _querystring.urlQueryToSearchParams)(router.query), new URLSearchParams(location.search))), asPath, {\n                // @ts-ignore\n                // WARNING: `_h` is an internal option for handing Next.js\n                // client-side hydration. Your app should _never_ use this property.\n                // It may change at any time without notice.\n                _h: 1,\n                // Fallback pages must trigger the data fetch, so the transition is\n                // not shallow.\n                // Other pages (strictly updating query) happens shallowly, as data\n                // requirements would already be present.\n                shallow: !initialData.isFallback && !initialMatchesMiddleware\n            }).catch((err)=>{\n                if (!err.cancelled) throw err;\n            });\n        }\n    }\n    componentDidUpdate() {\n        this.scrollToHash();\n    }\n    scrollToHash() {\n        let { hash } = location;\n        hash = hash && hash.substring(1);\n        if (!hash) return;\n        const el = document.getElementById(hash);\n        if (!el) return;\n        // If we call scrollIntoView() in here without a setTimeout\n        // it won't scroll properly.\n        setTimeout(()=>el.scrollIntoView(), 0);\n    }\n    render() {\n        if (false) {} else {\n            const ReactDevOverlay = (__webpack_require__(/*! ./components/react-dev-overlay/pages/client */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js\").ReactDevOverlay);\n            return /*#__PURE__*/ (0, _jsxruntime.jsx)(ReactDevOverlay, {\n                children: this.props.children\n            });\n        }\n    }\n}\nasync function initialize(opts) {\n    if (opts === void 0) opts = {};\n    _tracer.default.onSpanEnd(_reporttosocket.default);\n    // This makes sure this specific lines are removed in production\n    if (true) {\n        devClient = opts.devClient;\n    }\n    initialData = JSON.parse(document.getElementById('__NEXT_DATA__').textContent);\n    window.__NEXT_DATA__ = initialData;\n    defaultLocale = initialData.defaultLocale;\n    const prefix = initialData.assetPrefix || '';\n    self.__next_set_public_path__(\"\" + prefix + \"/_next/\") //eslint-disable-line\n    ;\n    // Initialize next/config with the environment configuration\n    (0, _runtimeconfigexternal.setConfig)({\n        serverRuntimeConfig: {},\n        publicRuntimeConfig: initialData.runtimeConfig || {}\n    });\n    asPath = (0, _utils.getURL)();\n    // make sure not to attempt stripping basePath for 404s\n    if ((0, _hasbasepath.hasBasePath)(asPath)) {\n        asPath = (0, _removebasepath.removeBasePath)(asPath);\n    }\n    if (false) {}\n    if (initialData.scriptLoader) {\n        const { initScriptLoader } = __webpack_require__(/*! ./script */ \"./node_modules/next/dist/client/script.js\");\n        initScriptLoader(initialData.scriptLoader);\n    }\n    pageLoader = new _pageloader.default(initialData.buildId, prefix);\n    const register = (param)=>{\n        let [r, f] = param;\n        return pageLoader.routeLoader.onEntrypoint(r, f);\n    };\n    if (window.__NEXT_P) {\n        // Defer page registration for another tick. This will increase the overall\n        // latency in hydrating the page, but reduce the total blocking time.\n        window.__NEXT_P.map((p)=>setTimeout(()=>register(p), 0));\n    }\n    window.__NEXT_P = [];\n    window.__NEXT_P.push = register;\n    headManager = (0, _headmanager.default)();\n    headManager.getIsSsr = ()=>{\n        return router.isSsr;\n    };\n    appElement = document.getElementById('__next');\n    return {\n        assetPrefix: prefix\n    };\n}\nfunction renderApp(App, appProps) {\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(App, {\n        ...appProps\n    });\n}\nfunction AppContainer(param) {\n    _s();\n    let { children } = param;\n    // Create a memoized value for next/navigation router context.\n    const adaptedForAppRouter = _react.default.useMemo({\n        \"AppContainer.useMemo[adaptedForAppRouter]\": ()=>{\n            return (0, _adapters.adaptForAppRouterInstance)(router);\n        }\n    }[\"AppContainer.useMemo[adaptedForAppRouter]\"], []);\n    var _self___NEXT_DATA___autoExport;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(Container, {\n        fn: (error)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            renderError({\n                App: CachedApp,\n                err: error\n            }).catch((err)=>console.error('Error rendering page: ', err)),\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.AppRouterContext.Provider, {\n            value: adaptedForAppRouter,\n            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.SearchParamsContext.Provider, {\n                value: (0, _adapters.adaptForSearchParams)(router),\n                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_adapters.PathnameContextProviderAdapter, {\n                    router: router,\n                    isAutoExport: (_self___NEXT_DATA___autoExport = self.__NEXT_DATA__.autoExport) != null ? _self___NEXT_DATA___autoExport : false,\n                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_hooksclientcontextsharedruntime.PathParamsContext.Provider, {\n                        value: (0, _adapters.adaptForPathParams)(router),\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routercontextsharedruntime.RouterContext.Provider, {\n                            value: (0, _router.makePublicRouterInstance)(router),\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_headmanagercontextsharedruntime.HeadManagerContext.Provider, {\n                                value: headManager,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_imageconfigcontextsharedruntime.ImageConfigContext.Provider, {\n                                    value: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[],\"remotePatterns\":[]},\n                                    children: children\n                                })\n                            })\n                        })\n                    })\n                })\n            })\n        })\n    });\n}\n_s(AppContainer, \"F6BSfrFQNeqenuPnUMVY/6gI8uE=\");\n_c = AppContainer;\nconst wrapApp = (App)=>(wrappedAppProps)=>{\n        const appProps = {\n            ...wrappedAppProps,\n            Component: CachedComponent,\n            err: initialData.err,\n            router\n        };\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(AppContainer, {\n            children: renderApp(App, appProps)\n        });\n    };\n// This method handles all runtime and debug errors.\n// 404 and 500 errors are special kind of errors\n// and they are still handle via the main render method.\nfunction renderError(renderErrorProps) {\n    let { App, err } = renderErrorProps;\n    // In development runtime errors are caught by our overlay\n    // In production we catch runtime errors using componentDidCatch which will trigger renderError\n    if (true) {\n        // A Next.js rendering runtime error is always unrecoverable\n        // FIXME: let's make this recoverable (error in GIP client-transition)\n        devClient.onUnrecoverableError();\n        // We need to render an empty <App> so that the `<ReactDevOverlay>` can\n        // render itself.\n        // TODO: Fix disabled eslint rule\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return doRender({\n            App: ()=>null,\n            props: {},\n            Component: ()=>null,\n            styleSheets: []\n        });\n    }\n    // Make sure we log the error to the console, otherwise users can't track down issues.\n    console.error(err);\n    console.error(\"A client-side exception has occurred, see here for more info: https://nextjs.org/docs/messages/client-side-exception-occurred\");\n    return pageLoader.loadPage('/_error').then((param)=>{\n        let { page: ErrorComponent, styleSheets } = param;\n        return (lastAppProps == null ? void 0 : lastAppProps.Component) === ErrorComponent ? __webpack_require__.e(/*! import() */ \"node_modules_next_dist_pages__error_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../pages/_error */ \"./node_modules/next/dist/pages/_error.js\", 23)).then((errorModule)=>{\n            return __webpack_require__.e(/*! import() */ \"node_modules_next_dist_pages__app_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! ../pages/_app */ \"./node_modules/next/dist/pages/_app.js\", 23)).then((appModule)=>{\n                App = appModule.default;\n                renderErrorProps.App = App;\n                return errorModule;\n            });\n        }).then((m)=>({\n                ErrorComponent: m.default,\n                styleSheets: []\n            })) : {\n            ErrorComponent,\n            styleSheets\n        };\n    }).then((param)=>{\n        let { ErrorComponent, styleSheets } = param;\n        var _renderErrorProps_props;\n        // In production we do a normal render with the `ErrorComponent` as component.\n        // If we've gotten here upon initial render, we can use the props from the server.\n        // Otherwise, we need to call `getInitialProps` on `App` before mounting.\n        const AppTree = wrapApp(App);\n        const appCtx = {\n            Component: ErrorComponent,\n            AppTree,\n            router,\n            ctx: {\n                err,\n                pathname: initialData.page,\n                query: initialData.query,\n                asPath,\n                AppTree\n            }\n        };\n        return Promise.resolve(((_renderErrorProps_props = renderErrorProps.props) == null ? void 0 : _renderErrorProps_props.err) ? renderErrorProps.props : (0, _utils.loadGetInitialProps)(App, appCtx)).then((initProps)=>// eslint-disable-next-line @typescript-eslint/no-use-before-define\n            doRender({\n                ...renderErrorProps,\n                err,\n                Component: ErrorComponent,\n                styleSheets,\n                props: initProps\n            }));\n    });\n}\n// Dummy component that we render as a child of Root so that we can\n// toggle the correct styles before the page is rendered.\nfunction Head(param) {\n    _s1();\n    let { callback } = param;\n    // We use `useLayoutEffect` to guarantee the callback is executed\n    // as soon as React flushes the update.\n    _react.default.useLayoutEffect({\n        \"Head.useLayoutEffect\": ()=>callback()\n    }[\"Head.useLayoutEffect\"], [\n        callback\n    ]);\n    return null;\n}\n_s1(Head, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c1 = Head;\nconst performanceMarks = {\n    navigationStart: 'navigationStart',\n    beforeRender: 'beforeRender',\n    afterRender: 'afterRender',\n    afterHydrate: 'afterHydrate',\n    routeChange: 'routeChange'\n};\nconst performanceMeasures = {\n    hydration: 'Next.js-hydration',\n    beforeHydration: 'Next.js-before-hydration',\n    routeChangeToRender: 'Next.js-route-change-to-render',\n    render: 'Next.js-render'\n};\nlet reactRoot = null;\n// On initial render a hydrate should always happen\nlet shouldHydrate = true;\nfunction clearMarks() {\n    ;\n    [\n        performanceMarks.beforeRender,\n        performanceMarks.afterHydrate,\n        performanceMarks.afterRender,\n        performanceMarks.routeChange\n    ].forEach((mark)=>performance.clearMarks(mark));\n}\nfunction markHydrateComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterHydrate) // mark end of hydration\n    ;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        const beforeHydrationMeasure = performance.measure(performanceMeasures.beforeHydration, performanceMarks.navigationStart, performanceMarks.beforeRender);\n        const hydrationMeasure = performance.measure(performanceMeasures.hydration, performanceMarks.beforeRender, performanceMarks.afterHydrate);\n        if ( true && // Old versions of Safari don't return `PerformanceMeasure`s from `performance.measure()`\n        beforeHydrationMeasure && hydrationMeasure) {\n            _tracer.default.startSpan('navigation-to-hydration', {\n                startTime: performance.timeOrigin + beforeHydrationMeasure.startTime,\n                attributes: {\n                    pathname: location.pathname,\n                    query: location.search\n                }\n            }).end(performance.timeOrigin + hydrationMeasure.startTime + hydrationMeasure.duration);\n        }\n    }\n    if (onPerfEntry) {\n        performance.getEntriesByName(performanceMeasures.hydration).forEach(onPerfEntry);\n    }\n    clearMarks();\n}\nfunction markRenderComplete() {\n    if (!_utils.ST) return;\n    performance.mark(performanceMarks.afterRender) // mark end of render\n    ;\n    const navStartEntries = performance.getEntriesByName(performanceMarks.routeChange, 'mark');\n    if (!navStartEntries.length) return;\n    const hasBeforeRenderMark = performance.getEntriesByName(performanceMarks.beforeRender, 'mark').length;\n    if (hasBeforeRenderMark) {\n        performance.measure(performanceMeasures.routeChangeToRender, navStartEntries[0].name, performanceMarks.beforeRender);\n        performance.measure(performanceMeasures.render, performanceMarks.beforeRender, performanceMarks.afterRender);\n        if (onPerfEntry) {\n            performance.getEntriesByName(performanceMeasures.render).forEach(onPerfEntry);\n            performance.getEntriesByName(performanceMeasures.routeChangeToRender).forEach(onPerfEntry);\n        }\n    }\n    clearMarks();\n    [\n        performanceMeasures.routeChangeToRender,\n        performanceMeasures.render\n    ].forEach((measure)=>performance.clearMeasures(measure));\n}\nfunction renderReactElement(domEl, fn) {\n    // mark start of hydrate/render\n    if (_utils.ST) {\n        performance.mark(performanceMarks.beforeRender);\n    }\n    const reactEl = fn(shouldHydrate ? markHydrateComplete : markRenderComplete);\n    if (!reactRoot) {\n        // Unlike with createRoot, you don't need a separate root.render() call here\n        reactRoot = _client.default.hydrateRoot(domEl, reactEl, {\n            onRecoverableError: _shared.onRecoverableError\n        });\n        // TODO: Remove shouldHydrate variable when React 18 is stable as it can depend on `reactRoot` existing\n        shouldHydrate = false;\n    } else {\n        const startTransition = _react.default.startTransition;\n        startTransition(()=>{\n            reactRoot.render(reactEl);\n        });\n    }\n}\nfunction Root(param) {\n    _s2();\n    let { callbacks, children } = param;\n    // We use `useLayoutEffect` to guarantee the callbacks are executed\n    // as soon as React flushes the update\n    _react.default.useLayoutEffect({\n        \"Root.useLayoutEffect\": ()=>callbacks.forEach({\n                \"Root.useLayoutEffect\": (callback)=>callback()\n            }[\"Root.useLayoutEffect\"])\n    }[\"Root.useLayoutEffect\"], [\n        callbacks\n    ]);\n    if (false) {}\n    return children;\n}\n_s2(Root, \"n7/vCynhJvM+pLkyL2DMQUF0odM=\");\n_c2 = Root;\nfunction doRender(input) {\n    let { App, Component, props, err } = input;\n    let styleSheets = 'initial' in input ? undefined : input.styleSheets;\n    Component = Component || lastAppProps.Component;\n    props = props || lastAppProps.props;\n    const appProps = {\n        ...props,\n        Component,\n        err,\n        router\n    };\n    // lastAppProps has to be set before ReactDom.render to account for ReactDom throwing an error.\n    lastAppProps = appProps;\n    let canceled = false;\n    let resolvePromise;\n    const renderPromise = new Promise((resolve, reject)=>{\n        if (lastRenderReject) {\n            lastRenderReject();\n        }\n        resolvePromise = ()=>{\n            lastRenderReject = null;\n            resolve();\n        };\n        lastRenderReject = ()=>{\n            canceled = true;\n            lastRenderReject = null;\n            const error = new Error('Cancel rendering route');\n            error.cancelled = true;\n            reject(error);\n        };\n    });\n    // This function has a return type to ensure it doesn't start returning a\n    // Promise. It should remain synchronous.\n    function onStart() {\n        if (!styleSheets || // We use `style-loader` in development, so we don't need to do anything\n        // unless we're in production:\n        \"development\" !== 'production') {\n            return false;\n        }\n        const currentStyleTags = looseToArray(document.querySelectorAll('style[data-n-href]'));\n        const currentHrefs = new Set(currentStyleTags.map((tag)=>tag.getAttribute('data-n-href')));\n        const noscript = document.querySelector('noscript[data-n-css]');\n        const nonce = noscript == null ? void 0 : noscript.getAttribute('data-n-css');\n        styleSheets.forEach((param)=>{\n            let { href, text } = param;\n            if (!currentHrefs.has(href)) {\n                const styleTag = document.createElement('style');\n                styleTag.setAttribute('data-n-href', href);\n                styleTag.setAttribute('media', 'x');\n                if (nonce) {\n                    styleTag.setAttribute('nonce', nonce);\n                }\n                document.head.appendChild(styleTag);\n                styleTag.appendChild(document.createTextNode(text));\n            }\n        });\n        return true;\n    }\n    function onHeadCommit() {\n        if (false) {}\n        if (input.scroll) {\n            const { x, y } = input.scroll;\n            (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                window.scrollTo(x, y);\n            });\n        }\n    }\n    function onRootCommit() {\n        resolvePromise();\n    }\n    onStart();\n    const elem = /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(Head, {\n                callback: onHeadCommit\n            }),\n            /*#__PURE__*/ (0, _jsxruntime.jsxs)(AppContainer, {\n                children: [\n                    renderApp(App, appProps),\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(_portal.Portal, {\n                        type: \"next-route-announcer\",\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_routeannouncer.RouteAnnouncer, {})\n                    })\n                ]\n            })\n        ]\n    });\n    // We catch runtime errors using componentDidCatch which will trigger renderError\n    renderReactElement(appElement, (callback)=>/*#__PURE__*/ (0, _jsxruntime.jsx)(Root, {\n            callbacks: [\n                callback,\n                onRootCommit\n            ],\n            children:  true ? /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.default.StrictMode, {\n                children: elem\n            }) : 0\n        }));\n    return renderPromise;\n}\nasync function render(renderingProps) {\n    // if an error occurs in a server-side page (e.g. in getInitialProps),\n    // skip re-rendering the error page client-side as data-fetching operations\n    // will already have been done on the server and NEXT_DATA contains the correct\n    // data for straight-forward hydration of the error page\n    if (renderingProps.err && // renderingProps.Component might be undefined if there is a top/module-level error\n    (typeof renderingProps.Component === 'undefined' || !renderingProps.isHydratePass)) {\n        await renderError(renderingProps);\n        return;\n    }\n    try {\n        await doRender(renderingProps);\n    } catch (err) {\n        const renderErr = (0, _iserror.getProperError)(err);\n        // bubble up cancelation errors\n        if (renderErr.cancelled) {\n            throw renderErr;\n        }\n        if (true) {\n            // Ensure this error is displayed in the overlay in development\n            setTimeout(()=>{\n                throw renderErr;\n            });\n        }\n        await renderError({\n            ...renderingProps,\n            err: renderErr\n        });\n    }\n}\nasync function hydrate(opts) {\n    let initialErr = initialData.err;\n    try {\n        const appEntrypoint = await pageLoader.routeLoader.whenEntrypoint('/_app');\n        if ('error' in appEntrypoint) {\n            throw appEntrypoint.error;\n        }\n        const { component: app, exports: mod } = appEntrypoint;\n        CachedApp = app;\n        if (mod && mod.reportWebVitals) {\n            onPerfEntry = (param)=>{\n                let { id, name, startTime, value, duration, entryType, entries, attribution } = param;\n                // Combines timestamp with random number for unique ID\n                const uniqueID = Date.now() + \"-\" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);\n                let perfStartEntry;\n                if (entries && entries.length) {\n                    perfStartEntry = entries[0].startTime;\n                }\n                const webVitals = {\n                    id: id || uniqueID,\n                    name,\n                    startTime: startTime || perfStartEntry,\n                    value: value == null ? duration : value,\n                    label: entryType === 'mark' || entryType === 'measure' ? 'custom' : 'web-vital'\n                };\n                if (attribution) {\n                    webVitals.attribution = attribution;\n                }\n                mod.reportWebVitals(webVitals);\n            };\n        }\n        const pageEntrypoint = // error, so we need to skip waiting for the entrypoint.\n         true && initialData.err ? {\n            error: initialData.err\n        } : await pageLoader.routeLoader.whenEntrypoint(initialData.page);\n        if ('error' in pageEntrypoint) {\n            throw pageEntrypoint.error;\n        }\n        CachedComponent = pageEntrypoint.component;\n        if (true) {\n            const { isValidElementType } = __webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\");\n            if (!isValidElementType(CachedComponent)) {\n                throw new Error('The default export is not a React Component in page: \"' + initialData.page + '\"');\n            }\n        }\n    } catch (error) {\n        // This catches errors like throwing in the top level of a module\n        initialErr = (0, _iserror.getProperError)(error);\n    }\n    if (true) {\n        const getServerError = (__webpack_require__(/*! ./components/react-dev-overlay/pages/client */ \"./node_modules/next/dist/client/components/react-dev-overlay/pages/client.js\").getServerError);\n        // Server-side runtime errors need to be re-thrown on the client-side so\n        // that the overlay is rendered.\n        if (initialErr) {\n            if (initialErr === initialData.err) {\n                setTimeout(()=>{\n                    let error;\n                    try {\n                        // Generate a new error object. We `throw` it because some browsers\n                        // will set the `stack` when thrown, and we want to ensure ours is\n                        // not overridden when we re-throw it below.\n                        throw new Error(initialErr.message);\n                    } catch (e) {\n                        error = e;\n                    }\n                    error.name = initialErr.name;\n                    error.stack = initialErr.stack;\n                    const errSource = initialErr.source;\n                    // In development, error the navigation API usage in runtime,\n                    // since it's not allowed to be used in pages router as it doesn't contain error boundary like app router.\n                    if ((0, _isnextroutererror.isNextRouterError)(initialErr)) {\n                        error.message = 'Next.js navigation API is not allowed to be used in Pages Router.';\n                    }\n                    throw getServerError(error, errSource);\n                });\n            } else {\n                setTimeout(()=>{\n                    throw initialErr;\n                });\n            }\n        }\n    }\n    if (window.__NEXT_PRELOADREADY) {\n        await window.__NEXT_PRELOADREADY(initialData.dynamicIds);\n    }\n    router = (0, _router.createRouter)(initialData.page, initialData.query, asPath, {\n        initialProps: initialData.props,\n        pageLoader,\n        App: CachedApp,\n        Component: CachedComponent,\n        wrapApp,\n        err: initialErr,\n        isFallback: Boolean(initialData.isFallback),\n        subscription: (info, App, scroll)=>render(Object.assign({}, info, {\n                App,\n                scroll\n            })),\n        locale: initialData.locale,\n        locales: initialData.locales,\n        defaultLocale,\n        domainLocales: initialData.domainLocales,\n        isPreview: initialData.isPreview\n    });\n    initialMatchesMiddleware = await router._initialMatchesMiddlewarePromise;\n    const renderCtx = {\n        App: CachedApp,\n        initial: true,\n        Component: CachedComponent,\n        props: initialData.props,\n        err: initialErr,\n        isHydratePass: true\n    };\n    if (opts == null ? void 0 : opts.beforeRender) {\n        await opts.beforeRender();\n    }\n    render(renderCtx);\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=index.js.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"AppContainer\");\n$RefreshReg$(_c1, \"Head\");\n$RefreshReg$(_c2, \"Root\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsR0FDbkIsNkRBQTZEOzs7Ozs7Ozs7Ozs7Ozs7SUEwRWhEQSxPQUFPO2VBQVBBOztJQTB2QlNDLE9BQU87ZUFBUEE7O0lBem9CQUMsVUFBVTtlQUFWQTs7SUFsSFhDLE1BQU07ZUFBTkE7O0lBREVDLE9BQU87ZUFBUEE7Ozs7O29CQXZFTjs0RUFReUI7NkVBQ1g7NkRBQ2M7MkVBQ2xCO3dEQUVhO2dEQUNLO3VDQUNKO3lDQUl4QjttREFDbUI7bUNBQ3NCO29DQUV6QjtrRkFDSztpRkFDTDs0Q0FFUTtvQ0FDd0I7cUNBQ3hCOzZEQUNJOzRDQUVKO3lDQUNIOzJEQUNLO3NDQU0xQjs2REFJQTtvQ0FDNEI7NkVBQ2hCO3FGQUNROytDQUNPO0FBdUIzQixNQUFNQSxVQUFVQyxRQUFRQztBQUN4QixJQUFJSDtBQUNKLE1BQU1ILFVBQStCUSxDQUFBQSxHQUFBQSxNQUFBQSxPQUFBQTtBQUU1QyxNQUFNQyxlQUFlLENBQWVDLFFBQW9CLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQUNGO0FBRXRFLElBQUlHO0FBQ0osSUFBSUMsZ0JBQW9DQztBQUN4QyxJQUFJQztBQUNKLElBQUlDO0FBQ0osSUFBSUM7QUFDSixJQUFJQztBQUtKLElBQUlDLDJCQUEyQjtBQUMvQixJQUFJQztBQUVKLElBQUlDO0FBQ0osSUFBSUM7QUFFSixJQUFJQyxXQUF5QkM7QUFDN0IsSUFBSUM7QUFFSixNQUFNQyxrQkFBa0JDLE9BQUFBLE9BQUssQ0FBQ0MsU0FBUztJQUlyQ0Msa0JBQWtCQyxZQUFtQixFQUFFQyxJQUFTLEVBQUU7UUFDaEQsSUFBSSxDQUFDQyxLQUFLLENBQUNDLEVBQUUsQ0FBQ0gsY0FBY0M7SUFDOUI7SUFFQUcsb0JBQW9CO1FBQ2xCLElBQUksQ0FBQ0MsWUFBWTtRQUVqQiwwQ0FBMEM7UUFDMUMseUVBQXlFO1FBQ3pFLG9FQUFvRTtRQUNwRSxzREFB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Q1hPLE9BQU9wQixZQUFZb0IsS0FBSztRQUN4QnNCLEtBQUttTjtRQUNMSCxlQUFlO0lBQ2pCO0lBRUEsSUFBSWpNLFFBQUFBLE9BQUFBLEtBQUFBLElBQUFBLEtBQU1tRyxZQUFZLEVBQUU7UUFDdEIsTUFBTW5HLEtBQUttRyxZQUFZO0lBQ3pCO0lBRUF4RyxPQUFPaVA7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsZW9uYVxcUHJvamVjdHNcXHNyY1xcY2xpZW50XFxpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFsIGxvY2F0aW9uICovXG4vLyBpbXBvcnRzIHBvbHlmaWxsIGZyb20gYEBuZXh0L3BvbHlmaWxsLW1vZHVsZWAgYWZ0ZXIgYnVpbGQuXG5pbXBvcnQgJy4uL2J1aWxkL3BvbHlmaWxscy9wb2x5ZmlsbC1tb2R1bGUnXG5pbXBvcnQgdHlwZSBSb3V0ZXIgZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvcm91dGVyJ1xuaW1wb3J0IHR5cGUge1xuICBBcHBDb21wb25lbnQsXG4gIEFwcFByb3BzLFxuICBQcml2YXRlUm91dGVJbmZvLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci9yb3V0ZXInXG5cbmltcG9ydCBSZWFjdCwgeyB0eXBlIEpTWCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbS9jbGllbnQnXG5pbXBvcnQgeyBIZWFkTWFuYWdlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2hlYWQtbWFuYWdlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IG1pdHQgZnJvbSAnLi4vc2hhcmVkL2xpYi9taXR0J1xuaW1wb3J0IHR5cGUgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL3NoYXJlZC9saWIvbWl0dCdcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgaGFuZGxlU21vb3RoU2Nyb2xsIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGwnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2lzLWR5bmFtaWMnXG5pbXBvcnQge1xuICB1cmxRdWVyeVRvU2VhcmNoUGFyYW1zLFxuICBhc3NpZ24sXG59IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgc2V0Q29uZmlnIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9ydW50aW1lLWNvbmZpZy5leHRlcm5hbCdcbmltcG9ydCB7IGdldFVSTCwgbG9hZEdldEluaXRpYWxQcm9wcywgU1QgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHR5cGUgeyBOZXh0V2ViVml0YWxzTWV0cmljLCBORVhUX0RBVEEgfSBmcm9tICcuLi9zaGFyZWQvbGliL3V0aWxzJ1xuaW1wb3J0IHsgUG9ydGFsIH0gZnJvbSAnLi9wb3J0YWwnXG5pbXBvcnQgaW5pdEhlYWRNYW5hZ2VyIGZyb20gJy4vaGVhZC1tYW5hZ2VyJ1xuaW1wb3J0IFBhZ2VMb2FkZXIgZnJvbSAnLi9wYWdlLWxvYWRlcidcbmltcG9ydCB0eXBlIHsgU3R5bGVTaGVldFR1cGxlIH0gZnJvbSAnLi9wYWdlLWxvYWRlcidcbmltcG9ydCB7IFJvdXRlQW5ub3VuY2VyIH0gZnJvbSAnLi9yb3V0ZS1hbm5vdW5jZXInXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZXIsIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZSB9IGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgZ2V0UHJvcGVyRXJyb3IgfSBmcm9tICcuLi9saWIvaXMtZXJyb3InXG5pbXBvcnQgeyBJbWFnZUNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9zaGFyZWQvbGliL2ltYWdlLWNvbmZpZy1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBJbWFnZUNvbmZpZ0NvbXBsZXRlIH0gZnJvbSAnLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWcnXG5pbXBvcnQgeyByZW1vdmVCYXNlUGF0aCB9IGZyb20gJy4vcmVtb3ZlLWJhc2UtcGF0aCdcbmltcG9ydCB7IGhhc0Jhc2VQYXRoIH0gZnJvbSAnLi9oYXMtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgQXBwUm91dGVyQ29udGV4dCB9IGZyb20gJy4uL3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHtcbiAgYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZSxcbiAgYWRhcHRGb3JQYXRoUGFyYW1zLFxuICBhZGFwdEZvclNlYXJjaFBhcmFtcyxcbiAgUGF0aG5hbWVDb250ZXh0UHJvdmlkZXJBZGFwdGVyLFxufSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci9hZGFwdGVycydcbmltcG9ydCB7XG4gIFNlYXJjaFBhcmFtc0NvbnRleHQsXG4gIFBhdGhQYXJhbXNDb250ZXh0LFxufSBmcm9tICcuLi9zaGFyZWQvbGliL2hvb2tzLWNsaWVudC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHsgb25SZWNvdmVyYWJsZUVycm9yIH0gZnJvbSAnLi9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL3NoYXJlZCdcbmltcG9ydCB0cmFjZXIgZnJvbSAnLi90cmFjaW5nL3RyYWNlcidcbmltcG9ydCByZXBvcnRUb1NvY2tldCBmcm9tICcuL3RyYWNpbmcvcmVwb3J0LXRvLXNvY2tldCdcbmltcG9ydCB7IGlzTmV4dFJvdXRlckVycm9yIH0gZnJvbSAnLi9jb21wb25lbnRzL2lzLW5leHQtcm91dGVyLWVycm9yJ1xuXG4vLy8gPHJlZmVyZW5jZSB0eXBlcz1cInJlYWN0LWRvbS9leHBlcmltZW50YWxcIiAvPlxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIC8qIHRlc3QgZm5zICovXG4gICAgX19ORVhUX0hZRFJBVEVEPzogYm9vbGVhblxuICAgIF9fTkVYVF9IWURSQVRFRF9DQj86ICgpID0+IHZvaWRcblxuICAgIC8qIHByb2QgKi9cbiAgICBfX05FWFRfREFUQV9fOiBORVhUX0RBVEFcbiAgICBfX05FWFRfUDogYW55W11cbiAgfVxufVxudHlwZSBSZW5kZXJSb3V0ZUluZm8gPSBQcml2YXRlUm91dGVJbmZvICYge1xuICBBcHA6IEFwcENvbXBvbmVudFxuICBzY3JvbGw/OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBudWxsXG4gIGlzSHlkcmF0ZVBhc3M/OiBib29sZWFuXG59XG50eXBlIFJlbmRlckVycm9yUHJvcHMgPSBPbWl0PFJlbmRlclJvdXRlSW5mbywgJ0NvbXBvbmVudCcgfCAnc3R5bGVTaGVldHMnPlxudHlwZSBSZWdpc3RlckZuID0gKGlucHV0OiBbc3RyaW5nLCAoKSA9PiB2b2lkXSkgPT4gdm9pZFxuXG5leHBvcnQgY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MuZW52Ll9fTkVYVF9WRVJTSU9OXG5leHBvcnQgbGV0IHJvdXRlcjogUm91dGVyXG5leHBvcnQgY29uc3QgZW1pdHRlcjogTWl0dEVtaXR0ZXI8c3RyaW5nPiA9IG1pdHQoKVxuXG5jb25zdCBsb29zZVRvQXJyYXkgPSA8VCBleHRlbmRzIHt9PihpbnB1dDogYW55KTogVFtdID0+IFtdLnNsaWNlLmNhbGwoaW5wdXQpXG5cbmxldCBpbml0aWFsRGF0YTogTkVYVF9EQVRBXG5sZXQgZGVmYXVsdExvY2FsZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG5sZXQgYXNQYXRoOiBzdHJpbmdcbmxldCBwYWdlTG9hZGVyOiBQYWdlTG9hZGVyXG5sZXQgYXBwRWxlbWVudDogSFRNTEVsZW1lbnQgfCBudWxsXG5sZXQgaGVhZE1hbmFnZXI6IHtcbiAgbW91bnRlZEluc3RhbmNlczogU2V0PHVua25vd24+XG4gIHVwZGF0ZUhlYWQ6IChoZWFkOiBKU1guRWxlbWVudFtdKSA9PiB2b2lkXG4gIGdldElzU3NyPzogKCkgPT4gYm9vbGVhblxufVxubGV0IGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSA9IGZhbHNlXG5sZXQgbGFzdEFwcFByb3BzOiBBcHBQcm9wc1xuXG5sZXQgbGFzdFJlbmRlclJlamVjdDogKCgpID0+IHZvaWQpIHwgbnVsbFxubGV0IGRldkNsaWVudDogYW55XG5cbmxldCBDYWNoZWRBcHA6IEFwcENvbXBvbmVudCwgb25QZXJmRW50cnk6IChtZXRyaWM6IGFueSkgPT4gdm9pZFxubGV0IENhY2hlZENvbXBvbmVudDogUmVhY3QuQ29tcG9uZW50VHlwZVxuXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8e1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZVxuICBmbjogKGVycjogRXJyb3IsIGluZm8/OiBhbnkpID0+IHZvaWRcbn0+IHtcbiAgY29tcG9uZW50RGlkQ2F0Y2goY29tcG9uZW50RXJyOiBFcnJvciwgaW5mbzogYW55KSB7XG4gICAgdGhpcy5wcm9wcy5mbihjb21wb25lbnRFcnIsIGluZm8pXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnNjcm9sbFRvSGFzaCgpXG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlcGxhY2UgdGhlIHJvdXRlciBzdGF0ZSBpZjpcbiAgICAvLyAtIHRoZSBwYWdlIHdhcyAoYXV0bykgZXhwb3J0ZWQgYW5kIGhhcyBhIHF1ZXJ5IHN0cmluZyBvciBzZWFyY2ggKGhhc2gpXG4gICAgLy8gLSBpdCB3YXMgYXV0byBleHBvcnRlZCBhbmQgaXMgYSBkeW5hbWljIHJvdXRlICh0byBwcm92aWRlIHBhcmFtcylcbiAgICAvLyAtIGlmIGl0IGlzIGEgY2xpZW50LXNpZGUgc2tlbGV0b24gKGZhbGxiYWNrIHJlbmRlcilcbiAgICAvLyAtIGlmIG1pZGRsZXdhcmUgbWF0Y2hlcyB0aGUgY3VycmVudCBwYWdlIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICAvLyAtIGlmIHJld3JpdGVzIGluIG5leHQuY29uZmlnLmpzIG1hdGNoIChtYXkgaGF2ZSByZXdyaXRlIHBhcmFtcylcbiAgICBpZiAoXG4gICAgICByb3V0ZXIuaXNTc3IgJiZcbiAgICAgIChpbml0aWFsRGF0YS5pc0ZhbGxiYWNrIHx8XG4gICAgICAgIChpbml0aWFsRGF0YS5uZXh0RXhwb3J0ICYmXG4gICAgICAgICAgKGlzRHluYW1pY1JvdXRlKHJvdXRlci5wYXRobmFtZSkgfHxcbiAgICAgICAgICAgIGxvY2F0aW9uLnNlYXJjaCB8fFxuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyB8fFxuICAgICAgICAgICAgaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlKSkgfHxcbiAgICAgICAgKGluaXRpYWxEYXRhLnByb3BzICYmXG4gICAgICAgICAgaW5pdGlhbERhdGEucHJvcHMuX19OX1NTRyAmJlxuICAgICAgICAgIChsb2NhdGlvbi5zZWFyY2ggfHxcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgfHxcbiAgICAgICAgICAgIGluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSkpKVxuICAgICkge1xuICAgICAgLy8gdXBkYXRlIHF1ZXJ5IG9uIG1vdW50IGZvciBleHBvcnRlZCBwYWdlc1xuICAgICAgcm91dGVyXG4gICAgICAgIC5yZXBsYWNlKFxuICAgICAgICAgIHJvdXRlci5wYXRobmFtZSArXG4gICAgICAgICAgICAnPycgK1xuICAgICAgICAgICAgU3RyaW5nKFxuICAgICAgICAgICAgICBhc3NpZ24oXG4gICAgICAgICAgICAgICAgdXJsUXVlcnlUb1NlYXJjaFBhcmFtcyhyb3V0ZXIucXVlcnkpLFxuICAgICAgICAgICAgICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMobG9jYXRpb24uc2VhcmNoKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGFzUGF0aCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzXG4gICAgICAgICAgICAvLyBjbGllbnQtc2lkZSBoeWRyYXRpb24uIFlvdXIgYXBwIHNob3VsZCBfbmV2ZXJfIHVzZSB0aGlzIHByb3BlcnR5LlxuICAgICAgICAgICAgLy8gSXQgbWF5IGNoYW5nZSBhdCBhbnkgdGltZSB3aXRob3V0IG5vdGljZS5cbiAgICAgICAgICAgIF9oOiAxLFxuICAgICAgICAgICAgLy8gRmFsbGJhY2sgcGFnZXMgbXVzdCB0cmlnZ2VyIHRoZSBkYXRhIGZldGNoLCBzbyB0aGUgdHJhbnNpdGlvbiBpc1xuICAgICAgICAgICAgLy8gbm90IHNoYWxsb3cuXG4gICAgICAgICAgICAvLyBPdGhlciBwYWdlcyAoc3RyaWN0bHkgdXBkYXRpbmcgcXVlcnkpIGhhcHBlbnMgc2hhbGxvd2x5LCBhcyBkYXRhXG4gICAgICAgICAgICAvLyByZXF1aXJlbWVudHMgd291bGQgYWxyZWFkeSBiZSBwcmVzZW50LlxuICAgICAgICAgICAgc2hhbGxvdzogIWluaXRpYWxEYXRhLmlzRmFsbGJhY2sgJiYgIWluaXRpYWxNYXRjaGVzTWlkZGxld2FyZSxcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBpZiAoIWVyci5jYW5jZWxsZWQpIHRocm93IGVyclxuICAgICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB0aGlzLnNjcm9sbFRvSGFzaCgpXG4gIH1cblxuICBzY3JvbGxUb0hhc2goKSB7XG4gICAgbGV0IHsgaGFzaCB9ID0gbG9jYXRpb25cbiAgICBoYXNoID0gaGFzaCAmJiBoYXNoLnN1YnN0cmluZygxKVxuICAgIGlmICghaGFzaCkgcmV0dXJuXG5cbiAgICBjb25zdCBlbDogSFRNTEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaGFzaClcbiAgICBpZiAoIWVsKSByZXR1cm5cblxuICAgIC8vIElmIHdlIGNhbGwgc2Nyb2xsSW50b1ZpZXcoKSBpbiBoZXJlIHdpdGhvdXQgYSBzZXRUaW1lb3V0XG4gICAgLy8gaXQgd29uJ3Qgc2Nyb2xsIHByb3Blcmx5LlxuICAgIHNldFRpbWVvdXQoKCkgPT4gZWwuc2Nyb2xsSW50b1ZpZXcoKSwgMClcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgUmVhY3REZXZPdmVybGF5OiB0eXBlb2YgaW1wb3J0KCcuL2NvbXBvbmVudHMvcmVhY3QtZGV2LW92ZXJsYXkvcGFnZXMvY2xpZW50JykuUmVhY3REZXZPdmVybGF5ID1cbiAgICAgICAgcmVxdWlyZSgnLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2NsaWVudCcpLlJlYWN0RGV2T3ZlcmxheVxuICAgICAgcmV0dXJuIDxSZWFjdERldk92ZXJsYXk+e3RoaXMucHJvcHMuY2hpbGRyZW59PC9SZWFjdERldk92ZXJsYXk+XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbml0aWFsaXplKG9wdHM6IHsgZGV2Q2xpZW50PzogYW55IH0gPSB7fSk6IFByb21pc2U8e1xuICBhc3NldFByZWZpeDogc3RyaW5nXG59PiB7XG4gIHRyYWNlci5vblNwYW5FbmQocmVwb3J0VG9Tb2NrZXQpXG5cbiAgLy8gVGhpcyBtYWtlcyBzdXJlIHRoaXMgc3BlY2lmaWMgbGluZXMgYXJlIHJlbW92ZWQgaW4gcHJvZHVjdGlvblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBkZXZDbGllbnQgPSBvcHRzLmRldkNsaWVudFxuICB9XG5cbiAgaW5pdGlhbERhdGEgPSBKU09OLnBhcnNlKFxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdfX05FWFRfREFUQV9fJykhLnRleHRDb250ZW50IVxuICApXG4gIHdpbmRvdy5fX05FWFRfREFUQV9fID0gaW5pdGlhbERhdGFcblxuICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEuZGVmYXVsdExvY2FsZVxuICBjb25zdCBwcmVmaXg6IHN0cmluZyA9IGluaXRpYWxEYXRhLmFzc2V0UHJlZml4IHx8ICcnXG4gIC8vIFdpdGggZHluYW1pYyBhc3NldFByZWZpeCBpdCdzIG5vIGxvbmdlciBwb3NzaWJsZSB0byBzZXQgYXNzZXRQcmVmaXggYXQgdGhlIGJ1aWxkIHRpbWVcbiAgLy8gU28sIHRoaXMgaXMgaG93IHdlIGRvIGl0IGluIHRoZSBjbGllbnQgc2lkZSBhdCBydW50aW1lXG4gIDsoc2VsZiBhcyBhbnkpLl9fbmV4dF9zZXRfcHVibGljX3BhdGhfXyhgJHtwcmVmaXh9L19uZXh0L2ApIC8vZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIC8vIEluaXRpYWxpemUgbmV4dC9jb25maWcgd2l0aCB0aGUgZW52aXJvbm1lbnQgY29uZmlndXJhdGlvblxuICBzZXRDb25maWcoe1xuICAgIHNlcnZlclJ1bnRpbWVDb25maWc6IHt9LFxuICAgIHB1YmxpY1J1bnRpbWVDb25maWc6IGluaXRpYWxEYXRhLnJ1bnRpbWVDb25maWcgfHwge30sXG4gIH0pXG5cbiAgYXNQYXRoID0gZ2V0VVJMKClcblxuICAvLyBtYWtlIHN1cmUgbm90IHRvIGF0dGVtcHQgc3RyaXBwaW5nIGJhc2VQYXRoIGZvciA0MDRzXG4gIGlmIChoYXNCYXNlUGF0aChhc1BhdGgpKSB7XG4gICAgYXNQYXRoID0gcmVtb3ZlQmFzZVBhdGgoYXNQYXRoKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICBjb25zdCB7IG5vcm1hbGl6ZUxvY2FsZVBhdGggfSA9XG4gICAgICByZXF1aXJlKCcuLi9zaGFyZWQvbGliL2kxOG4vbm9ybWFsaXplLWxvY2FsZS1wYXRoJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2hhcmVkL2xpYi9pMThuL25vcm1hbGl6ZS1sb2NhbGUtcGF0aCcpXG5cbiAgICBjb25zdCB7IGRldGVjdERvbWFpbkxvY2FsZSB9ID1cbiAgICAgIHJlcXVpcmUoJy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpIGFzIHR5cGVvZiBpbXBvcnQoJy4uL3NoYXJlZC9saWIvaTE4bi9kZXRlY3QtZG9tYWluLWxvY2FsZScpXG5cbiAgICBjb25zdCB7IHBhcnNlUmVsYXRpdmVVcmwgfSA9XG4gICAgICByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnKSBhcyB0eXBlb2YgaW1wb3J0KCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9wYXJzZS1yZWxhdGl2ZS11cmwnKVxuXG4gICAgY29uc3QgeyBmb3JtYXRVcmwgfSA9XG4gICAgICByZXF1aXJlKCcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsJykgYXMgdHlwZW9mIGltcG9ydCgnLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvZm9ybWF0LXVybCcpXG5cbiAgICBpZiAoaW5pdGlhbERhdGEubG9jYWxlcykge1xuICAgICAgY29uc3QgcGFyc2VkQXMgPSBwYXJzZVJlbGF0aXZlVXJsKGFzUGF0aClcbiAgICAgIGNvbnN0IGxvY2FsZVBhdGhSZXN1bHQgPSBub3JtYWxpemVMb2NhbGVQYXRoKFxuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSxcbiAgICAgICAgaW5pdGlhbERhdGEubG9jYWxlc1xuICAgICAgKVxuXG4gICAgICBpZiAobG9jYWxlUGF0aFJlc3VsdC5kZXRlY3RlZExvY2FsZSkge1xuICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWVcbiAgICAgICAgYXNQYXRoID0gZm9ybWF0VXJsKHBhcnNlZEFzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVyaXZlIHRoZSBkZWZhdWx0IGxvY2FsZSBpZiBpdCB3YXNuJ3QgZGV0ZWN0ZWQgaW4gdGhlIGFzUGF0aFxuICAgICAgICAvLyBzaW5jZSB3ZSBkb24ndCBwcmVyZW5kZXIgc3RhdGljIHBhZ2VzIHdpdGggYWxsIHBvc3NpYmxlIGRlZmF1bHRcbiAgICAgICAgLy8gbG9jYWxlc1xuICAgICAgICBkZWZhdWx0TG9jYWxlID0gaW5pdGlhbERhdGEubG9jYWxlXG4gICAgICB9XG5cbiAgICAgIC8vIGF0dGVtcHQgZGV0ZWN0aW5nIGRlZmF1bHQgbG9jYWxlIGJhc2VkIG9uIGhvc3RuYW1lXG4gICAgICBjb25zdCBkZXRlY3RlZERvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShcbiAgICAgICAgcHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fRE9NQUlOUyBhcyBhbnksXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZVxuICAgICAgKVxuXG4gICAgICAvLyBUT0RPOiBpbnZlc3RpZ2F0ZSBpZiBkZWZhdWx0TG9jYWxlIG5lZWRzIHRvIGJlIHBvcHVsYXRlZCBhZnRlclxuICAgICAgLy8gaHlkcmF0aW9uIHRvIHByZXZlbnQgbWlzbWF0Y2hlZCByZW5kZXJzXG4gICAgICBpZiAoZGV0ZWN0ZWREb21haW4pIHtcbiAgICAgICAgZGVmYXVsdExvY2FsZSA9IGRldGVjdGVkRG9tYWluLmRlZmF1bHRMb2NhbGVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW5pdGlhbERhdGEuc2NyaXB0TG9hZGVyKSB7XG4gICAgY29uc3QgeyBpbml0U2NyaXB0TG9hZGVyIH0gPSByZXF1aXJlKCcuL3NjcmlwdCcpXG4gICAgaW5pdFNjcmlwdExvYWRlcihpbml0aWFsRGF0YS5zY3JpcHRMb2FkZXIpXG4gIH1cblxuICBwYWdlTG9hZGVyID0gbmV3IFBhZ2VMb2FkZXIoaW5pdGlhbERhdGEuYnVpbGRJZCwgcHJlZml4KVxuXG4gIGNvbnN0IHJlZ2lzdGVyOiBSZWdpc3RlckZuID0gKFtyLCBmXSkgPT5cbiAgICBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLm9uRW50cnlwb2ludChyLCBmKVxuICBpZiAod2luZG93Ll9fTkVYVF9QKSB7XG4gICAgLy8gRGVmZXIgcGFnZSByZWdpc3RyYXRpb24gZm9yIGFub3RoZXIgdGljay4gVGhpcyB3aWxsIGluY3JlYXNlIHRoZSBvdmVyYWxsXG4gICAgLy8gbGF0ZW5jeSBpbiBoeWRyYXRpbmcgdGhlIHBhZ2UsIGJ1dCByZWR1Y2UgdGhlIHRvdGFsIGJsb2NraW5nIHRpbWUuXG4gICAgd2luZG93Ll9fTkVYVF9QLm1hcCgocCkgPT4gc2V0VGltZW91dCgoKSA9PiByZWdpc3RlcihwKSwgMCkpXG4gIH1cbiAgd2luZG93Ll9fTkVYVF9QID0gW11cbiAgOyh3aW5kb3cuX19ORVhUX1AgYXMgYW55KS5wdXNoID0gcmVnaXN0ZXJcblxuICBoZWFkTWFuYWdlciA9IGluaXRIZWFkTWFuYWdlcigpXG4gIGhlYWRNYW5hZ2VyLmdldElzU3NyID0gKCkgPT4ge1xuICAgIHJldHVybiByb3V0ZXIuaXNTc3JcbiAgfVxuXG4gIGFwcEVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnX19uZXh0JylcbiAgcmV0dXJuIHsgYXNzZXRQcmVmaXg6IHByZWZpeCB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFwcChBcHA6IEFwcENvbXBvbmVudCwgYXBwUHJvcHM6IEFwcFByb3BzKSB7XG4gIHJldHVybiA8QXBwIHsuLi5hcHBQcm9wc30gLz5cbn1cblxuZnVuY3Rpb24gQXBwQ29udGFpbmVyKHtcbiAgY2hpbGRyZW4sXG59OiBSZWFjdC5Qcm9wc1dpdGhDaGlsZHJlbjx7fT4pOiBSZWFjdC5SZWFjdEVsZW1lbnQge1xuICAvLyBDcmVhdGUgYSBtZW1vaXplZCB2YWx1ZSBmb3IgbmV4dC9uYXZpZ2F0aW9uIHJvdXRlciBjb250ZXh0LlxuICBjb25zdCBhZGFwdGVkRm9yQXBwUm91dGVyID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIGFkYXB0Rm9yQXBwUm91dGVySW5zdGFuY2Uocm91dGVyKVxuICB9LCBbXSlcbiAgcmV0dXJuIChcbiAgICA8Q29udGFpbmVyXG4gICAgICBmbj17KGVycm9yKSA9PlxuICAgICAgICAvLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICByZW5kZXJFcnJvcih7IEFwcDogQ2FjaGVkQXBwLCBlcnI6IGVycm9yIH0pLmNhdGNoKChlcnIpID0+XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIHBhZ2U6ICcsIGVycilcbiAgICAgICAgKVxuICAgICAgfVxuICAgID5cbiAgICAgIDxBcHBSb3V0ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXthZGFwdGVkRm9yQXBwUm91dGVyfT5cbiAgICAgICAgPFNlYXJjaFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2FkYXB0Rm9yU2VhcmNoUGFyYW1zKHJvdXRlcil9PlxuICAgICAgICAgIDxQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXJcbiAgICAgICAgICAgIHJvdXRlcj17cm91dGVyfVxuICAgICAgICAgICAgaXNBdXRvRXhwb3J0PXtzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydCA/PyBmYWxzZX1cbiAgICAgICAgICA+XG4gICAgICAgICAgICA8UGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2FkYXB0Rm9yUGF0aFBhcmFtcyhyb3V0ZXIpfT5cbiAgICAgICAgICAgICAgPFJvdXRlckNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e21ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXIpfT5cbiAgICAgICAgICAgICAgICA8SGVhZE1hbmFnZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXtoZWFkTWFuYWdlcn0+XG4gICAgICAgICAgICAgICAgICA8SW1hZ2VDb25maWdDb250ZXh0LlByb3ZpZGVyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlPXtcbiAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLmVudlxuICAgICAgICAgICAgICAgICAgICAgICAgLl9fTkVYVF9JTUFHRV9PUFRTIGFzIGFueSBhcyBJbWFnZUNvbmZpZ0NvbXBsZXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICAgICAgICAgICAgPC9JbWFnZUNvbmZpZ0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPC9IZWFkTWFuYWdlckNvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgIDwvUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgIDwvUGF0aFBhcmFtc0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgPC9QYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXI+XG4gICAgICAgIDwvU2VhcmNoUGFyYW1zQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvQXBwUm91dGVyQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKVxufVxuXG5jb25zdCB3cmFwQXBwID1cbiAgKEFwcDogQXBwQ29tcG9uZW50KSA9PlxuICAod3JhcHBlZEFwcFByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+KTogSlNYLkVsZW1lbnQgPT4ge1xuICAgIGNvbnN0IGFwcFByb3BzOiBBcHBQcm9wcyA9IHtcbiAgICAgIC4uLndyYXBwZWRBcHBQcm9wcyxcbiAgICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgICAgZXJyOiBpbml0aWFsRGF0YS5lcnIsXG4gICAgICByb3V0ZXIsXG4gICAgfVxuICAgIHJldHVybiA8QXBwQ29udGFpbmVyPntyZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyl9PC9BcHBDb250YWluZXI+XG4gIH1cblxuLy8gVGhpcyBtZXRob2QgaGFuZGxlcyBhbGwgcnVudGltZSBhbmQgZGVidWcgZXJyb3JzLlxuLy8gNDA0IGFuZCA1MDAgZXJyb3JzIGFyZSBzcGVjaWFsIGtpbmQgb2YgZXJyb3JzXG4vLyBhbmQgdGhleSBhcmUgc3RpbGwgaGFuZGxlIHZpYSB0aGUgbWFpbiByZW5kZXIgbWV0aG9kLlxuZnVuY3Rpb24gcmVuZGVyRXJyb3IocmVuZGVyRXJyb3JQcm9wczogUmVuZGVyRXJyb3JQcm9wcyk6IFByb21pc2U8YW55PiB7XG4gIGxldCB7IEFwcCwgZXJyIH0gPSByZW5kZXJFcnJvclByb3BzXG5cbiAgLy8gSW4gZGV2ZWxvcG1lbnQgcnVudGltZSBlcnJvcnMgYXJlIGNhdWdodCBieSBvdXIgb3ZlcmxheVxuICAvLyBJbiBwcm9kdWN0aW9uIHdlIGNhdGNoIHJ1bnRpbWUgZXJyb3JzIHVzaW5nIGNvbXBvbmVudERpZENhdGNoIHdoaWNoIHdpbGwgdHJpZ2dlciByZW5kZXJFcnJvclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIEEgTmV4dC5qcyByZW5kZXJpbmcgcnVudGltZSBlcnJvciBpcyBhbHdheXMgdW5yZWNvdmVyYWJsZVxuICAgIC8vIEZJWE1FOiBsZXQncyBtYWtlIHRoaXMgcmVjb3ZlcmFibGUgKGVycm9yIGluIEdJUCBjbGllbnQtdHJhbnNpdGlvbilcbiAgICBkZXZDbGllbnQub25VbnJlY292ZXJhYmxlRXJyb3IoKVxuXG4gICAgLy8gV2UgbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgPEFwcD4gc28gdGhhdCB0aGUgYDxSZWFjdERldk92ZXJsYXk+YCBjYW5cbiAgICAvLyByZW5kZXIgaXRzZWxmLlxuICAgIC8vIFRPRE86IEZpeCBkaXNhYmxlZCBlc2xpbnQgcnVsZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICByZXR1cm4gZG9SZW5kZXIoe1xuICAgICAgQXBwOiAoKSA9PiBudWxsLFxuICAgICAgcHJvcHM6IHt9LFxuICAgICAgQ29tcG9uZW50OiAoKSA9PiBudWxsLFxuICAgICAgc3R5bGVTaGVldHM6IFtdLFxuICAgIH0pXG4gIH1cblxuICAvLyBNYWtlIHN1cmUgd2UgbG9nIHRoZSBlcnJvciB0byB0aGUgY29uc29sZSwgb3RoZXJ3aXNlIHVzZXJzIGNhbid0IHRyYWNrIGRvd24gaXNzdWVzLlxuICBjb25zb2xlLmVycm9yKGVycilcbiAgY29uc29sZS5lcnJvcihcbiAgICBgQSBjbGllbnQtc2lkZSBleGNlcHRpb24gaGFzIG9jY3VycmVkLCBzZWUgaGVyZSBmb3IgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9jbGllbnQtc2lkZS1leGNlcHRpb24tb2NjdXJyZWRgXG4gIClcblxuICByZXR1cm4gcGFnZUxvYWRlclxuICAgIC5sb2FkUGFnZSgnL19lcnJvcicpXG4gICAgLnRoZW4oKHsgcGFnZTogRXJyb3JDb21wb25lbnQsIHN0eWxlU2hlZXRzIH0pID0+IHtcbiAgICAgIHJldHVybiBsYXN0QXBwUHJvcHM/LkNvbXBvbmVudCA9PT0gRXJyb3JDb21wb25lbnRcbiAgICAgICAgPyBpbXBvcnQoJy4uL3BhZ2VzL19lcnJvcicpXG4gICAgICAgICAgICAudGhlbigoZXJyb3JNb2R1bGUpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi4vcGFnZXMvX2FwcCcpLnRoZW4oKGFwcE1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIEFwcCA9IGFwcE1vZHVsZS5kZWZhdWx0IGFzIGFueSBhcyBBcHBDb21wb25lbnRcbiAgICAgICAgICAgICAgICByZW5kZXJFcnJvclByb3BzLkFwcCA9IEFwcFxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvck1vZHVsZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChtKSA9PiAoe1xuICAgICAgICAgICAgICBFcnJvckNvbXBvbmVudDogbS5kZWZhdWx0IGFzIFJlYWN0LkNvbXBvbmVudFR5cGU8e30+LFxuICAgICAgICAgICAgICBzdHlsZVNoZWV0czogW10sXG4gICAgICAgICAgICB9KSlcbiAgICAgICAgOiB7IEVycm9yQ29tcG9uZW50LCBzdHlsZVNoZWV0cyB9XG4gICAgfSlcbiAgICAudGhlbigoeyBFcnJvckNvbXBvbmVudCwgc3R5bGVTaGVldHMgfSkgPT4ge1xuICAgICAgLy8gSW4gcHJvZHVjdGlvbiB3ZSBkbyBhIG5vcm1hbCByZW5kZXIgd2l0aCB0aGUgYEVycm9yQ29tcG9uZW50YCBhcyBjb21wb25lbnQuXG4gICAgICAvLyBJZiB3ZSd2ZSBnb3R0ZW4gaGVyZSB1cG9uIGluaXRpYWwgcmVuZGVyLCB3ZSBjYW4gdXNlIHRoZSBwcm9wcyBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIG5lZWQgdG8gY2FsbCBgZ2V0SW5pdGlhbFByb3BzYCBvbiBgQXBwYCBiZWZvcmUgbW91bnRpbmcuXG4gICAgICBjb25zdCBBcHBUcmVlID0gd3JhcEFwcChBcHApXG4gICAgICBjb25zdCBhcHBDdHggPSB7XG4gICAgICAgIENvbXBvbmVudDogRXJyb3JDb21wb25lbnQsXG4gICAgICAgIEFwcFRyZWUsXG4gICAgICAgIHJvdXRlcixcbiAgICAgICAgY3R4OiB7XG4gICAgICAgICAgZXJyLFxuICAgICAgICAgIHBhdGhuYW1lOiBpbml0aWFsRGF0YS5wYWdlLFxuICAgICAgICAgIHF1ZXJ5OiBpbml0aWFsRGF0YS5xdWVyeSxcbiAgICAgICAgICBhc1BhdGgsXG4gICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoXG4gICAgICAgIHJlbmRlckVycm9yUHJvcHMucHJvcHM/LmVyclxuICAgICAgICAgID8gcmVuZGVyRXJyb3JQcm9wcy5wcm9wc1xuICAgICAgICAgIDogbG9hZEdldEluaXRpYWxQcm9wcyhBcHAsIGFwcEN0eClcbiAgICAgICkudGhlbigoaW5pdFByb3BzKSA9PlxuICAgICAgICAvLyBUT0RPOiBGaXggZGlzYWJsZWQgZXNsaW50IHJ1bGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBkb1JlbmRlcih7XG4gICAgICAgICAgLi4ucmVuZGVyRXJyb3JQcm9wcyxcbiAgICAgICAgICBlcnIsXG4gICAgICAgICAgQ29tcG9uZW50OiBFcnJvckNvbXBvbmVudCxcbiAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICBwcm9wczogaW5pdFByb3BzLFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0pXG59XG5cbi8vIER1bW15IGNvbXBvbmVudCB0aGF0IHdlIHJlbmRlciBhcyBhIGNoaWxkIG9mIFJvb3Qgc28gdGhhdCB3ZSBjYW5cbi8vIHRvZ2dsZSB0aGUgY29ycmVjdCBzdHlsZXMgYmVmb3JlIHRoZSBwYWdlIGlzIHJlbmRlcmVkLlxuZnVuY3Rpb24gSGVhZCh7IGNhbGxiYWNrIH06IHsgY2FsbGJhY2s6ICgpID0+IHZvaWQgfSk6IG51bGwge1xuICAvLyBXZSB1c2UgYHVzZUxheW91dEVmZmVjdGAgdG8gZ3VhcmFudGVlIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZFxuICAvLyBhcyBzb29uIGFzIFJlYWN0IGZsdXNoZXMgdGhlIHVwZGF0ZS5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGNhbGxiYWNrKCksIFtjYWxsYmFja10pXG4gIHJldHVybiBudWxsXG59XG5cbmNvbnN0IHBlcmZvcm1hbmNlTWFya3MgPSB7XG4gIG5hdmlnYXRpb25TdGFydDogJ25hdmlnYXRpb25TdGFydCcsXG4gIGJlZm9yZVJlbmRlcjogJ2JlZm9yZVJlbmRlcicsXG4gIGFmdGVyUmVuZGVyOiAnYWZ0ZXJSZW5kZXInLFxuICBhZnRlckh5ZHJhdGU6ICdhZnRlckh5ZHJhdGUnLFxuICByb3V0ZUNoYW5nZTogJ3JvdXRlQ2hhbmdlJyxcbn0gYXMgY29uc3RcblxuY29uc3QgcGVyZm9ybWFuY2VNZWFzdXJlcyA9IHtcbiAgaHlkcmF0aW9uOiAnTmV4dC5qcy1oeWRyYXRpb24nLFxuICBiZWZvcmVIeWRyYXRpb246ICdOZXh0LmpzLWJlZm9yZS1oeWRyYXRpb24nLFxuICByb3V0ZUNoYW5nZVRvUmVuZGVyOiAnTmV4dC5qcy1yb3V0ZS1jaGFuZ2UtdG8tcmVuZGVyJyxcbiAgcmVuZGVyOiAnTmV4dC5qcy1yZW5kZXInLFxufSBhcyBjb25zdFxuXG5sZXQgcmVhY3RSb290OiBhbnkgPSBudWxsXG4vLyBPbiBpbml0aWFsIHJlbmRlciBhIGh5ZHJhdGUgc2hvdWxkIGFsd2F5cyBoYXBwZW5cbmxldCBzaG91bGRIeWRyYXRlOiBib29sZWFuID0gdHJ1ZVxuXG5mdW5jdGlvbiBjbGVhck1hcmtzKCk6IHZvaWQge1xuICA7W1xuICAgIHBlcmZvcm1hbmNlTWFya3MuYmVmb3JlUmVuZGVyLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlLFxuICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXIsXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgXS5mb3JFYWNoKChtYXJrKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKG1hcmspKVxufVxuXG5mdW5jdGlvbiBtYXJrSHlkcmF0ZUNvbXBsZXRlKCk6IHZvaWQge1xuICBpZiAoIVNUKSByZXR1cm5cblxuICBwZXJmb3JtYW5jZS5tYXJrKHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlKSAvLyBtYXJrIGVuZCBvZiBoeWRyYXRpb25cblxuICBjb25zdCBoYXNCZWZvcmVSZW5kZXJNYXJrID0gcGVyZm9ybWFuY2UuZ2V0RW50cmllc0J5TmFtZShcbiAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAnbWFyaydcbiAgKS5sZW5ndGhcbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBjb25zdCBiZWZvcmVIeWRyYXRpb25NZWFzdXJlID0gcGVyZm9ybWFuY2UubWVhc3VyZShcbiAgICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMuYmVmb3JlSHlkcmF0aW9uLFxuICAgICAgcGVyZm9ybWFuY2VNYXJrcy5uYXZpZ2F0aW9uU3RhcnQsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcblxuICAgIGNvbnN0IGh5ZHJhdGlvbk1lYXN1cmUgPSBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5oeWRyYXRpb24sXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJIeWRyYXRlXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiZcbiAgICAgIC8vIE9sZCB2ZXJzaW9ucyBvZiBTYWZhcmkgZG9uJ3QgcmV0dXJuIGBQZXJmb3JtYW5jZU1lYXN1cmVgcyBmcm9tIGBwZXJmb3JtYW5jZS5tZWFzdXJlKClgXG4gICAgICBiZWZvcmVIeWRyYXRpb25NZWFzdXJlICYmXG4gICAgICBoeWRyYXRpb25NZWFzdXJlXG4gICAgKSB7XG4gICAgICB0cmFjZXJcbiAgICAgICAgLnN0YXJ0U3BhbignbmF2aWdhdGlvbi10by1oeWRyYXRpb24nLCB7XG4gICAgICAgICAgc3RhcnRUaW1lOiBwZXJmb3JtYW5jZS50aW1lT3JpZ2luICsgYmVmb3JlSHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUsXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgcXVlcnk6IGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuICAgICAgICAuZW5kKFxuICAgICAgICAgIHBlcmZvcm1hbmNlLnRpbWVPcmlnaW4gK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5zdGFydFRpbWUgK1xuICAgICAgICAgICAgaHlkcmF0aW9uTWVhc3VyZS5kdXJhdGlvblxuICAgICAgICApXG4gICAgfVxuICB9XG5cbiAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgcGVyZm9ybWFuY2VcbiAgICAgIC5nZXRFbnRyaWVzQnlOYW1lKHBlcmZvcm1hbmNlTWVhc3VyZXMuaHlkcmF0aW9uKVxuICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gIH1cbiAgY2xlYXJNYXJrcygpXG59XG5cbmZ1bmN0aW9uIG1hcmtSZW5kZXJDb21wbGV0ZSgpOiB2b2lkIHtcbiAgaWYgKCFTVCkgcmV0dXJuXG5cbiAgcGVyZm9ybWFuY2UubWFyayhwZXJmb3JtYW5jZU1hcmtzLmFmdGVyUmVuZGVyKSAvLyBtYXJrIGVuZCBvZiByZW5kZXJcbiAgY29uc3QgbmF2U3RhcnRFbnRyaWVzOiBQZXJmb3JtYW5jZUVudHJ5TGlzdCA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5yb3V0ZUNoYW5nZSxcbiAgICAnbWFyaydcbiAgKVxuXG4gIGlmICghbmF2U3RhcnRFbnRyaWVzLmxlbmd0aCkgcmV0dXJuXG5cbiAgY29uc3QgaGFzQmVmb3JlUmVuZGVyTWFyayA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeU5hbWUoXG4gICAgcGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIsXG4gICAgJ21hcmsnXG4gICkubGVuZ3RoXG5cbiAgaWYgKGhhc0JlZm9yZVJlbmRlck1hcmspIHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yb3V0ZUNoYW5nZVRvUmVuZGVyLFxuICAgICAgbmF2U3RhcnRFbnRyaWVzWzBdLm5hbWUsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlclxuICAgIClcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKFxuICAgICAgcGVyZm9ybWFuY2VNZWFzdXJlcy5yZW5kZXIsXG4gICAgICBwZXJmb3JtYW5jZU1hcmtzLmJlZm9yZVJlbmRlcixcbiAgICAgIHBlcmZvcm1hbmNlTWFya3MuYWZ0ZXJSZW5kZXJcbiAgICApXG4gICAgaWYgKG9uUGVyZkVudHJ5KSB7XG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcilcbiAgICAgICAgLmZvckVhY2gob25QZXJmRW50cnkpXG4gICAgICBwZXJmb3JtYW5jZVxuICAgICAgICAuZ2V0RW50cmllc0J5TmFtZShwZXJmb3JtYW5jZU1lYXN1cmVzLnJvdXRlQ2hhbmdlVG9SZW5kZXIpXG4gICAgICAgIC5mb3JFYWNoKG9uUGVyZkVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyTWFya3MoKVxuICA7W1xuICAgIHBlcmZvcm1hbmNlTWVhc3VyZXMucm91dGVDaGFuZ2VUb1JlbmRlcixcbiAgICBwZXJmb3JtYW5jZU1lYXN1cmVzLnJlbmRlcixcbiAgXS5mb3JFYWNoKChtZWFzdXJlKSA9PiBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKG1lYXN1cmUpKVxufVxuXG5mdW5jdGlvbiByZW5kZXJSZWFjdEVsZW1lbnQoXG4gIGRvbUVsOiBIVE1MRWxlbWVudCxcbiAgZm46IChjYjogKCkgPT4gdm9pZCkgPT4gSlNYLkVsZW1lbnRcbik6IHZvaWQge1xuICAvLyBtYXJrIHN0YXJ0IG9mIGh5ZHJhdGUvcmVuZGVyXG4gIGlmIChTVCkge1xuICAgIHBlcmZvcm1hbmNlLm1hcmsocGVyZm9ybWFuY2VNYXJrcy5iZWZvcmVSZW5kZXIpXG4gIH1cblxuICBjb25zdCByZWFjdEVsID0gZm4oc2hvdWxkSHlkcmF0ZSA/IG1hcmtIeWRyYXRlQ29tcGxldGUgOiBtYXJrUmVuZGVyQ29tcGxldGUpXG4gIGlmICghcmVhY3RSb290KSB7XG4gICAgLy8gVW5saWtlIHdpdGggY3JlYXRlUm9vdCwgeW91IGRvbid0IG5lZWQgYSBzZXBhcmF0ZSByb290LnJlbmRlcigpIGNhbGwgaGVyZVxuICAgIHJlYWN0Um9vdCA9IFJlYWN0RE9NLmh5ZHJhdGVSb290KGRvbUVsLCByZWFjdEVsLCB7XG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IsXG4gICAgfSlcbiAgICAvLyBUT0RPOiBSZW1vdmUgc2hvdWxkSHlkcmF0ZSB2YXJpYWJsZSB3aGVuIFJlYWN0IDE4IGlzIHN0YWJsZSBhcyBpdCBjYW4gZGVwZW5kIG9uIGByZWFjdFJvb3RgIGV4aXN0aW5nXG4gICAgc2hvdWxkSHlkcmF0ZSA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc3RhcnRUcmFuc2l0aW9uID0gKFJlYWN0IGFzIGFueSkuc3RhcnRUcmFuc2l0aW9uXG4gICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgIHJlYWN0Um9vdC5yZW5kZXIocmVhY3RFbClcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIFJvb3Qoe1xuICBjYWxsYmFja3MsXG4gIGNoaWxkcmVuLFxufTogUmVhY3QuUHJvcHNXaXRoQ2hpbGRyZW48e1xuICBjYWxsYmFja3M6IEFycmF5PCgpID0+IHZvaWQ+XG59Pik6IFJlYWN0LlJlYWN0RWxlbWVudCB7XG4gIC8vIFdlIHVzZSBgdXNlTGF5b3V0RWZmZWN0YCB0byBndWFyYW50ZWUgdGhlIGNhbGxiYWNrcyBhcmUgZXhlY3V0ZWRcbiAgLy8gYXMgc29vbiBhcyBSZWFjdCBmbHVzaGVzIHRoZSB1cGRhdGVcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KFxuICAgICgpID0+IGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soKSksXG4gICAgW2NhbGxiYWNrc11cbiAgKVxuXG4gIGlmIChwcm9jZXNzLmVudi5fX05FWFRfVEVTVF9NT0RFKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURUQgPSB0cnVlXG5cbiAgICAgIGlmICh3aW5kb3cuX19ORVhUX0hZRFJBVEVEX0NCKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfSFlEUkFURURfQ0IoKVxuICAgICAgfVxuICAgIH0sIFtdKVxuICB9XG5cbiAgcmV0dXJuIGNoaWxkcmVuIGFzIFJlYWN0LlJlYWN0RWxlbWVudFxufVxuXG5mdW5jdGlvbiBkb1JlbmRlcihpbnB1dDogUmVuZGVyUm91dGVJbmZvKTogUHJvbWlzZTxhbnk+IHtcbiAgbGV0IHsgQXBwLCBDb21wb25lbnQsIHByb3BzLCBlcnIgfTogUmVuZGVyUm91dGVJbmZvID0gaW5wdXRcbiAgbGV0IHN0eWxlU2hlZXRzOiBTdHlsZVNoZWV0VHVwbGVbXSB8IHVuZGVmaW5lZCA9XG4gICAgJ2luaXRpYWwnIGluIGlucHV0ID8gdW5kZWZpbmVkIDogaW5wdXQuc3R5bGVTaGVldHNcbiAgQ29tcG9uZW50ID0gQ29tcG9uZW50IHx8IGxhc3RBcHBQcm9wcy5Db21wb25lbnRcbiAgcHJvcHMgPSBwcm9wcyB8fCBsYXN0QXBwUHJvcHMucHJvcHNcblxuICBjb25zdCBhcHBQcm9wczogQXBwUHJvcHMgPSB7XG4gICAgLi4ucHJvcHMsXG4gICAgQ29tcG9uZW50LFxuICAgIGVycixcbiAgICByb3V0ZXIsXG4gIH1cbiAgLy8gbGFzdEFwcFByb3BzIGhhcyB0byBiZSBzZXQgYmVmb3JlIFJlYWN0RG9tLnJlbmRlciB0byBhY2NvdW50IGZvciBSZWFjdERvbSB0aHJvd2luZyBhbiBlcnJvci5cbiAgbGFzdEFwcFByb3BzID0gYXBwUHJvcHNcblxuICBsZXQgY2FuY2VsZWQ6IGJvb2xlYW4gPSBmYWxzZVxuICBsZXQgcmVzb2x2ZVByb21pc2U6ICgpID0+IHZvaWRcbiAgY29uc3QgcmVuZGVyUHJvbWlzZSA9IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAobGFzdFJlbmRlclJlamVjdCkge1xuICAgICAgbGFzdFJlbmRlclJlamVjdCgpXG4gICAgfVxuICAgIHJlc29sdmVQcm9taXNlID0gKCkgPT4ge1xuICAgICAgbGFzdFJlbmRlclJlamVjdCA9IG51bGxcbiAgICAgIHJlc29sdmUoKVxuICAgIH1cbiAgICBsYXN0UmVuZGVyUmVqZWN0ID0gKCkgPT4ge1xuICAgICAgY2FuY2VsZWQgPSB0cnVlXG4gICAgICBsYXN0UmVuZGVyUmVqZWN0ID0gbnVsbFxuXG4gICAgICBjb25zdCBlcnJvcjogYW55ID0gbmV3IEVycm9yKCdDYW5jZWwgcmVuZGVyaW5nIHJvdXRlJylcbiAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIHJlamVjdChlcnJvcilcbiAgICB9XG4gIH0pXG5cbiAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgYSByZXR1cm4gdHlwZSB0byBlbnN1cmUgaXQgZG9lc24ndCBzdGFydCByZXR1cm5pbmcgYVxuICAvLyBQcm9taXNlLiBJdCBzaG91bGQgcmVtYWluIHN5bmNocm9ub3VzLlxuICBmdW5jdGlvbiBvblN0YXJ0KCk6IGJvb2xlYW4ge1xuICAgIGlmIChcbiAgICAgICFzdHlsZVNoZWV0cyB8fFxuICAgICAgLy8gV2UgdXNlIGBzdHlsZS1sb2FkZXJgIGluIGRldmVsb3BtZW50LCBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAvLyB1bmxlc3Mgd2UncmUgaW4gcHJvZHVjdGlvbjpcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbidcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRTdHlsZVRhZ3M6IEhUTUxTdHlsZUVsZW1lbnRbXSA9IGxvb3NlVG9BcnJheTxIVE1MU3R5bGVFbGVtZW50PihcbiAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlW2RhdGEtbi1ocmVmXScpXG4gICAgKVxuICAgIGNvbnN0IGN1cnJlbnRIcmVmczogU2V0PHN0cmluZyB8IG51bGw+ID0gbmV3IFNldChcbiAgICAgIGN1cnJlbnRTdHlsZVRhZ3MubWFwKCh0YWcpID0+IHRhZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtbi1ocmVmJykpXG4gICAgKVxuXG4gICAgY29uc3Qgbm9zY3JpcHQ6IEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICdub3NjcmlwdFtkYXRhLW4tY3NzXSdcbiAgICApXG4gICAgY29uc3Qgbm9uY2U6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQgPVxuICAgICAgbm9zY3JpcHQ/LmdldEF0dHJpYnV0ZSgnZGF0YS1uLWNzcycpXG5cbiAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYsIHRleHQgfTogeyBocmVmOiBzdHJpbmc7IHRleHQ6IGFueSB9KSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRIcmVmcy5oYXMoaHJlZikpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpXG4gICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1uLWhyZWYnLCBocmVmKVxuICAgICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgJ3gnKVxuXG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgIHN0eWxlVGFnLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpXG4gICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uSGVhZENvbW1pdCgpOiB2b2lkIHtcbiAgICBpZiAoXG4gICAgICAvLyBUdXJib3BhY2sgaGFzIGl0J3Mgb3duIGNzcyBpbmplY3Rpb24gaGFuZGxpbmcsIHRoaXMgY29kZSBlbmRzIHVwIHJlbW92aW5nIHRoZSBDU1MuXG4gICAgICAhcHJvY2Vzcy5lbnYuVFVSQk9QQUNLICYmXG4gICAgICAvLyBXZSB1c2UgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQsIHNvIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIHVubGVzcyB3ZSdyZSBpbiBwcm9kdWN0aW9uOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgLy8gV2UgY2FuIHNraXAgdGhpcyBkdXJpbmcgaHlkcmF0aW9uLiBSdW5uaW5nIGl0IHdvbnQgY2F1c2UgYW55IGhhcm0sIGJ1dFxuICAgICAgLy8gd2UgbWF5IGFzIHdlbGwgc2F2ZSB0aGUgQ1BVIGN5Y2xlczpcbiAgICAgIHN0eWxlU2hlZXRzICYmXG4gICAgICAvLyBFbnN1cmUgdGhpcyByZW5kZXIgd2FzIG5vdCBjYW5jZWxlZFxuICAgICAgIWNhbmNlbGVkXG4gICAgKSB7XG4gICAgICBjb25zdCBkZXNpcmVkSHJlZnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChzdHlsZVNoZWV0cy5tYXAoKHMpID0+IHMuaHJlZikpXG4gICAgICBjb25zdCBjdXJyZW50U3R5bGVUYWdzOiBIVE1MU3R5bGVFbGVtZW50W10gPVxuICAgICAgICBsb29zZVRvQXJyYXk8SFRNTFN0eWxlRWxlbWVudD4oXG4gICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZGF0YS1uLWhyZWZdJylcbiAgICAgICAgKVxuICAgICAgY29uc3QgY3VycmVudEhyZWZzOiBzdHJpbmdbXSA9IGN1cnJlbnRTdHlsZVRhZ3MubWFwKFxuICAgICAgICAodGFnKSA9PiB0YWcuZ2V0QXR0cmlidXRlKCdkYXRhLW4taHJlZicpIVxuICAgICAgKVxuXG4gICAgICAvLyBUb2dnbGUgYDxzdHlsZT5gIHRhZ3Mgb24gb3Igb2ZmIGRlcGVuZGluZyBvbiBpZiB0aGV5J3JlIG5lZWRlZDpcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGN1cnJlbnRIcmVmcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgIGlmIChkZXNpcmVkSHJlZnMuaGFzKGN1cnJlbnRIcmVmc1tpZHhdKSkge1xuICAgICAgICAgIGN1cnJlbnRTdHlsZVRhZ3NbaWR4XS5yZW1vdmVBdHRyaWJ1dGUoJ21lZGlhJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50U3R5bGVUYWdzW2lkeF0uc2V0QXR0cmlidXRlKCdtZWRpYScsICd4JylcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZW9yZGVyIHN0eWxlcyBpbnRvIGludGVuZGVkIG9yZGVyOlxuICAgICAgbGV0IHJlZmVyZW5jZU5vZGU6IEVsZW1lbnQgfCBudWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcbiAgICAgICAgJ25vc2NyaXB0W2RhdGEtbi1jc3NdJ1xuICAgICAgKVxuICAgICAgaWYgKFxuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSBhbiBpbnZhcmlhbnQ6XG4gICAgICAgIHJlZmVyZW5jZU5vZGVcbiAgICAgICkge1xuICAgICAgICBzdHlsZVNoZWV0cy5mb3JFYWNoKCh7IGhyZWYgfTogeyBocmVmOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRhcmdldFRhZzogRWxlbWVudCB8IG51bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYHN0eWxlW2RhdGEtbi1ocmVmPVwiJHtocmVmfVwiXWBcbiAgICAgICAgICApXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgYW4gaW52YXJpYW50OlxuICAgICAgICAgICAgdGFyZ2V0VGFnXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VOb2RlIS5wYXJlbnROb2RlIS5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgIHRhcmdldFRhZyxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlTm9kZSEubmV4dFNpYmxpbmdcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJlZmVyZW5jZU5vZGUgPSB0YXJnZXRUYWdcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsbHksIGNsZWFuIHVwIHNlcnZlciByZW5kZXJlZCBzdHlsZXNoZWV0czpcbiAgICAgIGxvb3NlVG9BcnJheTxIVE1MTGlua0VsZW1lbnQ+KFxuICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW2RhdGEtbi1wXScpXG4gICAgICApLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLnBhcmVudE5vZGUhLnJlbW92ZUNoaWxkKGVsKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW5wdXQuc2Nyb2xsKSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IGlucHV0LnNjcm9sbFxuICAgICAgaGFuZGxlU21vb3RoU2Nyb2xsKCgpID0+IHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKHgsIHkpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUm9vdENvbW1pdCgpOiB2b2lkIHtcbiAgICByZXNvbHZlUHJvbWlzZSgpXG4gIH1cblxuICBvblN0YXJ0KClcblxuICBjb25zdCBlbGVtOiBKU1guRWxlbWVudCA9IChcbiAgICA8PlxuICAgICAgPEhlYWQgY2FsbGJhY2s9e29uSGVhZENvbW1pdH0gLz5cbiAgICAgIDxBcHBDb250YWluZXI+XG4gICAgICAgIHtyZW5kZXJBcHAoQXBwLCBhcHBQcm9wcyl9XG4gICAgICAgIDxQb3J0YWwgdHlwZT1cIm5leHQtcm91dGUtYW5ub3VuY2VyXCI+XG4gICAgICAgICAgPFJvdXRlQW5ub3VuY2VyIC8+XG4gICAgICAgIDwvUG9ydGFsPlxuICAgICAgPC9BcHBDb250YWluZXI+XG4gICAgPC8+XG4gIClcblxuICAvLyBXZSBjYXRjaCBydW50aW1lIGVycm9ycyB1c2luZyBjb21wb25lbnREaWRDYXRjaCB3aGljaCB3aWxsIHRyaWdnZXIgcmVuZGVyRXJyb3JcbiAgcmVuZGVyUmVhY3RFbGVtZW50KGFwcEVsZW1lbnQhLCAoY2FsbGJhY2spID0+IChcbiAgICA8Um9vdCBjYWxsYmFja3M9e1tjYWxsYmFjaywgb25Sb290Q29tbWl0XX0+XG4gICAgICB7cHJvY2Vzcy5lbnYuX19ORVhUX1NUUklDVF9NT0RFID8gKFxuICAgICAgICA8UmVhY3QuU3RyaWN0TW9kZT57ZWxlbX08L1JlYWN0LlN0cmljdE1vZGU+XG4gICAgICApIDogKFxuICAgICAgICBlbGVtXG4gICAgICApfVxuICAgIDwvUm9vdD5cbiAgKSlcblxuICByZXR1cm4gcmVuZGVyUHJvbWlzZVxufVxuXG5hc3luYyBmdW5jdGlvbiByZW5kZXIocmVuZGVyaW5nUHJvcHM6IFJlbmRlclJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAvLyBpZiBhbiBlcnJvciBvY2N1cnMgaW4gYSBzZXJ2ZXItc2lkZSBwYWdlIChlLmcuIGluIGdldEluaXRpYWxQcm9wcyksXG4gIC8vIHNraXAgcmUtcmVuZGVyaW5nIHRoZSBlcnJvciBwYWdlIGNsaWVudC1zaWRlIGFzIGRhdGEtZmV0Y2hpbmcgb3BlcmF0aW9uc1xuICAvLyB3aWxsIGFscmVhZHkgaGF2ZSBiZWVuIGRvbmUgb24gdGhlIHNlcnZlciBhbmQgTkVYVF9EQVRBIGNvbnRhaW5zIHRoZSBjb3JyZWN0XG4gIC8vIGRhdGEgZm9yIHN0cmFpZ2h0LWZvcndhcmQgaHlkcmF0aW9uIG9mIHRoZSBlcnJvciBwYWdlXG4gIGlmIChcbiAgICByZW5kZXJpbmdQcm9wcy5lcnIgJiZcbiAgICAvLyByZW5kZXJpbmdQcm9wcy5Db21wb25lbnQgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIHRoZXJlIGlzIGEgdG9wL21vZHVsZS1sZXZlbCBlcnJvclxuICAgICh0eXBlb2YgcmVuZGVyaW5nUHJvcHMuQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgIXJlbmRlcmluZ1Byb3BzLmlzSHlkcmF0ZVBhc3MpXG4gICkge1xuICAgIGF3YWl0IHJlbmRlckVycm9yKHJlbmRlcmluZ1Byb3BzKVxuICAgIHJldHVyblxuICB9XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBkb1JlbmRlcihyZW5kZXJpbmdQcm9wcylcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgY29uc3QgcmVuZGVyRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyKVxuICAgIC8vIGJ1YmJsZSB1cCBjYW5jZWxhdGlvbiBlcnJvcnNcbiAgICBpZiAoKHJlbmRlckVyciBhcyBFcnJvciAmIHsgY2FuY2VsbGVkPzogYm9vbGVhbiB9KS5jYW5jZWxsZWQpIHtcbiAgICAgIHRocm93IHJlbmRlckVyclxuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgLy8gRW5zdXJlIHRoaXMgZXJyb3IgaXMgZGlzcGxheWVkIGluIHRoZSBvdmVybGF5IGluIGRldmVsb3BtZW50XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgcmVuZGVyRXJyXG4gICAgICB9KVxuICAgIH1cbiAgICBhd2FpdCByZW5kZXJFcnJvcih7IC4uLnJlbmRlcmluZ1Byb3BzLCBlcnI6IHJlbmRlckVyciB9KVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoeWRyYXRlKG9wdHM/OiB7IGJlZm9yZVJlbmRlcj86ICgpID0+IFByb21pc2U8dm9pZD4gfSkge1xuICBsZXQgaW5pdGlhbEVyciA9IGluaXRpYWxEYXRhLmVyclxuXG4gIHRyeSB7XG4gICAgY29uc3QgYXBwRW50cnlwb2ludCA9IGF3YWl0IHBhZ2VMb2FkZXIucm91dGVMb2FkZXIud2hlbkVudHJ5cG9pbnQoJy9fYXBwJylcbiAgICBpZiAoJ2Vycm9yJyBpbiBhcHBFbnRyeXBvaW50KSB7XG4gICAgICB0aHJvdyBhcHBFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuXG4gICAgY29uc3QgeyBjb21wb25lbnQ6IGFwcCwgZXhwb3J0czogbW9kIH0gPSBhcHBFbnRyeXBvaW50XG4gICAgQ2FjaGVkQXBwID0gYXBwIGFzIEFwcENvbXBvbmVudFxuICAgIGlmIChtb2QgJiYgbW9kLnJlcG9ydFdlYlZpdGFscykge1xuICAgICAgb25QZXJmRW50cnkgPSAoe1xuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3RhcnRUaW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVudHJ5VHlwZSxcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgYXR0cmlidXRpb24sXG4gICAgICB9OiBhbnkpOiB2b2lkID0+IHtcbiAgICAgICAgLy8gQ29tYmluZXMgdGltZXN0YW1wIHdpdGggcmFuZG9tIG51bWJlciBmb3IgdW5pcXVlIElEXG4gICAgICAgIGNvbnN0IHVuaXF1ZUlEOiBzdHJpbmcgPSBgJHtEYXRlLm5vdygpfS0ke1xuICAgICAgICAgIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICg5ZTEyIC0gMSkpICsgMWUxMlxuICAgICAgICB9YFxuICAgICAgICBsZXQgcGVyZlN0YXJ0RW50cnk6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmIChlbnRyaWVzICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGVyZlN0YXJ0RW50cnkgPSBlbnRyaWVzWzBdLnN0YXJ0VGltZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2ViVml0YWxzOiBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICAgICAgICAgIGlkOiBpZCB8fCB1bmlxdWVJRCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lIHx8IHBlcmZTdGFydEVudHJ5LFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZSA9PSBudWxsID8gZHVyYXRpb24gOiB2YWx1ZSxcbiAgICAgICAgICBsYWJlbDpcbiAgICAgICAgICAgIGVudHJ5VHlwZSA9PT0gJ21hcmsnIHx8IGVudHJ5VHlwZSA9PT0gJ21lYXN1cmUnXG4gICAgICAgICAgICAgID8gJ2N1c3RvbSdcbiAgICAgICAgICAgICAgOiAnd2ViLXZpdGFsJyxcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cmlidXRpb24pIHtcbiAgICAgICAgICB3ZWJWaXRhbHMuYXR0cmlidXRpb24gPSBhdHRyaWJ1dGlvblxuICAgICAgICB9XG4gICAgICAgIG1vZC5yZXBvcnRXZWJWaXRhbHMod2ViVml0YWxzKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VFbnRyeXBvaW50ID1cbiAgICAgIC8vIFRoZSBkZXYgc2VydmVyIGZhaWxzIHRvIHNlcnZlIHNjcmlwdCBhc3NldHMgd2hlbiB0aGVyZSdzIGEgaHlkcmF0aW9uXG4gICAgICAvLyBlcnJvciwgc28gd2UgbmVlZCB0byBza2lwIHdhaXRpbmcgZm9yIHRoZSBlbnRyeXBvaW50LlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgaW5pdGlhbERhdGEuZXJyXG4gICAgICAgID8geyBlcnJvcjogaW5pdGlhbERhdGEuZXJyIH1cbiAgICAgICAgOiBhd2FpdCBwYWdlTG9hZGVyLnJvdXRlTG9hZGVyLndoZW5FbnRyeXBvaW50KGluaXRpYWxEYXRhLnBhZ2UpXG4gICAgaWYgKCdlcnJvcicgaW4gcGFnZUVudHJ5cG9pbnQpIHtcbiAgICAgIHRocm93IHBhZ2VFbnRyeXBvaW50LmVycm9yXG4gICAgfVxuICAgIENhY2hlZENvbXBvbmVudCA9IHBhZ2VFbnRyeXBvaW50LmNvbXBvbmVudFxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGNvbnN0IHsgaXNWYWxpZEVsZW1lbnRUeXBlIH0gPSByZXF1aXJlKCduZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXMnKVxuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUoQ2FjaGVkQ29tcG9uZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBkZWZhdWx0IGV4cG9ydCBpcyBub3QgYSBSZWFjdCBDb21wb25lbnQgaW4gcGFnZTogXCIke2luaXRpYWxEYXRhLnBhZ2V9XCJgXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBjYXRjaGVzIGVycm9ycyBsaWtlIHRocm93aW5nIGluIHRoZSB0b3AgbGV2ZWwgb2YgYSBtb2R1bGVcbiAgICBpbml0aWFsRXJyID0gZ2V0UHJvcGVyRXJyb3IoZXJyb3IpXG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBnZXRTZXJ2ZXJFcnJvcjogdHlwZW9mIGltcG9ydCgnLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L3BhZ2VzL2NsaWVudCcpLmdldFNlcnZlckVycm9yID1cbiAgICAgIHJlcXVpcmUoJy4vY29tcG9uZW50cy9yZWFjdC1kZXYtb3ZlcmxheS9wYWdlcy9jbGllbnQnKS5nZXRTZXJ2ZXJFcnJvclxuICAgIC8vIFNlcnZlci1zaWRlIHJ1bnRpbWUgZXJyb3JzIG5lZWQgdG8gYmUgcmUtdGhyb3duIG9uIHRoZSBjbGllbnQtc2lkZSBzb1xuICAgIC8vIHRoYXQgdGhlIG92ZXJsYXkgaXMgcmVuZGVyZWQuXG4gICAgaWYgKGluaXRpYWxFcnIpIHtcbiAgICAgIGlmIChpbml0aWFsRXJyID09PSBpbml0aWFsRGF0YS5lcnIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgbGV0IGVycm9yXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IGVycm9yIG9iamVjdC4gV2UgYHRocm93YCBpdCBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIHdpbGwgc2V0IHRoZSBgc3RhY2tgIHdoZW4gdGhyb3duLCBhbmQgd2Ugd2FudCB0byBlbnN1cmUgb3VycyBpc1xuICAgICAgICAgICAgLy8gbm90IG92ZXJyaWRkZW4gd2hlbiB3ZSByZS10aHJvdyBpdCBiZWxvdy5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihpbml0aWFsRXJyIS5tZXNzYWdlKVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZSBhcyBFcnJvclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yLm5hbWUgPSBpbml0aWFsRXJyIS5uYW1lXG4gICAgICAgICAgZXJyb3Iuc3RhY2sgPSBpbml0aWFsRXJyIS5zdGFja1xuICAgICAgICAgIGNvbnN0IGVyclNvdXJjZSA9IGluaXRpYWxFcnIuc291cmNlIVxuXG4gICAgICAgICAgLy8gSW4gZGV2ZWxvcG1lbnQsIGVycm9yIHRoZSBuYXZpZ2F0aW9uIEFQSSB1c2FnZSBpbiBydW50aW1lLFxuICAgICAgICAgIC8vIHNpbmNlIGl0J3Mgbm90IGFsbG93ZWQgdG8gYmUgdXNlZCBpbiBwYWdlcyByb3V0ZXIgYXMgaXQgZG9lc24ndCBjb250YWluIGVycm9yIGJvdW5kYXJ5IGxpa2UgYXBwIHJvdXRlci5cbiAgICAgICAgICBpZiAoaXNOZXh0Um91dGVyRXJyb3IoaW5pdGlhbEVycikpIHtcbiAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPVxuICAgICAgICAgICAgICAnTmV4dC5qcyBuYXZpZ2F0aW9uIEFQSSBpcyBub3QgYWxsb3dlZCB0byBiZSB1c2VkIGluIFBhZ2VzIFJvdXRlci4nXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhyb3cgZ2V0U2VydmVyRXJyb3IoZXJyb3IsIGVyclNvdXJjZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIC8vIFdlIHJlcGxhY2VkIHRoZSBzZXJ2ZXItc2lkZSBlcnJvciB3aXRoIGEgY2xpZW50LXNpZGUgZXJyb3IsIGFuZCBzaG91bGRcbiAgICAgIC8vIG5vIGxvbmdlciByZXdyaXRlIHRoZSBzdGFjayB0cmFjZSB0byBhIE5vZGUgZXJyb3IuXG4gICAgICBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhyb3cgaW5pdGlhbEVyclxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh3aW5kb3cuX19ORVhUX1BSRUxPQURSRUFEWSkge1xuICAgIGF3YWl0IHdpbmRvdy5fX05FWFRfUFJFTE9BRFJFQURZKGluaXRpYWxEYXRhLmR5bmFtaWNJZHMpXG4gIH1cblxuICByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdGlhbERhdGEucGFnZSwgaW5pdGlhbERhdGEucXVlcnksIGFzUGF0aCwge1xuICAgIGluaXRpYWxQcm9wczogaW5pdGlhbERhdGEucHJvcHMsXG4gICAgcGFnZUxvYWRlcixcbiAgICBBcHA6IENhY2hlZEFwcCxcbiAgICBDb21wb25lbnQ6IENhY2hlZENvbXBvbmVudCxcbiAgICB3cmFwQXBwLFxuICAgIGVycjogaW5pdGlhbEVycixcbiAgICBpc0ZhbGxiYWNrOiBCb29sZWFuKGluaXRpYWxEYXRhLmlzRmFsbGJhY2spLFxuICAgIHN1YnNjcmlwdGlvbjogKGluZm8sIEFwcCwgc2Nyb2xsKSA9PlxuICAgICAgcmVuZGVyKFxuICAgICAgICBPYmplY3QuYXNzaWduPFxuICAgICAgICAgIHt9LFxuICAgICAgICAgIE9taXQ8UmVuZGVyUm91dGVJbmZvLCAnQXBwJyB8ICdzY3JvbGwnPixcbiAgICAgICAgICBQaWNrPFJlbmRlclJvdXRlSW5mbywgJ0FwcCcgfCAnc2Nyb2xsJz5cbiAgICAgICAgPih7fSwgaW5mbywge1xuICAgICAgICAgIEFwcCxcbiAgICAgICAgICBzY3JvbGwsXG4gICAgICAgIH0pIGFzIFJlbmRlclJvdXRlSW5mb1xuICAgICAgKSxcbiAgICBsb2NhbGU6IGluaXRpYWxEYXRhLmxvY2FsZSxcbiAgICBsb2NhbGVzOiBpbml0aWFsRGF0YS5sb2NhbGVzLFxuICAgIGRlZmF1bHRMb2NhbGUsXG4gICAgZG9tYWluTG9jYWxlczogaW5pdGlhbERhdGEuZG9tYWluTG9jYWxlcyxcbiAgICBpc1ByZXZpZXc6IGluaXRpYWxEYXRhLmlzUHJldmlldyxcbiAgfSlcblxuICBpbml0aWFsTWF0Y2hlc01pZGRsZXdhcmUgPSBhd2FpdCByb3V0ZXIuX2luaXRpYWxNYXRjaGVzTWlkZGxld2FyZVByb21pc2VcblxuICBjb25zdCByZW5kZXJDdHg6IFJlbmRlclJvdXRlSW5mbyA9IHtcbiAgICBBcHA6IENhY2hlZEFwcCxcbiAgICBpbml0aWFsOiB0cnVlLFxuICAgIENvbXBvbmVudDogQ2FjaGVkQ29tcG9uZW50LFxuICAgIHByb3BzOiBpbml0aWFsRGF0YS5wcm9wcyxcbiAgICBlcnI6IGluaXRpYWxFcnIsXG4gICAgaXNIeWRyYXRlUGFzczogdHJ1ZSxcbiAgfVxuXG4gIGlmIChvcHRzPy5iZWZvcmVSZW5kZXIpIHtcbiAgICBhd2FpdCBvcHRzLmJlZm9yZVJlbmRlcigpXG4gIH1cblxuICByZW5kZXIocmVuZGVyQ3R4KVxufVxuIl0sIm5hbWVzIjpbImVtaXR0ZXIiLCJoeWRyYXRlIiwiaW5pdGlhbGl6ZSIsInJvdXRlciIsInZlcnNpb24iLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1ZFUlNJT04iLCJtaXR0IiwibG9vc2VUb0FycmF5IiwiaW5wdXQiLCJzbGljZSIsImNhbGwiLCJpbml0aWFsRGF0YSIsImRlZmF1bHRMb2NhbGUiLCJ1bmRlZmluZWQiLCJhc1BhdGgiLCJwYWdlTG9hZGVyIiwiYXBwRWxlbWVudCIsImhlYWRNYW5hZ2VyIiwiaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlIiwibGFzdEFwcFByb3BzIiwibGFzdFJlbmRlclJlamVjdCIsImRldkNsaWVudCIsIkNhY2hlZEFwcCIsIm9uUGVyZkVudHJ5IiwiQ2FjaGVkQ29tcG9uZW50IiwiQ29udGFpbmVyIiwiUmVhY3QiLCJDb21wb25lbnQiLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudEVyciIsImluZm8iLCJwcm9wcyIsImZuIiwiY29tcG9uZW50RGlkTW91bnQiLCJzY3JvbGxUb0hhc2giLCJpc1NzciIsImlzRmFsbGJhY2siLCJuZXh0RXhwb3J0IiwiaXNEeW5hbWljUm91dGUiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwic2VhcmNoIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsIl9fTl9TU0ciLCJyZXBsYWNlIiwiU3RyaW5nIiwiYXNzaWduIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInF1ZXJ5IiwiVVJMU2VhcmNoUGFyYW1zIiwiX2giLCJzaGFsbG93IiwiY2F0Y2giLCJlcnIiLCJjYW5jZWxsZWQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJoYXNoIiwic3Vic3RyaW5nIiwiZWwiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2V0VGltZW91dCIsInNjcm9sbEludG9WaWV3IiwicmVuZGVyIiwiTk9ERV9FTlYiLCJjaGlsZHJlbiIsIlJlYWN0RGV2T3ZlcmxheSIsInJlcXVpcmUiLCJvcHRzIiwidHJhY2VyIiwib25TcGFuRW5kIiwicmVwb3J0VG9Tb2NrZXQiLCJKU09OIiwicGFyc2UiLCJ0ZXh0Q29udGVudCIsIndpbmRvdyIsIl9fTkVYVF9EQVRBX18iLCJwcmVmaXgiLCJhc3NldFByZWZpeCIsInNlbGYiLCJfX25leHRfc2V0X3B1YmxpY19wYXRoX18iLCJzZXRDb25maWciLCJzZXJ2ZXJSdW50aW1lQ29uZmlnIiwicHVibGljUnVudGltZUNvbmZpZyIsInJ1bnRpbWVDb25maWciLCJnZXRVUkwiLCJoYXNCYXNlUGF0aCIsInJlbW92ZUJhc2VQYXRoIiwiX19ORVhUX0kxOE5fU1VQUE9SVCIsIm5vcm1hbGl6ZUxvY2FsZVBhdGgiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJwYXJzZVJlbGF0aXZlVXJsIiwiZm9ybWF0VXJsIiwibG9jYWxlcyIsInBhcnNlZEFzIiwibG9jYWxlUGF0aFJlc3VsdCIsImRldGVjdGVkTG9jYWxlIiwibG9jYWxlIiwiZGV0ZWN0ZWREb21haW4iLCJfX05FWFRfSTE4Tl9ET01BSU5TIiwiaG9zdG5hbWUiLCJzY3JpcHRMb2FkZXIiLCJpbml0U2NyaXB0TG9hZGVyIiwiUGFnZUxvYWRlciIsImJ1aWxkSWQiLCJyZWdpc3RlciIsInIiLCJmIiwicm91dGVMb2FkZXIiLCJvbkVudHJ5cG9pbnQiLCJfX05FWFRfUCIsIm1hcCIsInAiLCJwdXNoIiwiaW5pdEhlYWRNYW5hZ2VyIiwiZ2V0SXNTc3IiLCJyZW5kZXJBcHAiLCJBcHAiLCJhcHBQcm9wcyIsIkFwcENvbnRhaW5lciIsImFkYXB0ZWRGb3JBcHBSb3V0ZXIiLCJ1c2VNZW1vIiwiYWRhcHRGb3JBcHBSb3V0ZXJJbnN0YW5jZSIsImVycm9yIiwicmVuZGVyRXJyb3IiLCJjb25zb2xlIiwiQXBwUm91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwidmFsdWUiLCJTZWFyY2hQYXJhbXNDb250ZXh0IiwiYWRhcHRGb3JTZWFyY2hQYXJhbXMiLCJQYXRobmFtZUNvbnRleHRQcm92aWRlckFkYXB0ZXIiLCJpc0F1dG9FeHBvcnQiLCJhdXRvRXhwb3J0IiwiUGF0aFBhcmFtc0NvbnRleHQiLCJhZGFwdEZvclBhdGhQYXJhbXMiLCJSb3V0ZXJDb250ZXh0IiwibWFrZVB1YmxpY1JvdXRlckluc3RhbmNlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX19ORVhUX0lNQUdFX09QVFMiLCJ3cmFwQXBwIiwid3JhcHBlZEFwcFByb3BzIiwicmVuZGVyRXJyb3JQcm9wcyIsIm9uVW5yZWNvdmVyYWJsZUVycm9yIiwiZG9SZW5kZXIiLCJzdHlsZVNoZWV0cyIsImxvYWRQYWdlIiwidGhlbiIsInBhZ2UiLCJFcnJvckNvbXBvbmVudCIsImVycm9yTW9kdWxlIiwiYXBwTW9kdWxlIiwiZGVmYXVsdCIsIm0iLCJBcHBUcmVlIiwiYXBwQ3R4IiwiY3R4IiwiUHJvbWlzZSIsInJlc29sdmUiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwiaW5pdFByb3BzIiwiSGVhZCIsImNhbGxiYWNrIiwidXNlTGF5b3V0RWZmZWN0IiwicGVyZm9ybWFuY2VNYXJrcyIsIm5hdmlnYXRpb25TdGFydCIsImJlZm9yZVJlbmRlciIsImFmdGVyUmVuZGVyIiwiYWZ0ZXJIeWRyYXRlIiwicm91dGVDaGFuZ2UiLCJwZXJmb3JtYW5jZU1lYXN1cmVzIiwiaHlkcmF0aW9uIiwiYmVmb3JlSHlkcmF0aW9uIiwicm91dGVDaGFuZ2VUb1JlbmRlciIsInJlYWN0Um9vdCIsInNob3VsZEh5ZHJhdGUiLCJjbGVhck1hcmtzIiwiZm9yRWFjaCIsIm1hcmsiLCJwZXJmb3JtYW5jZSIsIm1hcmtIeWRyYXRlQ29tcGxldGUiLCJTVCIsImhhc0JlZm9yZVJlbmRlck1hcmsiLCJnZXRFbnRyaWVzQnlOYW1lIiwibGVuZ3RoIiwiYmVmb3JlSHlkcmF0aW9uTWVhc3VyZSIsIm1lYXN1cmUiLCJoeWRyYXRpb25NZWFzdXJlIiwic3RhcnRTcGFuIiwic3RhcnRUaW1lIiwidGltZU9yaWdpbiIsImF0dHJpYnV0ZXMiLCJlbmQiLCJkdXJhdGlvbiIsIm1hcmtSZW5kZXJDb21wbGV0ZSIsIm5hdlN0YXJ0RW50cmllcyIsIm5hbWUiLCJjbGVhck1lYXN1cmVzIiwicmVuZGVyUmVhY3RFbGVtZW50IiwiZG9tRWwiLCJyZWFjdEVsIiwiUmVhY3RET00iLCJoeWRyYXRlUm9vdCIsIm9uUmVjb3ZlcmFibGVFcnJvciIsInN0YXJ0VHJhbnNpdGlvbiIsIlJvb3QiLCJjYWxsYmFja3MiLCJfX05FWFRfVEVTVF9NT0RFIiwidXNlRWZmZWN0IiwiX19ORVhUX0hZRFJBVEVEIiwiX19ORVhUX0hZRFJBVEVEX0NCIiwiY2FuY2VsZWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlbmRlclByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsIm9uU3RhcnQiLCJjdXJyZW50U3R5bGVUYWdzIiwicXVlcnlTZWxlY3RvckFsbCIsImN1cnJlbnRIcmVmcyIsIlNldCIsInRhZyIsImdldEF0dHJpYnV0ZSIsIm5vc2NyaXB0IiwicXVlcnlTZWxlY3RvciIsIm5vbmNlIiwiaHJlZiIsInRleHQiLCJoYXMiLCJzdHlsZVRhZyIsImNyZWF0ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVUZXh0Tm9kZSIsIm9uSGVhZENvbW1pdCIsIlRVUkJPUEFDSyIsImRlc2lyZWRIcmVmcyIsInMiLCJpZHgiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZWZlcmVuY2VOb2RlIiwidGFyZ2V0VGFnIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwicmVtb3ZlQ2hpbGQiLCJzY3JvbGwiLCJ4IiwieSIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwib25Sb290Q29tbWl0IiwiZWxlbSIsIlBvcnRhbCIsInR5cGUiLCJSb3V0ZUFubm91bmNlciIsIl9fTkVYVF9TVFJJQ1RfTU9ERSIsIlN0cmljdE1vZGUiLCJyZW5kZXJpbmdQcm9wcyIsImlzSHlkcmF0ZVBhc3MiLCJyZW5kZXJFcnIiLCJnZXRQcm9wZXJFcnJvciIsImluaXRpYWxFcnIiLCJhcHBFbnRyeXBvaW50Iiwid2hlbkVudHJ5cG9pbnQiLCJjb21wb25lbnQiLCJhcHAiLCJleHBvcnRzIiwibW9kIiwicmVwb3J0V2ViVml0YWxzIiwiaWQiLCJlbnRyeVR5cGUiLCJlbnRyaWVzIiwiYXR0cmlidXRpb24iLCJ1bmlxdWVJRCIsIkRhdGUiLCJub3ciLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJwZXJmU3RhcnRFbnRyeSIsIndlYlZpdGFscyIsImxhYmVsIiwicGFnZUVudHJ5cG9pbnQiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJnZXRTZXJ2ZXJFcnJvciIsIm1lc3NhZ2UiLCJlIiwic3RhY2siLCJlcnJTb3VyY2UiLCJzb3VyY2UiLCJpc05leHRSb3V0ZXJFcnJvciIsIl9fTkVYVF9QUkVMT0FEUkVBRFkiLCJkeW5hbWljSWRzIiwiY3JlYXRlUm91dGVyIiwiaW5pdGlhbFByb3BzIiwiQm9vbGVhbiIsInN1YnNjcmlwdGlvbiIsIk9iamVjdCIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJfaW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSIsInJlbmRlckN0eCIsImluaXRpYWwiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/index.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/page-loader.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/page-loader.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return PageLoader;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst _interpolateas = __webpack_require__(/*! ../shared/lib/router/utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nconst _getassetpathfromroute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _isdynamic = __webpack_require__(/*! ../shared/lib/router/utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nconst _parserelativeurl = __webpack_require__(/*! ../shared/lib/router/utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nconst _removetrailingslash = __webpack_require__(/*! ../shared/lib/router/utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nconst _routeloader = __webpack_require__(/*! ./route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nconst _constants = __webpack_require__(/*! ../shared/lib/constants */ \"./node_modules/next/dist/shared/lib/constants.js\");\nclass PageLoader {\n    getPageList() {\n        if (false) {} else {\n            if (window.__DEV_PAGES_MANIFEST) {\n                return window.__DEV_PAGES_MANIFEST.pages;\n            } else {\n                this.promisedDevPagesManifest || (this.promisedDevPagesManifest = fetch(this.assetPrefix + \"/_next/static/development/\" + _constants.DEV_CLIENT_PAGES_MANIFEST, {\n                    credentials: 'same-origin'\n                }).then((res)=>res.json()).then((manifest)=>{\n                    window.__DEV_PAGES_MANIFEST = manifest;\n                    return manifest.pages;\n                }).catch((err)=>{\n                    console.log(\"Failed to fetch devPagesManifest:\", err);\n                    throw new Error(\"Failed to fetch _devPagesManifest.json. Is something blocking that network request?\\n\" + 'Read more: https://nextjs.org/docs/messages/failed-to-fetch-devpagesmanifest');\n                }));\n                return this.promisedDevPagesManifest;\n            }\n        }\n    }\n    getMiddleware() {\n        // Webpack production\n        if (false) {} else if (false) {} else {\n            if (window.__DEV_MIDDLEWARE_MATCHERS) {\n                return window.__DEV_MIDDLEWARE_MATCHERS;\n            } else {\n                if (!this.promisedMiddlewareMatchers) {\n                    // TODO: Decide what should happen when fetching fails instead of asserting\n                    // @ts-ignore\n                    this.promisedMiddlewareMatchers = fetch(this.assetPrefix + \"/_next/static/\" + this.buildId + \"/\" + _constants.DEV_CLIENT_MIDDLEWARE_MANIFEST, {\n                        credentials: 'same-origin'\n                    }).then((res)=>res.json()).then((matchers)=>{\n                        window.__DEV_MIDDLEWARE_MATCHERS = matchers;\n                        return matchers;\n                    }).catch((err)=>{\n                        console.log(\"Failed to fetch _devMiddlewareManifest\", err);\n                    });\n                }\n                // TODO Remove this assertion as this could be undefined\n                return this.promisedMiddlewareMatchers;\n            }\n        }\n    }\n    getDataHref(params) {\n        const { asPath, href, locale } = params;\n        const { pathname: hrefPathname, query, search } = (0, _parserelativeurl.parseRelativeUrl)(href);\n        const { pathname: asPathname } = (0, _parserelativeurl.parseRelativeUrl)(asPath);\n        const route = (0, _removetrailingslash.removeTrailingSlash)(hrefPathname);\n        if (route[0] !== '/') {\n            throw new Error('Route name should start with a \"/\", got \"' + route + '\"');\n        }\n        const getHrefForSlug = (path)=>{\n            const dataRoute = (0, _getassetpathfromroute.default)((0, _removetrailingslash.removeTrailingSlash)((0, _addlocale.addLocale)(path, locale)), '.json');\n            return (0, _addbasepath.addBasePath)(\"/_next/data/\" + this.buildId + dataRoute + search, true);\n        };\n        return getHrefForSlug(params.skipInterpolation ? asPathname : (0, _isdynamic.isDynamicRoute)(route) ? (0, _interpolateas.interpolateAs)(hrefPathname, asPathname, query).result : route);\n    }\n    _isSsg(/** the route (file-system path) */ route) {\n        return this.promisedSsgManifest.then((manifest)=>manifest.has(route));\n    }\n    loadPage(route) {\n        return this.routeLoader.loadRoute(route).then((res)=>{\n            if ('component' in res) {\n                return {\n                    page: res.component,\n                    mod: res.exports,\n                    styleSheets: res.styles.map((o)=>({\n                            href: o.href,\n                            text: o.content\n                        }))\n                };\n            }\n            throw res.error;\n        });\n    }\n    prefetch(route) {\n        return this.routeLoader.prefetch(route);\n    }\n    constructor(buildId, assetPrefix){\n        this.routeLoader = (0, _routeloader.createRouteLoader)(assetPrefix);\n        this.buildId = buildId;\n        this.assetPrefix = assetPrefix;\n        this.promisedSsgManifest = new Promise((resolve)=>{\n            if (window.__SSG_MANIFEST) {\n                resolve(window.__SSG_MANIFEST);\n            } else {\n                window.__SSG_MANIFEST_CB = ()=>{\n                    resolve(window.__SSG_MANIFEST);\n                };\n            }\n        });\n    }\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=page-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9wYWdlLWxvYWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O2VBaUNxQkE7Ozs7eUNBOUJPOzJDQUNFOzRGQUNJO3VDQUNSO3VDQUNLOzhDQUNFO2lEQUNHO3lDQUNzQjt1Q0FLbkQ7QUFrQlEsTUFBTUE7SUEwQm5CQyxjQUFjO1FBQ1osSUFBSUMsS0FBb0IsRUFBbUIsRUFFMUMsTUFBTTtZQUNMLElBQUlPLE9BQU9DLG9CQUFvQixFQUFFO2dCQUMvQixPQUFPRCxPQUFPQyxvQkFBb0IsQ0FBQ0MsS0FBSztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ0Msd0JBQUFBLEtBQUwsSUFBSSxDQUFDQSx3QkFBQUEsR0FBNkJDLE1BQzdCLElBQUksQ0FBQ0MsV0FBVyxHQUFDLCtCQUE0QkMsV0FBQUEseUJBQXlCLEVBQ3pFO29CQUFFQyxhQUFhO2dCQUFjLEdBRTVCVixJQUFJLENBQUMsQ0FBQ1csTUFBUUEsSUFBSUMsSUFBSSxJQUN0QlosSUFBSSxDQUFDLENBQUNDO29CQUNMRSxPQUFPQyxvQkFBb0IsR0FBR0g7b0JBQzlCLE9BQU9BLFNBQVNJLEtBQUs7Z0JBQ3ZCLEdBQ0NRLEtBQUssQ0FBQyxDQUFDQztvQkFDTkMsUUFBUUMsR0FBRyxDQUFFLHFDQUFvQ0Y7b0JBQ2pELE1BQU0sSUFBSUcsTUFDUCwwRkFDQztnQkFFTjtnQkFDRixPQUFPLElBQUksQ0FBQ1gsd0JBQXdCO1lBQ3RDO1FBQ0Y7SUFDRjtJQUVBWSxnQkFBZ0I7UUFDZCxxQkFBcUI7UUFDckIsSUFDRXRCLEtBQ3NDLEVBQ3RDLEVBT0QsTUFBTSxJQUFJQSxLQUFvQixFQUFtQixFQXdCakQsTUFBTTtZQUNMLElBQUlPLE9BQU93Qix5QkFBeUIsRUFBRTtnQkFDcEMsT0FBT3hCLE9BQU93Qix5QkFBeUI7WUFDekMsT0FBTztnQkFDTCxJQUFJLENBQUMsSUFBSSxDQUFDSiwwQkFBMEIsRUFBRTtvQkFDcEMsMkVBQTJFO29CQUMzRSxhQUFhO29CQUNi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QUFHQTtRQUVuQixJQUFJLENBQUM2QyxtQkFBbUIsR0FBRyxJQUFJbUIsUUFBUSxDQUFDQztZQUN0QyxJQUFJdEUsT0FBT3VFLGNBQWMsRUFBRTtnQkFDekJELFFBQVF0RSxPQUFPdUUsY0FBYztZQUMvQixPQUFPO2dCQUNMdkUsT0FBT3dFLGlCQUFpQixHQUFHO29CQUN6QkYsUUFBUXRFLE9BQU91RSxjQUFjO2dCQUMvQjtZQUNGO1FBQ0Y7SUFDRjtBQXdKRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxsZW9uYVxcUHJvamVjdHNcXHNyY1xcY2xpZW50XFxwYWdlLWxvYWRlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgUm91dGVMb2FkZXIgfSBmcm9tICcuL3JvdXRlLWxvYWRlcidcbmltcG9ydCB0eXBlIHsgTWlkZGxld2FyZU1hdGNoZXIgfSBmcm9tICcuLi9idWlsZC9hbmFseXNpcy9nZXQtcGFnZS1zdGF0aWMtaW5mbydcbmltcG9ydCB7IGFkZEJhc2VQYXRoIH0gZnJvbSAnLi9hZGQtYmFzZS1wYXRoJ1xuaW1wb3J0IHsgaW50ZXJwb2xhdGVBcyB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2ludGVycG9sYXRlLWFzJ1xuaW1wb3J0IGdldEFzc2V0UGF0aEZyb21Sb3V0ZSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHsgYWRkTG9jYWxlIH0gZnJvbSAnLi9hZGQtbG9jYWxlJ1xuaW1wb3J0IHsgaXNEeW5hbWljUm91dGUgfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljJ1xuaW1wb3J0IHsgcGFyc2VSZWxhdGl2ZVVybCB9IGZyb20gJy4uL3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybCdcbmltcG9ydCB7IHJlbW92ZVRyYWlsaW5nU2xhc2ggfSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2gnXG5pbXBvcnQgeyBjcmVhdGVSb3V0ZUxvYWRlciwgZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCB9IGZyb20gJy4vcm91dGUtbG9hZGVyJ1xuaW1wb3J0IHtcbiAgREVWX0NMSUVOVF9QQUdFU19NQU5JRkVTVCxcbiAgREVWX0NMSUVOVF9NSURETEVXQVJFX01BTklGRVNULFxuICBUVVJCT1BBQ0tfQ0xJRU5UX01JRERMRVdBUkVfTUFOSUZFU1QsXG59IGZyb20gJy4uL3NoYXJlZC9saWIvY29uc3RhbnRzJ1xuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fREVWX01JRERMRVdBUkVfTUFUQ0hFUlM/OiBNaWRkbGV3YXJlTWF0Y2hlcltdXG4gICAgX19ERVZfUEFHRVNfTUFOSUZFU1Q/OiB7IHBhZ2VzOiBzdHJpbmdbXSB9XG4gICAgX19TU0dfTUFOSUZFU1RfQ0I/OiAoKSA9PiB2b2lkXG4gICAgX19TU0dfTUFOSUZFU1Q/OiBTZXQ8c3RyaW5nPlxuICB9XG59XG5cbmV4cG9ydCB0eXBlIFN0eWxlU2hlZXRUdXBsZSA9IHsgaHJlZjogc3RyaW5nOyB0ZXh0OiBzdHJpbmcgfVxuZXhwb3J0IHR5cGUgR29vZFBhZ2VDYWNoZSA9IHtcbiAgcGFnZTogQ29tcG9uZW50VHlwZVxuICBtb2Q6IGFueVxuICBzdHlsZVNoZWV0czogU3R5bGVTaGVldFR1cGxlW11cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGFnZUxvYWRlciB7XG4gIHByaXZhdGUgYnVpbGRJZDogc3RyaW5nXG4gIHByaXZhdGUgYXNzZXRQcmVmaXg6IHN0cmluZ1xuICBwcml2YXRlIHByb21pc2VkU3NnTWFuaWZlc3Q6IFByb21pc2U8U2V0PHN0cmluZz4+XG4gIHByaXZhdGUgcHJvbWlzZWREZXZQYWdlc01hbmlmZXN0PzogUHJvbWlzZTxzdHJpbmdbXT5cbiAgcHJpdmF0ZSBwcm9taXNlZE1pZGRsZXdhcmVNYXRjaGVycz86IFByb21pc2U8TWlkZGxld2FyZU1hdGNoZXJbXT5cblxuICBwdWJsaWMgcm91dGVMb2FkZXI6IFJvdXRlTG9hZGVyXG5cbiAgY29uc3RydWN0b3IoYnVpbGRJZDogc3RyaW5nLCBhc3NldFByZWZpeDogc3RyaW5nKSB7XG4gICAgdGhpcy5yb3V0ZUxvYWRlciA9IGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4KVxuXG4gICAgdGhpcy5idWlsZElkID0gYnVpbGRJZFxuICAgIHRoaXMuYXNzZXRQcmVmaXggPSBhc3NldFByZWZpeFxuXG4gICAgdGhpcy5wcm9taXNlZFNzZ01hbmlmZXN0ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGlmICh3aW5kb3cuX19TU0dfTUFOSUZFU1QpIHtcbiAgICAgICAgcmVzb2x2ZSh3aW5kb3cuX19TU0dfTUFOSUZFU1QpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW5kb3cuX19TU0dfTUFOSUZFU1RfQ0IgPSAoKSA9PiB7XG4gICAgICAgICAgcmVzb2x2ZSh3aW5kb3cuX19TU0dfTUFOSUZFU1QhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGdldFBhZ2VMaXN0KCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICByZXR1cm4gZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCgpLnRoZW4oKG1hbmlmZXN0KSA9PiBtYW5pZmVzdC5zb3J0ZWRQYWdlcylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCkge1xuICAgICAgICByZXR1cm4gd2luZG93Ll9fREVWX1BBR0VTX01BTklGRVNULnBhZ2VzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByb21pc2VkRGV2UGFnZXNNYW5pZmVzdCB8fD0gZmV0Y2goXG4gICAgICAgICAgYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljL2RldmVsb3BtZW50LyR7REVWX0NMSUVOVF9QQUdFU19NQU5JRkVTVH1gLFxuICAgICAgICAgIHsgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicgfVxuICAgICAgICApXG4gICAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgICAudGhlbigobWFuaWZlc3Q6IHsgcGFnZXM6IHN0cmluZ1tdIH0pID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5fX0RFVl9QQUdFU19NQU5JRkVTVCA9IG1hbmlmZXN0XG4gICAgICAgICAgICByZXR1cm4gbWFuaWZlc3QucGFnZXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRmFpbGVkIHRvIGZldGNoIGRldlBhZ2VzTWFuaWZlc3Q6YCwgZXJyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRmFpbGVkIHRvIGZldGNoIF9kZXZQYWdlc01hbmlmZXN0Lmpzb24uIElzIHNvbWV0aGluZyBibG9ja2luZyB0aGF0IG5ldHdvcmsgcmVxdWVzdD9cXG5gICtcbiAgICAgICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9mYWlsZWQtdG8tZmV0Y2gtZGV2cGFnZXNtYW5pZmVzdCdcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9KVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZERldlBhZ2VzTWFuaWZlc3RcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRNaWRkbGV3YXJlKCkge1xuICAgIC8vIFdlYnBhY2sgcHJvZHVjdGlvblxuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHByb2Nlc3MuZW52Ll9fTkVYVF9NSURETEVXQVJFX01BVENIRVJTXG4gICAgKSB7XG4gICAgICBjb25zdCBtaWRkbGV3YXJlTWF0Y2hlcnMgPSBwcm9jZXNzLmVudi5fX05FWFRfTUlERExFV0FSRV9NQVRDSEVSU1xuICAgICAgd2luZG93Ll9fTUlERExFV0FSRV9NQVRDSEVSUyA9IG1pZGRsZXdhcmVNYXRjaGVyc1xuICAgICAgICA/IChtaWRkbGV3YXJlTWF0Y2hlcnMgYXMgYW55IGFzIE1pZGRsZXdhcmVNYXRjaGVyW10pXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgICByZXR1cm4gd2luZG93Ll9fTUlERExFV0FSRV9NQVRDSEVSU1xuICAgICAgLy8gVHVyYm9wYWNrIHByb2R1Y3Rpb25cbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICh3aW5kb3cuX19NSURETEVXQVJFX01BVENIRVJTKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuX19NSURETEVXQVJFX01BVENIRVJTXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMucHJvbWlzZWRNaWRkbGV3YXJlTWF0Y2hlcnMpIHtcbiAgICAgICAgICAvLyBUT0RPOiBEZWNpZGUgd2hhdCBzaG91bGQgaGFwcGVuIHdoZW4gZmV0Y2hpbmcgZmFpbHMgaW5zdGVhZCBvZiBhc3NlcnRpbmdcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYXRjaGVycyA9IGZldGNoKFxuICAgICAgICAgICAgYCR7dGhpcy5hc3NldFByZWZpeH0vX25leHQvc3RhdGljLyR7dGhpcy5idWlsZElkfS8ke1RVUkJPUEFDS19DTElFTlRfTUlERExFV0FSRV9NQU5JRkVTVH1gLFxuICAgICAgICAgICAgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9XG4gICAgICAgICAgKVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcbiAgICAgICAgICAgIC50aGVuKChtYXRjaGVyczogTWlkZGxld2FyZU1hdGNoZXJbXSkgPT4ge1xuICAgICAgICAgICAgICB3aW5kb3cuX19NSURETEVXQVJFX01BVENIRVJTID0gbWF0Y2hlcnNcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBfZGV2TWlkZGxld2FyZU1hbmlmZXN0YCwgZXJyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGFzc2VydGlvbiBhcyB0aGlzIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYXRjaGVycyFcbiAgICAgIH1cbiAgICAgIC8vIERldmVsb3BtZW50IGJvdGggVHVyYm9wYWNrIGFuZCBXZWJwYWNrXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh3aW5kb3cuX19ERVZfTUlERExFV0FSRV9NQVRDSEVSUykge1xuICAgICAgICByZXR1cm4gd2luZG93Ll9fREVWX01JRERMRVdBUkVfTUFUQ0hFUlNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYXRjaGVycykge1xuICAgICAgICAgIC8vIFRPRE86IERlY2lkZSB3aGF0IHNob3VsZCBoYXBwZW4gd2hlbiBmZXRjaGluZyBmYWlscyBpbnN0ZWFkIG9mIGFzc2VydGluZ1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICB0aGlzLnByb21pc2VkTWlkZGxld2FyZU1hdGNoZXJzID0gZmV0Y2goXG4gICAgICAgICAgICBgJHt0aGlzLmFzc2V0UHJlZml4fS9fbmV4dC9zdGF0aWMvJHt0aGlzLmJ1aWxkSWR9LyR7REVWX0NMSUVOVF9NSURETEVXQVJFX01BTklGRVNUfWAsXG4gICAgICAgICAgICB7IGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nIH1cbiAgICAgICAgICApXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiByZXMuanNvbigpKVxuICAgICAgICAgICAgLnRoZW4oKG1hdGNoZXJzOiBNaWRkbGV3YXJlTWF0Y2hlcltdKSA9PiB7XG4gICAgICAgICAgICAgIHdpbmRvdy5fX0RFVl9NSURETEVXQVJFX01BVENIRVJTID0gbWF0Y2hlcnNcbiAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXJzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBmZXRjaCBfZGV2TWlkZGxld2FyZU1hbmlmZXN0YCwgZXJyKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGFzc2VydGlvbiBhcyB0aGlzIGNvdWxkIGJlIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlZE1pZGRsZXdhcmVNYXRjaGVycyFcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXREYXRhSHJlZihwYXJhbXM6IHtcbiAgICBhc1BhdGg6IHN0cmluZ1xuICAgIGhyZWY6IHN0cmluZ1xuICAgIGxvY2FsZT86IHN0cmluZyB8IGZhbHNlXG4gICAgc2tpcEludGVycG9sYXRpb24/OiBib29sZWFuXG4gIH0pOiBzdHJpbmcge1xuICAgIGNvbnN0IHsgYXNQYXRoLCBocmVmLCBsb2NhbGUgfSA9IHBhcmFtc1xuICAgIGNvbnN0IHsgcGF0aG5hbWU6IGhyZWZQYXRobmFtZSwgcXVlcnksIHNlYXJjaCB9ID0gcGFyc2VSZWxhdGl2ZVVybChocmVmKVxuICAgIGNvbnN0IHsgcGF0aG5hbWU6IGFzUGF0aG5hbWUgfSA9IHBhcnNlUmVsYXRpdmVVcmwoYXNQYXRoKVxuICAgIGNvbnN0IHJvdXRlID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChocmVmUGF0aG5hbWUpXG4gICAgaWYgKHJvdXRlWzBdICE9PSAnLycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUm91dGUgbmFtZSBzaG91bGQgc3RhcnQgd2l0aCBhIFwiL1wiLCBnb3QgXCIke3JvdXRlfVwiYClcbiAgICB9XG5cbiAgICBjb25zdCBnZXRIcmVmRm9yU2x1ZyA9IChwYXRoOiBzdHJpbmcpID0+IHtcbiAgICAgIGNvbnN0IGRhdGFSb3V0ZSA9IGdldEFzc2V0UGF0aEZyb21Sb3V0ZShcbiAgICAgICAgcmVtb3ZlVHJhaWxpbmdTbGFzaChhZGRMb2NhbGUocGF0aCwgbG9jYWxlKSksXG4gICAgICAgICcuanNvbidcbiAgICAgIClcbiAgICAgIHJldHVybiBhZGRCYXNlUGF0aChcbiAgICAgICAgYC9fbmV4dC9kYXRhLyR7dGhpcy5idWlsZElkfSR7ZGF0YVJvdXRlfSR7c2VhcmNofWAsXG4gICAgICAgIHRydWVcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0SHJlZkZvclNsdWcoXG4gICAgICBwYXJhbXMuc2tpcEludGVycG9sYXRpb25cbiAgICAgICAgPyBhc1BhdGhuYW1lXG4gICAgICAgIDogaXNEeW5hbWljUm91dGUocm91dGUpXG4gICAgICAgICAgPyBpbnRlcnBvbGF0ZUFzKGhyZWZQYXRobmFtZSwgYXNQYXRobmFtZSwgcXVlcnkpLnJlc3VsdFxuICAgICAgICAgIDogcm91dGVcbiAgICApXG4gIH1cblxuICBfaXNTc2coXG4gICAgLyoqIHRoZSByb3V0ZSAoZmlsZS1zeXN0ZW0gcGF0aCkgKi9cbiAgICByb3V0ZTogc3RyaW5nXG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnByb21pc2VkU3NnTWFuaWZlc3QudGhlbigobWFuaWZlc3QpID0+IG1hbmlmZXN0Lmhhcyhyb3V0ZSkpXG4gIH1cblxuICBsb2FkUGFnZShyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTxHb29kUGFnZUNhY2hlPiB7XG4gICAgcmV0dXJuIHRoaXMucm91dGVMb2FkZXIubG9hZFJvdXRlKHJvdXRlKS50aGVuKChyZXMpID0+IHtcbiAgICAgIGlmICgnY29tcG9uZW50JyBpbiByZXMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYWdlOiByZXMuY29tcG9uZW50LFxuICAgICAgICAgIG1vZDogcmVzLmV4cG9ydHMsXG4gICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZXMubWFwKChvKSA9PiAoe1xuICAgICAgICAgICAgaHJlZjogby5ocmVmLFxuICAgICAgICAgICAgdGV4dDogby5jb250ZW50LFxuICAgICAgICAgIH0pKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgcmVzLmVycm9yXG4gICAgfSlcbiAgfVxuXG4gIHByZWZldGNoKHJvdXRlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gdGhpcy5yb3V0ZUxvYWRlci5wcmVmZXRjaChyb3V0ZSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbIlBhZ2VMb2FkZXIiLCJnZXRQYWdlTGlzdCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwibWFuaWZlc3QiLCJzb3J0ZWRQYWdlcyIsIndpbmRvdyIsIl9fREVWX1BBR0VTX01BTklGRVNUIiwicGFnZXMiLCJwcm9taXNlZERldlBhZ2VzTWFuaWZlc3QiLCJmZXRjaCIsImFzc2V0UHJlZml4IiwiREVWX0NMSUVOVF9QQUdFU19NQU5JRkVTVCIsImNyZWRlbnRpYWxzIiwicmVzIiwianNvbiIsImNhdGNoIiwiZXJyIiwiY29uc29sZSIsImxvZyIsIkVycm9yIiwiZ2V0TWlkZGxld2FyZSIsIl9fTkVYVF9NSURETEVXQVJFX01BVENIRVJTIiwibWlkZGxld2FyZU1hdGNoZXJzIiwiX19NSURETEVXQVJFX01BVENIRVJTIiwidW5kZWZpbmVkIiwicHJvbWlzZWRNaWRkbGV3YXJlTWF0Y2hlcnMiLCJidWlsZElkIiwiVFVSQk9QQUNLX0NMSUVOVF9NSURETEVXQVJFX01BTklGRVNUIiwibWF0Y2hlcnMiLCJfX0RFVl9NSURETEVXQVJFX01BVENIRVJTIiwiREVWX0NMSUVOVF9NSURETEVXQVJFX01BTklGRVNUIiwiZ2V0RGF0YUhyZWYiLCJwYXJhbXMiLCJhc1BhdGgiLCJocmVmIiwibG9jYWxlIiwicGF0aG5hbWUiLCJocmVmUGF0aG5hbWUiLCJxdWVyeSIsInNlYXJjaCIsInBhcnNlUmVsYXRpdmVVcmwiLCJhc1BhdGhuYW1lIiwicm91dGUiLCJyZW1vdmVUcmFpbGluZ1NsYXNoIiwiZ2V0SHJlZkZvclNsdWciLCJwYXRoIiwiZGF0YVJvdXRlIiwiZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwiYWRkTG9jYWxlIiwiYWRkQmFzZVBhdGgiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzRHluYW1pY1JvdXRlIiwiaW50ZXJwb2xhdGVBcyIsInJlc3VsdCIsIl9pc1NzZyIsInByb21pc2VkU3NnTWFuaWZlc3QiLCJoYXMiLCJsb2FkUGFnZSIsInJvdXRlTG9hZGVyIiwibG9hZFJvdXRlIiwicGFnZSIsImNvbXBvbmVudCIsIm1vZCIsImV4cG9ydHMiLCJzdHlsZVNoZWV0cyIsInN0eWxlcyIsIm1hcCIsIm8iLCJ0ZXh0IiwiY29udGVudCIsImVycm9yIiwicHJlZmV0Y2giLCJjb25zdHJ1Y3RvciIsImNyZWF0ZVJvdXRlTG9hZGVyIiwiUHJvbWlzZSIsInJlc29sdmUiLCJfX1NTR19NQU5JRkVTVCIsIl9fU1NHX01BTklGRVNUX0NCIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/page-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/react-client-callbacks/shared.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/react-client-callbacks/shared.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// This module can be shared between both pages router and app router\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"onRecoverableError\", ({\n    enumerable: true,\n    get: function() {\n        return onRecoverableError;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _bailouttocsr = __webpack_require__(/*! ../../shared/lib/lazy-dynamic/bailout-to-csr */ \"./node_modules/next/dist/shared/lib/lazy-dynamic/bailout-to-csr.js\");\nconst _reportglobalerror = __webpack_require__(/*! ./report-global-error */ \"./node_modules/next/dist/client/react-client-callbacks/report-global-error.js\");\nconst _stitchederror = __webpack_require__(/*! ../components/react-dev-overlay/internal/helpers/stitched-error */ \"./node_modules/next/dist/client/components/react-dev-overlay/internal/helpers/stitched-error.js\");\nconst _iserror = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nconst onRecoverableError = (error, errorInfo)=>{\n    // x-ref: https://github.com/facebook/react/pull/28736\n    const cause = (0, _iserror.default)(error) && 'cause' in error ? error.cause : error;\n    const stitchedError = (0, _stitchederror.getReactStitchedError)(cause);\n    // In development mode, pass along the component stack to the error\n    if ( true && errorInfo.componentStack) {\n        ;\n        stitchedError._componentStack = errorInfo.componentStack;\n    }\n    // Skip certain custom errors which are not expected to be reported on client\n    if ((0, _bailouttocsr.isBailoutToCSRError)(cause)) return;\n    (0, _reportglobalerror.reportGlobalError)(stitchedError);\n};\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=shared.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yZWFjdC1jbGllbnQtY2FsbGJhY2tzL3NoYXJlZC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxRUFBcUU7Ozs7O3NEQVF4REE7OztlQUFBQTs7OzswQ0FMdUI7K0NBQ0Y7MkNBQ0k7OEVBQ2xCO0FBRWIsTUFBTUEscUJBQTZELENBQ3hFQyxPQUNBQztJQUVBLHNEQUFzRDtJQUN0RCxNQUFNQyxRQUFRQyxDQUFBQSxHQUFBQSxTQUFBQSxPQUFBQSxFQUFRSCxVQUFVLFdBQVdBLFFBQVFBLE1BQU1FLEtBQUssR0FBR0Y7SUFDakUsTUFBTUksZ0JBQWdCQyxDQUFBQSxHQUFBQSxlQUFBQSxxQkFBQUEsRUFBc0JIO0lBQzVDLG1FQUFtRTtJQUNuRSxJQUFJSSxLQUFvQixJQUFzQkwsVUFBVVEsY0FBYyxFQUFFOztRQUNwRUwsY0FBc0JNLGVBQWUsR0FBR1QsVUFBVVEsY0FBYztJQUNwRTtJQUNBLDZFQUE2RTtJQUM3RSxJQUFJRSxDQUFBQSxHQUFBQSxjQUFBQSxtQkFBQUEsRUFBb0JULFFBQVE7SUFFaENVLENBQUFBLEdBQUFBLG1CQUFBQSxpQkFBQUEsRUFBa0JSO0FBQ3BCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlb25hXFxzcmNcXGNsaWVudFxccmVhY3QtY2xpZW50LWNhbGxiYWNrc1xcc2hhcmVkLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgbW9kdWxlIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBib3RoIHBhZ2VzIHJvdXRlciBhbmQgYXBwIHJvdXRlclxuXG5pbXBvcnQgdHlwZSB7IEh5ZHJhdGlvbk9wdGlvbnMgfSBmcm9tICdyZWFjdC1kb20vY2xpZW50J1xuaW1wb3J0IHsgaXNCYWlsb3V0VG9DU1JFcnJvciB9IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbGF6eS1keW5hbWljL2JhaWxvdXQtdG8tY3NyJ1xuaW1wb3J0IHsgcmVwb3J0R2xvYmFsRXJyb3IgfSBmcm9tICcuL3JlcG9ydC1nbG9iYWwtZXJyb3InXG5pbXBvcnQgeyBnZXRSZWFjdFN0aXRjaGVkRXJyb3IgfSBmcm9tICcuLi9jb21wb25lbnRzL3JlYWN0LWRldi1vdmVybGF5L2ludGVybmFsL2hlbHBlcnMvc3RpdGNoZWQtZXJyb3InXG5pbXBvcnQgaXNFcnJvciBmcm9tICcuLi8uLi9saWIvaXMtZXJyb3InXG5cbmV4cG9ydCBjb25zdCBvblJlY292ZXJhYmxlRXJyb3I6IEh5ZHJhdGlvbk9wdGlvbnNbJ29uUmVjb3ZlcmFibGVFcnJvciddID0gKFxuICBlcnJvcixcbiAgZXJyb3JJbmZvXG4pID0+IHtcbiAgLy8geC1yZWY6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI4NzM2XG4gIGNvbnN0IGNhdXNlID0gaXNFcnJvcihlcnJvcikgJiYgJ2NhdXNlJyBpbiBlcnJvciA/IGVycm9yLmNhdXNlIDogZXJyb3JcbiAgY29uc3Qgc3RpdGNoZWRFcnJvciA9IGdldFJlYWN0U3RpdGNoZWRFcnJvcihjYXVzZSlcbiAgLy8gSW4gZGV2ZWxvcG1lbnQgbW9kZSwgcGFzcyBhbG9uZyB0aGUgY29tcG9uZW50IHN0YWNrIHRvIHRoZSBlcnJvclxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrKSB7XG4gICAgOyhzdGl0Y2hlZEVycm9yIGFzIGFueSkuX2NvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrXG4gIH1cbiAgLy8gU2tpcCBjZXJ0YWluIGN1c3RvbSBlcnJvcnMgd2hpY2ggYXJlIG5vdCBleHBlY3RlZCB0byBiZSByZXBvcnRlZCBvbiBjbGllbnRcbiAgaWYgKGlzQmFpbG91dFRvQ1NSRXJyb3IoY2F1c2UpKSByZXR1cm5cblxuICByZXBvcnRHbG9iYWxFcnJvcihzdGl0Y2hlZEVycm9yKVxufVxuIl0sIm5hbWVzIjpbIm9uUmVjb3ZlcmFibGVFcnJvciIsImVycm9yIiwiZXJyb3JJbmZvIiwiY2F1c2UiLCJpc0Vycm9yIiwic3RpdGNoZWRFcnJvciIsImdldFJlYWN0U3RpdGNoZWRFcnJvciIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudFN0YWNrIiwiaXNCYWlsb3V0VG9DU1JFcnJvciIsInJlcG9ydEdsb2JhbEVycm9yIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/react-client-callbacks/shared.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/route-loader.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/client/route-loader.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    createRouteLoader: function() {\n        return createRouteLoader;\n    },\n    getClientBuildManifest: function() {\n        return getClientBuildManifest;\n    },\n    isAssetError: function() {\n        return isAssetError;\n    },\n    markAssetError: function() {\n        return markAssetError;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getassetpathfromroute = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/router/utils/get-asset-path-from-route */ \"./node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js\"));\nconst _trustedtypes = __webpack_require__(/*! ./trusted-types */ \"./node_modules/next/dist/client/trusted-types.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst _deploymentid = __webpack_require__(/*! ../build/deployment-id */ \"./node_modules/next/dist/build/deployment-id.js\");\nconst _encodeuripath = __webpack_require__(/*! ../shared/lib/encode-uri-path */ \"./node_modules/next/dist/shared/lib/encode-uri-path.js\");\n// 3.8s was arbitrarily chosen as it's what https://web.dev/interactive\n// considers as \"Good\" time-to-interactive. We must assume something went\n// wrong beyond this point, and then fall-back to a full page transition to\n// show the user something of value.\nconst MS_MAX_IDLE_DELAY = 3800;\nfunction withFuture(key, map, generator) {\n    let entry = map.get(key);\n    if (entry) {\n        if ('future' in entry) {\n            return entry.future;\n        }\n        return Promise.resolve(entry);\n    }\n    let resolver;\n    const prom = new Promise((resolve)=>{\n        resolver = resolve;\n    });\n    map.set(key, {\n        resolve: resolver,\n        future: prom\n    });\n    return generator ? generator().then((value)=>{\n        resolver(value);\n        return value;\n    }).catch((err)=>{\n        map.delete(key);\n        throw err;\n    }) : prom;\n}\nconst ASSET_LOAD_ERROR = Symbol('ASSET_LOAD_ERROR');\nfunction markAssetError(err) {\n    return Object.defineProperty(err, ASSET_LOAD_ERROR, {});\n}\nfunction isAssetError(err) {\n    return err && ASSET_LOAD_ERROR in err;\n}\nfunction hasPrefetch(link) {\n    try {\n        link = document.createElement('link');\n        return(// with relList.support\n        !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports('prefetch'));\n    } catch (e) {\n        return false;\n    }\n}\nconst canPrefetch = hasPrefetch();\nconst getAssetQueryString = ()=>{\n    return (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();\n};\nfunction prefetchViaDom(href, as, link) {\n    return new Promise((resolve, reject)=>{\n        const selector = '\\n      link[rel=\"prefetch\"][href^=\"' + href + '\"],\\n      link[rel=\"preload\"][href^=\"' + href + '\"],\\n      script[src^=\"' + href + '\"]';\n        if (document.querySelector(selector)) {\n            return resolve();\n        }\n        link = document.createElement('link');\n        // The order of property assignment here is intentional:\n        if (as) link.as = as;\n        link.rel = \"prefetch\";\n        link.crossOrigin = undefined;\n        link.onload = resolve;\n        link.onerror = ()=>reject(markAssetError(new Error(\"Failed to prefetch: \" + href)));\n        // `href` should always be last:\n        link.href = href;\n        document.head.appendChild(link);\n    });\n}\nfunction appendScript(src, script) {\n    return new Promise((resolve, reject)=>{\n        script = document.createElement('script');\n        // The order of property assignment here is intentional.\n        // 1. Setup success/failure hooks in case the browser synchronously\n        //    executes when `src` is set.\n        script.onload = resolve;\n        script.onerror = ()=>reject(markAssetError(new Error(\"Failed to load script: \" + src)));\n        // 2. Configure the cross-origin attribute before setting `src` in case the\n        //    browser begins to fetch.\n        script.crossOrigin = undefined;\n        // 3. Finally, set the source and inject into the DOM in case the child\n        //    must be appended for fetching to start.\n        script.src = src;\n        document.body.appendChild(script);\n    });\n}\n// We wait for pages to be built in dev before we start the route transition\n// timeout to prevent an un-necessary hard navigation in development.\nlet devBuildPromise;\n// Resolve a promise that times out after given amount of milliseconds.\nfunction resolvePromiseWithTimeout(p, ms, err) {\n    return new Promise((resolve, reject)=>{\n        let cancelled = false;\n        p.then((r)=>{\n            // Resolved, cancel the timeout\n            cancelled = true;\n            resolve(r);\n        }).catch(reject);\n        // We wrap these checks separately for better dead-code elimination in\n        // production bundles.\n        if (true) {\n            ;\n            (devBuildPromise || Promise.resolve()).then(()=>{\n                (0, _requestidlecallback.requestIdleCallback)(()=>setTimeout(()=>{\n                        if (!cancelled) {\n                            reject(err);\n                        }\n                    }, ms));\n            });\n        }\n        if (false) {}\n    });\n}\nfunction getClientBuildManifest() {\n    if (self.__BUILD_MANIFEST) {\n        return Promise.resolve(self.__BUILD_MANIFEST);\n    }\n    const onBuildManifest = new Promise((resolve)=>{\n        // Mandatory because this is not concurrent safe:\n        const cb = self.__BUILD_MANIFEST_CB;\n        self.__BUILD_MANIFEST_CB = ()=>{\n            resolve(self.__BUILD_MANIFEST);\n            cb && cb();\n        };\n    });\n    return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(new Error('Failed to load client build manifest')));\n}\nfunction getFilesForRoute(assetPrefix, route) {\n    if (true) {\n        const scriptUrl = assetPrefix + '/_next/static/chunks/pages' + (0, _encodeuripath.encodeURIPath)((0, _getassetpathfromroute.default)(route, '.js')) + getAssetQueryString();\n        return Promise.resolve({\n            scripts: [\n                (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(scriptUrl)\n            ],\n            // Styles are handled by `style-loader` in development:\n            css: []\n        });\n    }\n    return getClientBuildManifest().then((manifest)=>{\n        if (!(route in manifest)) {\n            throw markAssetError(new Error(\"Failed to lookup route: \" + route));\n        }\n        const allFiles = manifest[route].map((entry)=>assetPrefix + '/_next/' + (0, _encodeuripath.encodeURIPath)(entry));\n        return {\n            scripts: allFiles.filter((v)=>v.endsWith('.js')).map((v)=>(0, _trustedtypes.__unsafeCreateTrustedScriptURL)(v) + getAssetQueryString()),\n            css: allFiles.filter((v)=>v.endsWith('.css')).map((v)=>v + getAssetQueryString())\n        };\n    });\n}\nfunction createRouteLoader(assetPrefix) {\n    const entrypoints = new Map();\n    const loadedScripts = new Map();\n    const styleSheets = new Map();\n    const routes = new Map();\n    function maybeExecuteScript(src) {\n        // With HMR we might need to \"reload\" scripts when they are\n        // disposed and readded. Executing scripts twice has no functional\n        // differences\n        if (false) {} else {\n            return appendScript(src);\n        }\n    }\n    function fetchStyleSheet(href) {\n        let prom = styleSheets.get(href);\n        if (prom) {\n            return prom;\n        }\n        styleSheets.set(href, prom = fetch(href, {\n            credentials: 'same-origin'\n        }).then((res)=>{\n            if (!res.ok) {\n                throw new Error(\"Failed to load stylesheet: \" + href);\n            }\n            return res.text().then((text)=>({\n                    href: href,\n                    content: text\n                }));\n        }).catch((err)=>{\n            throw markAssetError(err);\n        }));\n        return prom;\n    }\n    return {\n        whenEntrypoint (route) {\n            return withFuture(route, entrypoints);\n        },\n        onEntrypoint (route, execute) {\n            ;\n            (execute ? Promise.resolve().then(()=>execute()).then((exports1)=>({\n                    component: exports1 && exports1.default || exports1,\n                    exports: exports1\n                }), (err)=>({\n                    error: err\n                })) : Promise.resolve(undefined)).then((input)=>{\n                const old = entrypoints.get(route);\n                if (old && 'resolve' in old) {\n                    if (input) {\n                        entrypoints.set(route, input);\n                        old.resolve(input);\n                    }\n                } else {\n                    if (input) {\n                        entrypoints.set(route, input);\n                    } else {\n                        entrypoints.delete(route);\n                    }\n                    // when this entrypoint has been resolved before\n                    // the route is outdated and we want to invalidate\n                    // this cache entry\n                    routes.delete(route);\n                }\n            });\n        },\n        loadRoute (route, prefetch) {\n            return withFuture(route, routes, ()=>{\n                let devBuildPromiseResolve;\n                if (true) {\n                    devBuildPromise = new Promise((resolve)=>{\n                        devBuildPromiseResolve = resolve;\n                    });\n                }\n                return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param)=>{\n                    let { scripts, css } = param;\n                    return Promise.all([\n                        entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),\n                        Promise.all(css.map(fetchStyleSheet))\n                    ]);\n                }).then((res)=>{\n                    return this.whenEntrypoint(route).then((entrypoint)=>({\n                            entrypoint,\n                            styles: res[1]\n                        }));\n                }), MS_MAX_IDLE_DELAY, markAssetError(new Error(\"Route did not complete loading: \" + route))).then((param)=>{\n                    let { entrypoint, styles } = param;\n                    const res = Object.assign({\n                        styles: styles\n                    }, entrypoint);\n                    return 'error' in entrypoint ? entrypoint : res;\n                }).catch((err)=>{\n                    if (prefetch) {\n                        // we don't want to cache errors during prefetch\n                        throw err;\n                    }\n                    return {\n                        error: err\n                    };\n                }).finally(()=>devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve());\n            });\n        },\n        prefetch (route) {\n            // https://github.com/GoogleChromeLabs/quicklink/blob/453a661fa1fa940e2d2e044452398e38c67a98fb/src/index.mjs#L115-L118\n            // License: Apache 2.0\n            let cn;\n            if (cn = navigator.connection) {\n                // Don't prefetch if using 2G or if Save-Data is enabled.\n                if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();\n            }\n            return getFilesForRoute(assetPrefix, route).then((output)=>Promise.all(canPrefetch ? output.scripts.map((script)=>prefetchViaDom(script.toString(), 'script')) : [])).then(()=>{\n                (0, _requestidlecallback.requestIdleCallback)(()=>this.loadRoute(route, true).catch(()=>{}));\n            }).catch(()=>{});\n        }\n    };\n}\nif ((typeof exports.default === 'function' || typeof exports.default === 'object' && exports.default !== null) && typeof exports.default.__esModule === 'undefined') {\n    Object.defineProperty(exports.default, '__esModule', {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=route-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9yb3V0ZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBaVNnQkEsaUJBQWlCO2VBQWpCQTs7SUEzREFDLHNCQUFzQjtlQUF0QkE7O0lBbklBQyxZQUFZO2VBQVpBOztJQUpBQyxjQUFjO2VBQWRBOzs7OzRGQTdGa0I7MENBQ2E7aURBQ1g7MENBQ2M7MkNBQ3BCO0FBRTlCLHVFQUF1RTtBQUN2RSx5RUFBeUU7QUFDekUsMkVBQTJFO0FBQzNFLG9DQUFvQztBQUNwQyxNQUFNQyxvQkFBb0I7QUE0QzFCLFNBQVNDLFdBQ1BDLEdBQVcsRUFDWEMsR0FBK0IsRUFDL0JDLFNBQTRCO0lBRTVCLElBQUlDLFFBQVFGLElBQUlHLEdBQUcsQ0FBQ0o7SUFDcEIsSUFBSUcsT0FBTztRQUNULElBQUksWUFBWUEsT0FBTztZQUNyQixPQUFPQSxNQUFNRSxNQUFNO1FBQ3JCO1FBQ0EsT0FBT0MsUUFBUUMsT0FBTyxDQUFDSjtJQUN6QjtJQUNBLElBQUlLO0lBQ0osTUFBTUMsT0FBbUIsSUFBSUgsUUFBVyxDQUFDQztRQUN2Q0MsV0FBV0Q7SUFDYjtJQUNBTixJQUFJUyxHQUFHLENBQUNWLEtBQUs7UUFBRU8sU0FBU0M7UUFBV0gsUUFBUUk7SUFBSztJQUNoRCxPQUFPUCxZQUNIQSxZQUNHUyxJQUFJLENBQUMsQ0FBQ0M7UUFDTEosU0FBU0k7UUFDVCxPQUFPQTtJQUNULEdBQ0NDLEtBQUssQ0FBQyxDQUFDQztRQUNOYixJQUFJYyxNQUFNLENBQUNmO1FBQ1gsTUFBTWM7SUFDUixLQUNGTDtBQUNOO0FBU0EsTUFBTU8sbUJBQW1CQyxPQUFPO0FBRXpCLFNBQVNwQixlQUFlaUIsR0FBVTtJQUN2QyxPQUFPSSxPQUFPQyxjQUFjLENBQUNMLEtBQUtFLGtCQUFrQixDQUFDO0FBQ3ZEO0FBRU8sU0FBU3BCLGFBQWFrQixHQUFXO0lBQ3RDLE9BQU9BLE9BQU9FLG9CQUFvQkY7QUFDcEM7QUFFQSxTQUFTTSxZQUFZ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QW9CLElBQU0sSUFBSSxDQUFDNkMsU0FBUyxDQUFDcEMsT0FBTyxNQUFNdkQsS0FBSyxDQUFDLEtBQU87WUFDckUsR0FDQ0EsS0FBSyxDQUNKLEtBQ087UUFFYjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVvbmFcXFByb2plY3RzXFxzcmNcXGNsaWVudFxccm91dGUtbG9hZGVyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHR5cGUgeyBNaWRkbGV3YXJlTWF0Y2hlciB9IGZyb20gJy4uL2J1aWxkL2FuYWx5c2lzL2dldC1wYWdlLXN0YXRpYy1pbmZvJ1xuaW1wb3J0IGdldEFzc2V0UGF0aEZyb21Sb3V0ZSBmcm9tICcuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9nZXQtYXNzZXQtcGF0aC1mcm9tLXJvdXRlJ1xuaW1wb3J0IHsgX191bnNhZmVDcmVhdGVUcnVzdGVkU2NyaXB0VVJMIH0gZnJvbSAnLi90cnVzdGVkLXR5cGVzJ1xuaW1wb3J0IHsgcmVxdWVzdElkbGVDYWxsYmFjayB9IGZyb20gJy4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrJ1xuaW1wb3J0IHsgZ2V0RGVwbG95bWVudElkUXVlcnlPckVtcHR5U3RyaW5nIH0gZnJvbSAnLi4vYnVpbGQvZGVwbG95bWVudC1pZCdcbmltcG9ydCB7IGVuY29kZVVSSVBhdGggfSBmcm9tICcuLi9zaGFyZWQvbGliL2VuY29kZS11cmktcGF0aCdcblxuLy8gMy44cyB3YXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGl0J3Mgd2hhdCBodHRwczovL3dlYi5kZXYvaW50ZXJhY3RpdmVcbi8vIGNvbnNpZGVycyBhcyBcIkdvb2RcIiB0aW1lLXRvLWludGVyYWN0aXZlLiBXZSBtdXN0IGFzc3VtZSBzb21ldGhpbmcgd2VudFxuLy8gd3JvbmcgYmV5b25kIHRoaXMgcG9pbnQsIGFuZCB0aGVuIGZhbGwtYmFjayB0byBhIGZ1bGwgcGFnZSB0cmFuc2l0aW9uIHRvXG4vLyBzaG93IHRoZSB1c2VyIHNvbWV0aGluZyBvZiB2YWx1ZS5cbmNvbnN0IE1TX01BWF9JRExFX0RFTEFZID0gMzgwMFxuXG5kZWNsYXJlIGdsb2JhbCB7XG4gIGludGVyZmFjZSBXaW5kb3cge1xuICAgIF9fQlVJTERfTUFOSUZFU1Q/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT5cbiAgICBfX0JVSUxEX01BTklGRVNUX0NCPzogRnVuY3Rpb25cbiAgICBfX01JRERMRVdBUkVfTUFUQ0hFUlM/OiBNaWRkbGV3YXJlTWF0Y2hlcltdXG4gICAgX19NSURETEVXQVJFX01BTklGRVNUX0NCPzogRnVuY3Rpb25cbiAgICBfX1JFQUNUX0xPQURBQkxFX01BTklGRVNUPzogYW55XG4gICAgX19EWU5BTUlDX0NTU19NQU5JRkVTVD86IGFueVxuICAgIF9fUlNDX01BTklGRVNUPzogYW55XG4gICAgX19SU0NfU0VSVkVSX01BTklGRVNUPzogYW55XG4gICAgX19ORVhUX0ZPTlRfTUFOSUZFU1Q/OiBhbnlcbiAgICBfX1NVQlJFU09VUkNFX0lOVEVHUklUWV9NQU5JRkVTVD86IHN0cmluZ1xuICAgIF9fSU5URVJDRVBUSU9OX1JPVVRFX1JFV1JJVEVfTUFOSUZFU1Q/OiBzdHJpbmdcbiAgfVxufVxuXG5pbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludFN1Y2Nlc3Mge1xuICBjb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgZXhwb3J0czogYW55XG59XG5pbnRlcmZhY2UgTG9hZGVkRW50cnlwb2ludEZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxudHlwZSBSb3V0ZUVudHJ5cG9pbnQgPSBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB8IExvYWRlZEVudHJ5cG9pbnRGYWlsdXJlXG5cbmludGVyZmFjZSBSb3V0ZVN0eWxlU2hlZXQge1xuICBocmVmOiBzdHJpbmdcbiAgY29udGVudDogc3RyaW5nXG59XG5cbmludGVyZmFjZSBMb2FkZWRSb3V0ZVN1Y2Nlc3MgZXh0ZW5kcyBMb2FkZWRFbnRyeXBvaW50U3VjY2VzcyB7XG4gIHN0eWxlczogUm91dGVTdHlsZVNoZWV0W11cbn1cbmludGVyZmFjZSBMb2FkZWRSb3V0ZUZhaWx1cmUge1xuICBlcnJvcjogdW5rbm93blxufVxudHlwZSBSb3V0ZUxvYWRlckVudHJ5ID0gTG9hZGVkUm91dGVTdWNjZXNzIHwgTG9hZGVkUm91dGVGYWlsdXJlXG5cbmludGVyZmFjZSBGdXR1cmU8Vj4ge1xuICByZXNvbHZlOiAoZW50cnlwb2ludDogVikgPT4gdm9pZFxuICBmdXR1cmU6IFByb21pc2U8Vj5cbn1cbmZ1bmN0aW9uIHdpdGhGdXR1cmU8VCBleHRlbmRzIG9iamVjdD4oXG4gIGtleTogc3RyaW5nLFxuICBtYXA6IE1hcDxzdHJpbmcsIEZ1dHVyZTxUPiB8IFQ+LFxuICBnZW5lcmF0b3I/OiAoKSA9PiBQcm9taXNlPFQ+XG4pOiBQcm9taXNlPFQ+IHtcbiAgbGV0IGVudHJ5ID0gbWFwLmdldChrZXkpXG4gIGlmIChlbnRyeSkge1xuICAgIGlmICgnZnV0dXJlJyBpbiBlbnRyeSkge1xuICAgICAgcmV0dXJuIGVudHJ5LmZ1dHVyZVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KVxuICB9XG4gIGxldCByZXNvbHZlcjogKGVudHJ5cG9pbnQ6IFQpID0+IHZvaWRcbiAgY29uc3QgcHJvbTogUHJvbWlzZTxUPiA9IG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlKSA9PiB7XG4gICAgcmVzb2x2ZXIgPSByZXNvbHZlXG4gIH0pXG4gIG1hcC5zZXQoa2V5LCB7IHJlc29sdmU6IHJlc29sdmVyISwgZnV0dXJlOiBwcm9tIH0pXG4gIHJldHVybiBnZW5lcmF0b3JcbiAgICA/IGdlbmVyYXRvcigpXG4gICAgICAgIC50aGVuKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHJlc29sdmVyKHZhbHVlKVxuICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgIG1hcC5kZWxldGUoa2V5KVxuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9KVxuICAgIDogcHJvbVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlTG9hZGVyIHtcbiAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Um91dGVFbnRyeXBvaW50PlxuICBvbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZywgZXhlY3V0ZTogKCkgPT4gdW5rbm93bik6IHZvaWRcbiAgbG9hZFJvdXRlKHJvdXRlOiBzdHJpbmcsIHByZWZldGNoPzogYm9vbGVhbik6IFByb21pc2U8Um91dGVMb2FkZXJFbnRyeT5cbiAgcHJlZmV0Y2gocm91dGU6IHN0cmluZyk6IFByb21pc2U8dm9pZD5cbn1cblxuY29uc3QgQVNTRVRfTE9BRF9FUlJPUiA9IFN5bWJvbCgnQVNTRVRfTE9BRF9FUlJPUicpXG4vLyBUT0RPOiB1bmV4cG9ydFxuZXhwb3J0IGZ1bmN0aW9uIG1hcmtBc3NldEVycm9yKGVycjogRXJyb3IpOiBFcnJvciB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyLCBBU1NFVF9MT0FEX0VSUk9SLCB7fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzZXRFcnJvcihlcnI/OiBFcnJvcik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gZXJyICYmIEFTU0VUX0xPQURfRVJST1IgaW4gZXJyXG59XG5cbmZ1bmN0aW9uIGhhc1ByZWZldGNoKGxpbms/OiBIVE1MTGlua0VsZW1lbnQpOiBib29sZWFuIHtcbiAgdHJ5IHtcbiAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGRldGVjdCBJRTExIHNpbmNlIGl0IHN1cHBvcnRzIHByZWZldGNoIGJ1dCBpc24ndCBkZXRlY3RlZFxuICAgICAgLy8gd2l0aCByZWxMaXN0LnN1cHBvcnRcbiAgICAgICghIXdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiAhIShkb2N1bWVudCBhcyBhbnkpLmRvY3VtZW50TW9kZSkgfHxcbiAgICAgIGxpbmsucmVsTGlzdC5zdXBwb3J0cygncHJlZmV0Y2gnKVxuICAgIClcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuY29uc3QgY2FuUHJlZmV0Y2g6IGJvb2xlYW4gPSBoYXNQcmVmZXRjaCgpXG5cbmNvbnN0IGdldEFzc2V0UXVlcnlTdHJpbmcgPSAoKSA9PiB7XG4gIHJldHVybiBnZXREZXBsb3ltZW50SWRRdWVyeU9yRW1wdHlTdHJpbmcoKVxufVxuXG5mdW5jdGlvbiBwcmVmZXRjaFZpYURvbShcbiAgaHJlZjogc3RyaW5nLFxuICBhczogc3RyaW5nLFxuICBsaW5rPzogSFRNTExpbmtFbGVtZW50XG4pOiBQcm9taXNlPGFueT4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdG9yID0gYFxuICAgICAgbGlua1tyZWw9XCJwcmVmZXRjaFwiXVtocmVmXj1cIiR7aHJlZn1cIl0sXG4gICAgICBsaW5rW3JlbD1cInByZWxvYWRcIl1baHJlZl49XCIke2hyZWZ9XCJdLFxuICAgICAgc2NyaXB0W3NyY149XCIke2hyZWZ9XCJdYFxuICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoKVxuICAgIH1cblxuICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaW5rJylcblxuICAgIC8vIFRoZSBvcmRlciBvZiBwcm9wZXJ0eSBhc3NpZ25tZW50IGhlcmUgaXMgaW50ZW50aW9uYWw6XG4gICAgaWYgKGFzKSBsaW5rIS5hcyA9IGFzXG4gICAgbGluayEucmVsID0gYHByZWZldGNoYFxuICAgIGxpbmshLmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcbiAgICBsaW5rIS5vbmxvYWQgPSByZXNvbHZlIGFzIGFueVxuICAgIGxpbmshLm9uZXJyb3IgPSAoKSA9PlxuICAgICAgcmVqZWN0KG1hcmtBc3NldEVycm9yKG5ldyBFcnJvcihgRmFpbGVkIHRvIHByZWZldGNoOiAke2hyZWZ9YCkpKVxuXG4gICAgLy8gYGhyZWZgIHNob3VsZCBhbHdheXMgYmUgbGFzdDpcbiAgICBsaW5rIS5ocmVmID0gaHJlZlxuXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKVxuICB9KVxufVxuXG5mdW5jdGlvbiBhcHBlbmRTY3JpcHQoXG4gIHNyYzogVHJ1c3RlZFNjcmlwdFVSTCB8IHN0cmluZyxcbiAgc2NyaXB0PzogSFRNTFNjcmlwdEVsZW1lbnRcbik6IFByb21pc2U8dW5rbm93bj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG5cbiAgICAvLyBUaGUgb3JkZXIgb2YgcHJvcGVydHkgYXNzaWdubWVudCBoZXJlIGlzIGludGVudGlvbmFsLlxuICAgIC8vIDEuIFNldHVwIHN1Y2Nlc3MvZmFpbHVyZSBob29rcyBpbiBjYXNlIHRoZSBicm93c2VyIHN5bmNocm9ub3VzbHlcbiAgICAvLyAgICBleGVjdXRlcyB3aGVuIGBzcmNgIGlzIHNldC5cbiAgICBzY3JpcHQub25sb2FkID0gcmVzb2x2ZVxuICAgIHNjcmlwdC5vbmVycm9yID0gKCkgPT5cbiAgICAgIHJlamVjdChtYXJrQXNzZXRFcnJvcihuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHNjcmlwdDogJHtzcmN9YCkpKVxuXG4gICAgLy8gMi4gQ29uZmlndXJlIHRoZSBjcm9zcy1vcmlnaW4gYXR0cmlidXRlIGJlZm9yZSBzZXR0aW5nIGBzcmNgIGluIGNhc2UgdGhlXG4gICAgLy8gICAgYnJvd3NlciBiZWdpbnMgdG8gZmV0Y2guXG4gICAgc2NyaXB0LmNyb3NzT3JpZ2luID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NST1NTX09SSUdJTiFcblxuICAgIC8vIDMuIEZpbmFsbHksIHNldCB0aGUgc291cmNlIGFuZCBpbmplY3QgaW50byB0aGUgRE9NIGluIGNhc2UgdGhlIGNoaWxkXG4gICAgLy8gICAgbXVzdCBiZSBhcHBlbmRlZCBmb3IgZmV0Y2hpbmcgdG8gc3RhcnQuXG4gICAgc2NyaXB0LnNyYyA9IHNyYyBhcyBzdHJpbmdcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdClcbiAgfSlcbn1cblxuLy8gV2Ugd2FpdCBmb3IgcGFnZXMgdG8gYmUgYnVpbHQgaW4gZGV2IGJlZm9yZSB3ZSBzdGFydCB0aGUgcm91dGUgdHJhbnNpdGlvblxuLy8gdGltZW91dCB0byBwcmV2ZW50IGFuIHVuLW5lY2Vzc2FyeSBoYXJkIG5hdmlnYXRpb24gaW4gZGV2ZWxvcG1lbnQuXG5sZXQgZGV2QnVpbGRQcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkXG5cbi8vIFJlc29sdmUgYSBwcm9taXNlIHRoYXQgdGltZXMgb3V0IGFmdGVyIGdpdmVuIGFtb3VudCBvZiBtaWxsaXNlY29uZHMuXG5mdW5jdGlvbiByZXNvbHZlUHJvbWlzZVdpdGhUaW1lb3V0PFQ+KFxuICBwOiBQcm9taXNlPFQ+LFxuICBtczogbnVtYmVyLFxuICBlcnI6IEVycm9yXG4pOiBQcm9taXNlPFQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2VcblxuICAgIHAudGhlbigocikgPT4ge1xuICAgICAgLy8gUmVzb2x2ZWQsIGNhbmNlbCB0aGUgdGltZW91dFxuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgcmVzb2x2ZShyKVxuICAgIH0pLmNhdGNoKHJlamVjdClcblxuICAgIC8vIFdlIHdyYXAgdGhlc2UgY2hlY2tzIHNlcGFyYXRlbHkgZm9yIGJldHRlciBkZWFkLWNvZGUgZWxpbWluYXRpb24gaW5cbiAgICAvLyBwcm9kdWN0aW9uIGJ1bmRsZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICA7KGRldkJ1aWxkUHJvbWlzZSB8fCBQcm9taXNlLnJlc29sdmUoKSkudGhlbigoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT5cbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbXMpXG4gICAgICAgIClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICByZXF1ZXN0SWRsZUNhbGxiYWNrKCgpID0+XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlmICghY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgbXMpXG4gICAgICApXG4gICAgfVxuICB9KVxufVxuXG4vLyBUT0RPOiBzdG9wIGV4cG9ydGluZyBvciBjYWNoZSB0aGUgZmFpbHVyZVxuLy8gSXQnZCBiZSBiZXN0IHRvIHN0b3AgZXhwb3J0aW5nIHRoaXMuIEl0J3MgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLiBXZSdyZVxuLy8gb25seSBleHBvcnRpbmcgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGBwYWdlLWxvYWRlcmAuXG4vLyBPbmx5IGNhY2hlIHRoaXMgcmVzcG9uc2UgYXMgYSBsYXN0IHJlc29ydCBpZiB3ZSBjYW5ub3QgZWxpbWluYXRlIGFsbCBvdGhlclxuLy8gY29kZSBicmFuY2hlcyB0aGF0IHVzZSB0aGUgQnVpbGQgTWFuaWZlc3QgQ2FsbGJhY2sgYW5kIHB1c2ggdGhlbSB0aHJvdWdoXG4vLyB0aGUgUm91dGUgTG9hZGVyIGludGVyZmFjZS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRCdWlsZE1hbmlmZXN0KCkge1xuICBpZiAoc2VsZi5fX0JVSUxEX01BTklGRVNUKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QpXG4gIH1cblxuICBjb25zdCBvbkJ1aWxkTWFuaWZlc3QgPSBuZXcgUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBzdHJpbmdbXT4+KChyZXNvbHZlKSA9PiB7XG4gICAgLy8gTWFuZGF0b3J5IGJlY2F1c2UgdGhpcyBpcyBub3QgY29uY3VycmVudCBzYWZlOlxuICAgIGNvbnN0IGNiID0gc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCXG4gICAgc2VsZi5fX0JVSUxEX01BTklGRVNUX0NCID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShzZWxmLl9fQlVJTERfTUFOSUZFU1QhKVxuICAgICAgY2IgJiYgY2IoKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gcmVzb2x2ZVByb21pc2VXaXRoVGltZW91dChcbiAgICBvbkJ1aWxkTWFuaWZlc3QsXG4gICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBjbGllbnQgYnVpbGQgbWFuaWZlc3QnKSlcbiAgKVxufVxuXG5pbnRlcmZhY2UgUm91dGVGaWxlcyB7XG4gIHNjcmlwdHM6IChUcnVzdGVkU2NyaXB0VVJMIHwgc3RyaW5nKVtdXG4gIGNzczogc3RyaW5nW11cbn1cbmZ1bmN0aW9uIGdldEZpbGVzRm9yUm91dGUoXG4gIGFzc2V0UHJlZml4OiBzdHJpbmcsXG4gIHJvdXRlOiBzdHJpbmdcbik6IFByb21pc2U8Um91dGVGaWxlcz4ge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICBjb25zdCBzY3JpcHRVcmwgPVxuICAgICAgYXNzZXRQcmVmaXggK1xuICAgICAgJy9fbmV4dC9zdGF0aWMvY2h1bmtzL3BhZ2VzJyArXG4gICAgICBlbmNvZGVVUklQYXRoKGdldEFzc2V0UGF0aEZyb21Sb3V0ZShyb3V0ZSwgJy5qcycpKSArXG4gICAgICBnZXRBc3NldFF1ZXJ5U3RyaW5nKClcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgIHNjcmlwdHM6IFtfX3Vuc2FmZUNyZWF0ZVRydXN0ZWRTY3JpcHRVUkwoc2NyaXB0VXJsKV0sXG4gICAgICAvLyBTdHlsZXMgYXJlIGhhbmRsZWQgYnkgYHN0eWxlLWxvYWRlcmAgaW4gZGV2ZWxvcG1lbnQ6XG4gICAgICBjc3M6IFtdLFxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGdldENsaWVudEJ1aWxkTWFuaWZlc3QoKS50aGVuKChtYW5pZmVzdCkgPT4ge1xuICAgIGlmICghKHJvdXRlIGluIG1hbmlmZXN0KSkge1xuICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBGYWlsZWQgdG8gbG9va3VwIHJvdXRlOiAke3JvdXRlfWApKVxuICAgIH1cbiAgICBjb25zdCBhbGxGaWxlcyA9IG1hbmlmZXN0W3JvdXRlXS5tYXAoXG4gICAgICAoZW50cnkpID0+IGFzc2V0UHJlZml4ICsgJy9fbmV4dC8nICsgZW5jb2RlVVJJUGF0aChlbnRyeSlcbiAgICApXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcmlwdHM6IGFsbEZpbGVzXG4gICAgICAgIC5maWx0ZXIoKHYpID0+IHYuZW5kc1dpdGgoJy5qcycpKVxuICAgICAgICAubWFwKCh2KSA9PiBfX3Vuc2FmZUNyZWF0ZVRydXN0ZWRTY3JpcHRVUkwodikgKyBnZXRBc3NldFF1ZXJ5U3RyaW5nKCkpLFxuICAgICAgY3NzOiBhbGxGaWxlc1xuICAgICAgICAuZmlsdGVyKCh2KSA9PiB2LmVuZHNXaXRoKCcuY3NzJykpXG4gICAgICAgIC5tYXAoKHYpID0+IHYgKyBnZXRBc3NldFF1ZXJ5U3RyaW5nKCkpLFxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlTG9hZGVyKGFzc2V0UHJlZml4OiBzdHJpbmcpOiBSb3V0ZUxvYWRlciB7XG4gIGNvbnN0IGVudHJ5cG9pbnRzOiBNYXA8c3RyaW5nLCBGdXR1cmU8Um91dGVFbnRyeXBvaW50PiB8IFJvdXRlRW50cnlwb2ludD4gPVxuICAgIG5ldyBNYXAoKVxuICBjb25zdCBsb2FkZWRTY3JpcHRzOiBNYXA8c3RyaW5nLCBQcm9taXNlPHVua25vd24+PiA9IG5ldyBNYXAoKVxuICBjb25zdCBzdHlsZVNoZWV0czogTWFwPHN0cmluZywgUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+PiA9IG5ldyBNYXAoKVxuICBjb25zdCByb3V0ZXM6IE1hcDxzdHJpbmcsIEZ1dHVyZTxSb3V0ZUxvYWRlckVudHJ5PiB8IFJvdXRlTG9hZGVyRW50cnk+ID1cbiAgICBuZXcgTWFwKClcblxuICBmdW5jdGlvbiBtYXliZUV4ZWN1dGVTY3JpcHQoXG4gICAgc3JjOiBUcnVzdGVkU2NyaXB0VVJMIHwgc3RyaW5nXG4gICk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgIC8vIFdpdGggSE1SIHdlIG1pZ2h0IG5lZWQgdG8gXCJyZWxvYWRcIiBzY3JpcHRzIHdoZW4gdGhleSBhcmVcbiAgICAvLyBkaXNwb3NlZCBhbmQgcmVhZGRlZC4gRXhlY3V0aW5nIHNjcmlwdHMgdHdpY2UgaGFzIG5vIGZ1bmN0aW9uYWxcbiAgICAvLyBkaWZmZXJlbmNlc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgbGV0IHByb206IFByb21pc2U8dW5rbm93bj4gfCB1bmRlZmluZWQgPSBsb2FkZWRTY3JpcHRzLmdldChzcmMudG9TdHJpbmcoKSlcbiAgICAgIGlmIChwcm9tKSB7XG4gICAgICAgIHJldHVybiBwcm9tXG4gICAgICB9XG5cbiAgICAgIC8vIFNraXAgZXhlY3V0aW5nIHNjcmlwdCBpZiBpdCdzIGFscmVhZHkgaW4gdGhlIERPTTpcbiAgICAgIGlmIChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBzY3JpcHRbc3JjXj1cIiR7c3JjfVwiXWApKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuXG4gICAgICBsb2FkZWRTY3JpcHRzLnNldChzcmMudG9TdHJpbmcoKSwgKHByb20gPSBhcHBlbmRTY3JpcHQoc3JjKSkpXG4gICAgICByZXR1cm4gcHJvbVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXBwZW5kU2NyaXB0KHNyYylcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmZXRjaFN0eWxlU2hlZXQoaHJlZjogc3RyaW5nKTogUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+IHtcbiAgICBsZXQgcHJvbTogUHJvbWlzZTxSb3V0ZVN0eWxlU2hlZXQ+IHwgdW5kZWZpbmVkID0gc3R5bGVTaGVldHMuZ2V0KGhyZWYpXG4gICAgaWYgKHByb20pIHtcbiAgICAgIHJldHVybiBwcm9tXG4gICAgfVxuXG4gICAgc3R5bGVTaGVldHMuc2V0KFxuICAgICAgaHJlZixcbiAgICAgIChwcm9tID0gZmV0Y2goaHJlZiwgeyBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJyB9KVxuICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgc3R5bGVzaGVldDogJHtocmVmfWApXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4oKHRleHQpID0+ICh7IGhyZWY6IGhyZWYsIGNvbnRlbnQ6IHRleHQgfSkpXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgdGhyb3cgbWFya0Fzc2V0RXJyb3IoZXJyKVxuICAgICAgICB9KSlcbiAgICApXG4gICAgcmV0dXJuIHByb21cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2hlbkVudHJ5cG9pbnQocm91dGU6IHN0cmluZykge1xuICAgICAgcmV0dXJuIHdpdGhGdXR1cmUocm91dGUsIGVudHJ5cG9pbnRzKVxuICAgIH0sXG4gICAgb25FbnRyeXBvaW50KHJvdXRlOiBzdHJpbmcsIGV4ZWN1dGU6IHVuZGVmaW5lZCB8ICgoKSA9PiB1bmtub3duKSkge1xuICAgICAgOyhleGVjdXRlXG4gICAgICAgID8gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgIC50aGVuKCgpID0+IGV4ZWN1dGUoKSlcbiAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAoZXhwb3J0czogYW55KSA9PiAoe1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudDogKGV4cG9ydHMgJiYgZXhwb3J0cy5kZWZhdWx0KSB8fCBleHBvcnRzLFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGV4cG9ydHMsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAoZXJyKSA9PiAoeyBlcnJvcjogZXJyIH0pXG4gICAgICAgICAgICApXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZClcbiAgICAgICkudGhlbigoaW5wdXQ6IFJvdXRlRW50cnlwb2ludCB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBjb25zdCBvbGQgPSBlbnRyeXBvaW50cy5nZXQocm91dGUpXG4gICAgICAgIGlmIChvbGQgJiYgJ3Jlc29sdmUnIGluIG9sZCkge1xuICAgICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgICAgZW50cnlwb2ludHMuc2V0KHJvdXRlLCBpbnB1dClcbiAgICAgICAgICAgIG9sZC5yZXNvbHZlKGlucHV0KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAgICAgIGVudHJ5cG9pbnRzLnNldChyb3V0ZSwgaW5wdXQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVudHJ5cG9pbnRzLmRlbGV0ZShyb3V0ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2hlbiB0aGlzIGVudHJ5cG9pbnQgaGFzIGJlZW4gcmVzb2x2ZWQgYmVmb3JlXG4gICAgICAgICAgLy8gdGhlIHJvdXRlIGlzIG91dGRhdGVkIGFuZCB3ZSB3YW50IHRvIGludmFsaWRhdGVcbiAgICAgICAgICAvLyB0aGlzIGNhY2hlIGVudHJ5XG4gICAgICAgICAgcm91dGVzLmRlbGV0ZShyb3V0ZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIGxvYWRSb3V0ZShyb3V0ZTogc3RyaW5nLCBwcmVmZXRjaD86IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiB3aXRoRnV0dXJlPFJvdXRlTG9hZGVyRW50cnk+KHJvdXRlLCByb3V0ZXMsICgpID0+IHtcbiAgICAgICAgbGV0IGRldkJ1aWxkUHJvbWlzZVJlc29sdmU6ICgpID0+IHZvaWRcblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBkZXZCdWlsZFByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgZGV2QnVpbGRQcm9taXNlUmVzb2x2ZSA9IHJlc29sdmVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQoXG4gICAgICAgICAgZ2V0RmlsZXNGb3JSb3V0ZShhc3NldFByZWZpeCwgcm91dGUpXG4gICAgICAgICAgICAudGhlbigoeyBzY3JpcHRzLCBjc3MgfSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIGVudHJ5cG9pbnRzLmhhcyhyb3V0ZSlcbiAgICAgICAgICAgICAgICAgID8gW11cbiAgICAgICAgICAgICAgICAgIDogUHJvbWlzZS5hbGwoc2NyaXB0cy5tYXAobWF5YmVFeGVjdXRlU2NyaXB0KSksXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoY3NzLm1hcChmZXRjaFN0eWxlU2hlZXQpKSxcbiAgICAgICAgICAgICAgXSBhcyBjb25zdClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZW5FbnRyeXBvaW50KHJvdXRlKS50aGVuKChlbnRyeXBvaW50KSA9PiAoe1xuICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiByZXNbMV0sXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgTVNfTUFYX0lETEVfREVMQVksXG4gICAgICAgICAgbWFya0Fzc2V0RXJyb3IobmV3IEVycm9yKGBSb3V0ZSBkaWQgbm90IGNvbXBsZXRlIGxvYWRpbmc6ICR7cm91dGV9YCkpXG4gICAgICAgIClcbiAgICAgICAgICAudGhlbigoeyBlbnRyeXBvaW50LCBzdHlsZXMgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzOiBSb3V0ZUxvYWRlckVudHJ5ID0gT2JqZWN0LmFzc2lnbjxcbiAgICAgICAgICAgICAgeyBzdHlsZXM6IFJvdXRlU3R5bGVTaGVldFtdIH0sXG4gICAgICAgICAgICAgIFJvdXRlRW50cnlwb2ludFxuICAgICAgICAgICAgPih7IHN0eWxlczogc3R5bGVzISB9LCBlbnRyeXBvaW50KVxuICAgICAgICAgICAgcmV0dXJuICdlcnJvcicgaW4gZW50cnlwb2ludCA/IGVudHJ5cG9pbnQgOiByZXNcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJlZmV0Y2gpIHtcbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjYWNoZSBlcnJvcnMgZHVyaW5nIHByZWZldGNoXG4gICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGVyciB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuZmluYWxseSgoKSA9PiBkZXZCdWlsZFByb21pc2VSZXNvbHZlPy4oKSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBwcmVmZXRjaChyb3V0ZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lTGFicy9xdWlja2xpbmsvYmxvYi80NTNhNjYxZmExZmE5NDBlMmQyZTA0NDQ1MjM5OGUzOGM2N2E5OGZiL3NyYy9pbmRleC5tanMjTDExNS1MMTE4XG4gICAgICAvLyBMaWNlbnNlOiBBcGFjaGUgMi4wXG4gICAgICBsZXQgY25cbiAgICAgIGlmICgoY24gPSAobmF2aWdhdG9yIGFzIGFueSkuY29ubmVjdGlvbikpIHtcbiAgICAgICAgLy8gRG9uJ3QgcHJlZmV0Y2ggaWYgdXNpbmcgMkcgb3IgaWYgU2F2ZS1EYXRhIGlzIGVuYWJsZWQuXG4gICAgICAgIGlmIChjbi5zYXZlRGF0YSB8fCAvMmcvLnRlc3QoY24uZWZmZWN0aXZlVHlwZSkpIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZpbGVzRm9yUm91dGUoYXNzZXRQcmVmaXgsIHJvdXRlKVxuICAgICAgICAudGhlbigob3V0cHV0KSA9PlxuICAgICAgICAgIFByb21pc2UuYWxsKFxuICAgICAgICAgICAgY2FuUHJlZmV0Y2hcbiAgICAgICAgICAgICAgPyBvdXRwdXQuc2NyaXB0cy5tYXAoKHNjcmlwdCkgPT5cbiAgICAgICAgICAgICAgICAgIHByZWZldGNoVmlhRG9tKHNjcmlwdC50b1N0cmluZygpLCAnc2NyaXB0JylcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIDogW11cbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIHJlcXVlc3RJZGxlQ2FsbGJhY2soKCkgPT4gdGhpcy5sb2FkUm91dGUocm91dGUsIHRydWUpLmNhdGNoKCgpID0+IHt9KSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKFxuICAgICAgICAgIC8vIHN3YWxsb3cgcHJlZmV0Y2ggZXJyb3JzXG4gICAgICAgICAgKCkgPT4ge31cbiAgICAgICAgKVxuICAgIH0sXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVSb3V0ZUxvYWRlciIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJpc0Fzc2V0RXJyb3IiLCJtYXJrQXNzZXRFcnJvciIsIk1TX01BWF9JRExFX0RFTEFZIiwid2l0aEZ1dHVyZSIsImtleSIsIm1hcCIsImdlbmVyYXRvciIsImVudHJ5IiwiZ2V0IiwiZnV0dXJlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZXNvbHZlciIsInByb20iLCJzZXQiLCJ0aGVuIiwidmFsdWUiLCJjYXRjaCIsImVyciIsImRlbGV0ZSIsIkFTU0VUX0xPQURfRVJST1IiLCJTeW1ib2wiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImhhc1ByZWZldGNoIiwibGluayIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsIndpbmRvdyIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwicmVsTGlzdCIsInN1cHBvcnRzIiwiY2FuUHJlZmV0Y2giLCJnZXRBc3NldFF1ZXJ5U3RyaW5nIiwiZ2V0RGVwbG95bWVudElkUXVlcnlPckVtcHR5U3RyaW5nIiwicHJlZmV0Y2hWaWFEb20iLCJocmVmIiwiYXMiLCJyZWplY3QiLCJzZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3IiLCJyZWwiLCJjcm9zc09yaWdpbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfQ1JPU1NfT1JJR0lOIiwib25sb2FkIiwib25lcnJvciIsIkVycm9yIiwiaGVhZCIsImFwcGVuZENoaWxkIiwiYXBwZW5kU2NyaXB0Iiwic3JjIiwic2NyaXB0IiwiYm9keSIsImRldkJ1aWxkUHJvbWlzZSIsInJlc29sdmVQcm9taXNlV2l0aFRpbWVvdXQiLCJwIiwibXMiLCJjYW5jZWxsZWQiLCJyIiwiTk9ERV9FTlYiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwic2V0VGltZW91dCIsInNlbGYiLCJfX0JVSUxEX01BTklGRVNUIiwib25CdWlsZE1hbmlmZXN0IiwiY2IiLCJfX0JVSUxEX01BTklGRVNUX0NCIiwiZ2V0RmlsZXNGb3JSb3V0ZSIsImFzc2V0UHJlZml4Iiwicm91dGUiLCJzY3JpcHRVcmwiLCJlbmNvZGVVUklQYXRoIiwiZ2V0QXNzZXRQYXRoRnJvbVJvdXRlIiwic2NyaXB0cyIsIl9fdW5zYWZlQ3JlYXRlVHJ1c3RlZFNjcmlwdFVSTCIsImNzcyIsIm1hbmlmZXN0IiwiYWxsRmlsZXMiLCJmaWx0ZXIiLCJ2IiwiZW5kc1dpdGgiLCJlbnRyeXBvaW50cyIsIk1hcCIsImxvYWRlZFNjcmlwdHMiLCJzdHlsZVNoZWV0cyIsInJvdXRlcyIsIm1heWJlRXhlY3V0ZVNjcmlwdCIsInRvU3RyaW5nIiwiZmV0Y2hTdHlsZVNoZWV0IiwiZmV0Y2giLCJjcmVkZW50aWFscyIsInJlcyIsIm9rIiwidGV4dCIsImNvbnRlbnQiLCJ3aGVuRW50cnlwb2ludCIsIm9uRW50cnlwb2ludCIsImV4ZWN1dGUiLCJleHBvcnRzIiwiY29tcG9uZW50IiwiZGVmYXVsdCIsImVycm9yIiwidW5kZWZpbmVkIiwiaW5wdXQiLCJvbGQiLCJsb2FkUm91dGUiLCJwcmVmZXRjaCIsImRldkJ1aWxkUHJvbWlzZVJlc29sdmUiLCJhbGwiLCJoYXMiLCJlbnRyeXBvaW50Iiwic3R5bGVzIiwiYXNzaWduIiwiZmluYWxseSIsImNuIiwibmF2aWdhdG9yIiwiY29ubmVjdGlvbiIsInNhdmVEYXRhIiwidGVzdCIsImVmZmVjdGl2ZVR5cGUiLCJvdXRwdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/route-loader.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js":
/*!********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    AppRouterContext: function() {\n        return AppRouterContext;\n    },\n    GlobalLayoutRouterContext: function() {\n        return GlobalLayoutRouterContext;\n    },\n    LayoutRouterContext: function() {\n        return LayoutRouterContext;\n    },\n    MissingSlotContext: function() {\n        return MissingSlotContext;\n    },\n    TemplateContext: function() {\n        return TemplateContext;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst AppRouterContext = _react.default.createContext(null);\nconst LayoutRouterContext = _react.default.createContext(null);\nconst GlobalLayoutRouterContext = _react.default.createContext(null);\nconst TemplateContext = _react.default.createContext(null);\nif (true) {\n    AppRouterContext.displayName = 'AppRouterContext';\n    LayoutRouterContext.displayName = 'LayoutRouterContext';\n    GlobalLayoutRouterContext.displayName = 'GlobalLayoutRouterContext';\n    TemplateContext.displayName = 'TemplateContext';\n}\nconst MissingSlotContext = _react.default.createContext(new Set()); //# sourceMappingURL=app-router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYXBwLXJvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztJQWdKYUEsZ0JBQWdCO2VBQWhCQTs7SUFVQUMseUJBQXlCO2VBQXpCQTs7SUFQQUMsbUJBQW1CO2VBQW5CQTs7SUF1QkFDLGtCQUFrQjtlQUFsQkE7O0lBVEFDLGVBQWU7ZUFBZkE7Ozs7NEVBeEpLO0FBdUlYLE1BQU1KLG1CQUFtQkssT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQ2pEO0FBRUssTUFBTUosc0JBQXNCRyxPQUFBQSxPQUFLLENBQUNDLGFBQWEsQ0FLNUM7QUFFSCxNQUFNTCw0QkFBNEJJLE9BQUFBLE9BQUssQ0FBQ0MsYUFBYSxDQUt6RDtBQUVJLE1BQU1GLGtCQUFrQkMsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQWtCO0FBRXBFLElBQUlDLElBQW9CLEVBQW1CO0lBQ3pDUCxpQkFBaUJVLFdBQVcsR0FBRztJQUMvQlIsb0JBQW9CUSxXQUFXLEdBQUc7SUFDbENULDBCQUEwQlMsV0FBVyxHQUFHO0lBQ3hDTixnQkFBZ0JNLFdBQVcsR0FBRztBQUNoQztBQUVPLE1BQU1QLHFCQUFxQkUsT0FBQUEsT0FBSyxDQUFDQyxhQUFhLENBQWMsSUFBSUsiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVvbmFcXHNyY1xcc2hhcmVkXFxsaWJcXGFwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IHR5cGUgeyBGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0IH0gZnJvbSAnLi4vLi4vY2xpZW50L2NvbXBvbmVudHMvcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlJ1xuaW1wb3J0IHR5cGUge1xuICBGb2N1c0FuZFNjcm9sbFJlZixcbiAgUHJlZmV0Y2hLaW5kLFxuICBSb3V0ZXJDaGFuZ2VCeVNlcnZlclJlc3BvbnNlLFxufSBmcm9tICcuLi8uLi9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcydcbmltcG9ydCB0eXBlIHsgRmxpZ2h0Um91dGVyU3RhdGUgfSBmcm9tICcuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci90eXBlcydcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IHR5cGUgQ2hpbGRTZWdtZW50TWFwID0gTWFwPHN0cmluZywgQ2FjaGVOb2RlPlxuXG4vKipcbiAqIENhY2hlIG5vZGUgdXNlZCBpbiBhcHAtcm91dGVyIC8gbGF5b3V0LXJvdXRlci5cbiAqL1xuZXhwb3J0IHR5cGUgQ2FjaGVOb2RlID0gUmVhZHlDYWNoZU5vZGUgfCBMYXp5Q2FjaGVOb2RlXG5cbmV4cG9ydCB0eXBlIExvYWRpbmdNb2R1bGVEYXRhID1cbiAgfCBbUmVhY3QuSlNYLkVsZW1lbnQsIFJlYWN0LlJlYWN0Tm9kZSwgUmVhY3QuUmVhY3ROb2RlXVxuICB8IG51bGxcblxuZXhwb3J0IHR5cGUgTGF6eUNhY2hlTm9kZSA9IHtcbiAgLyoqXG4gICAqIFdoZW4gcnNjIGlzIG51bGwsIHRoaXMgaXMgYSBsYXppbHktaW5pdGlhbGl6ZWQgY2FjaGUgbm9kZS5cbiAgICpcbiAgICogSWYgdGhlIGFwcCBhdHRlbXB0cyB0byByZW5kZXIgaXQsIGl0IHRyaWdnZXJzIGEgbGF6eSBkYXRhIGZldGNoLFxuICAgKiBwb3N0cG9uZXMgdGhlIHJlbmRlciwgYW5kIHNjaGVkdWxlcyBhbiB1cGRhdGUgdG8gYSBuZXcgdHJlZS5cbiAgICpcbiAgICogVE9ETzogVGhpcyBtZWNoYW5pc20gc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gUFBSIGlzIGVuYWJsZWQsIHRob3VnaCBpdFxuICAgKiBjdXJyZW50bHkgaXMgaW4gc29tZSBjYXNlcyB1bnRpbCB3ZSd2ZSBpbXBsZW1lbnRlZCBwYXJ0aWFsXG4gICAqIHNlZ21lbnQgZmV0Y2hpbmcuXG4gICAqL1xuICByc2M6IG51bGxcblxuICAvKipcbiAgICogQSBwcmVmZXRjaGVkIHZlcnNpb24gb2YgdGhlIHNlZ21lbnQgZGF0YS4gU2VlIGV4cGxhbmF0aW9uIGluIGNvcnJlc3BvbmRpbmdcbiAgICogZmllbGQgb2YgUmVhZHlDYWNoZU5vZGUgKGJlbG93KS5cbiAgICpcbiAgICogU2luY2UgTGF6eUNhY2hlTm9kZSBtb3N0bHkgb25seSBleGlzdHMgaW4gdGhlIG5vbi1QUFIgaW1wbGVtZW50YXRpb24sIHRoaXNcbiAgICogd2lsbCB1c3VhbGx5IGJlIG51bGwsIGJ1dCBpdCBjb3VsZCBoYXZlIGJlZW4gY2xvbmVkIGZyb20gYSBwcmV2aW91c1xuICAgKiBDYWNoZU5vZGUgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgUFBSIGltcGxlbWVudGF0aW9uLiBFdmVudHVhbGx5IHdlIHdhbnRcbiAgICogdG8gbWlncmF0ZSBldmVyeXRoaW5nIGF3YXkgZnJvbSBMYXp5Q2FjaGVOb2RlIGVudGlyZWx5LlxuICAgKi9cbiAgcHJlZmV0Y2hSc2M6IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIC8qKlxuICAgKiBBIHBlbmRpbmcgcmVzcG9uc2UgZm9yIHRoZSBsYXp5IGRhdGEgZmV0Y2guIElmIHRoaXMgaXMgbm90IHByZXNlbnRcbiAgICogZHVyaW5nIHJlbmRlciwgaXQgaXMgbGF6aWx5IGNyZWF0ZWQuXG4gICAqL1xuICBsYXp5RGF0YTogUHJvbWlzZTxGZXRjaFNlcnZlclJlc3BvbnNlUmVzdWx0PiB8IG51bGxcblxuICBwcmVmZXRjaEhlYWQ6IFJlYWN0LlJlYWN0Tm9kZVxuICBoZWFkOiBSZWFjdC5SZWFjdE5vZGVcblxuICBsb2FkaW5nOiBMb2FkaW5nTW9kdWxlRGF0YSB8IFByb21pc2U8TG9hZGluZ01vZHVsZURhdGE+XG5cbiAgLyoqXG4gICAqIENoaWxkIHBhcmFsbGVsIHJvdXRlcy5cbiAgICovXG4gIHBhcmFsbGVsUm91dGVzOiBNYXA8c3RyaW5nLCBDaGlsZFNlZ21lbnRNYXA+XG59XG5cbmV4cG9ydCB0eXBlIFJlYWR5Q2FjaGVOb2RlID0ge1xuICAvKipcbiAgICogV2hlbiByc2MgaXMgbm90IG51bGwsIGl0IHJlcHJlc2VudHMgdGhlIFJTQyBkYXRhIGZvciB0aGVcbiAgICogY29ycmVzcG9uZGluZyBzZWdtZW50LlxuICAgKlxuICAgKiBgbnVsbGAgaXMgYSB2YWxpZCBSZWFjdCBOb2RlIGJ1dCBiZWNhdXNlIHNlZ21lbnQgZGF0YSBpcyBhbHdheXMgYVxuICAgKiA8TGF5b3V0Um91dGVyPiBjb21wb25lbnQsIHdlIGNhbiB1c2UgYG51bGxgIHRvIHJlcHJlc2VudCBlbXB0eS5cbiAgICpcbiAgICogVE9ETzogRm9yIGFkZGl0aW9uYWwgdHlwZSBzYWZldHksIHVwZGF0ZSB0aGlzIHR5cGUgdG9cbiAgICogRXhjbHVkZTxSZWFjdC5SZWFjdE5vZGUsIG51bGw+LiBOZWVkIHRvIHVwZGF0ZSBjcmVhdGVFbXB0eUNhY2hlTm9kZSB0b1xuICAgKiBhY2NlcHQgcnNjIGFzIGFuIGFyZ3VtZW50LCBvciBqdXN0IGlubGluZSB0aGUgY2FsbGVycy5cbiAgICovXG4gIHJzYzogUmVhY3QuUmVhY3ROb2RlXG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSBzdGF0aWMgdmVyc2lvbiBvZiB0aGUgc2VnbWVudCB0aGF0IGNhbiBiZSBzaG93biBpbW1lZGlhdGVseSxcbiAgICogYW5kIG1heSBvciBtYXkgbm90IGNvbnRhaW4gZHluYW1pYyBob2xlcy4gSXQncyBwcmVmZXRjaGVkIGJlZm9yZSBhXG4gICAqIG5hdmlnYXRpb24gb2NjdXJzLlxuICAgKlxuICAgKiBEdXJpbmcgcmVuZGVyaW5nLCB3ZSB3aWxsIGNob29zZSB3aGV0aGVyIHRvIHJlbmRlciBgcnNjYCBvciBgcHJlZmV0Y2hSc2NgXG4gICAqIHdpdGggYHVzZURlZmVycmVkVmFsdWVgLiBBcyB3aXRoIHRoZSBgcnNjYCBmaWVsZCwgYSB2YWx1ZSBvZiBgbnVsbGAgbWVhbnNcbiAgICogbm8gdmFsdWUgd2FzIHByb3ZpZGVkLiBJbiB0aGlzIGNhc2UsIHRoZSBMYXlvdXRSb3V0ZXIgd2lsbCBnbyBzdHJhaWdodCB0b1xuICAgKiByZW5kZXJpbmcgdGhlIGByc2NgIHZhbHVlOyBpZiB0aGF0IG9uZSBpcyBhbHNvIG1pc3NpbmcsIGl0IHdpbGwgc3VzcGVuZCBhbmRcbiAgICogdHJpZ2dlciBhIGxhenkgZmV0Y2guXG4gICAqL1xuICBwcmVmZXRjaFJzYzogUmVhY3QuUmVhY3ROb2RlXG5cbiAgLyoqXG4gICAqIFRoZXJlIHNob3VsZCBuZXZlciBiZSBhIGxhenkgZGF0YSByZXF1ZXN0IGluIHRoaXMgY2FzZS5cbiAgICovXG4gIGxhenlEYXRhOiBudWxsXG4gIHByZWZldGNoSGVhZDogUmVhY3QuUmVhY3ROb2RlXG4gIGhlYWQ6IFJlYWN0LlJlYWN0Tm9kZVxuXG4gIGxvYWRpbmc6IExvYWRpbmdNb2R1bGVEYXRhIHwgUHJvbWlzZTxMb2FkaW5nTW9kdWxlRGF0YT5cblxuICBwYXJhbGxlbFJvdXRlczogTWFwPHN0cmluZywgQ2hpbGRTZWdtZW50TWFwPlxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hdmlnYXRlT3B0aW9ucyB7XG4gIHNjcm9sbD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQcmVmZXRjaE9wdGlvbnMge1xuICBraW5kOiBQcmVmZXRjaEtpbmRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBcHBSb3V0ZXJJbnN0YW5jZSB7XG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgcHJldmlvdXMgaGlzdG9yeSBlbnRyeS5cbiAgICovXG4gIGJhY2soKTogdm9pZFxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIG5leHQgaGlzdG9yeSBlbnRyeS5cbiAgICovXG4gIGZvcndhcmQoKTogdm9pZFxuICAvKipcbiAgICogUmVmcmVzaCB0aGUgY3VycmVudCBwYWdlLlxuICAgKi9cbiAgcmVmcmVzaCgpOiB2b2lkXG4gIC8qKlxuICAgKiBSZWZyZXNoIHRoZSBjdXJyZW50IHBhZ2UuIFVzZSBpbiBkZXZlbG9wbWVudCBvbmx5LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGhtclJlZnJlc2goKTogdm9pZFxuICAvKipcbiAgICogTmF2aWdhdGUgdG8gdGhlIHByb3ZpZGVkIGhyZWYuXG4gICAqIFB1c2hlcyBhIG5ldyBoaXN0b3J5IGVudHJ5LlxuICAgKi9cbiAgcHVzaChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkXG4gIC8qKlxuICAgKiBOYXZpZ2F0ZSB0byB0aGUgcHJvdmlkZWQgaHJlZi5cbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgaGlzdG9yeSBlbnRyeS5cbiAgICovXG4gIHJlcGxhY2UoaHJlZjogc3RyaW5nLCBvcHRpb25zPzogTmF2aWdhdGVPcHRpb25zKTogdm9pZFxuICAvKipcbiAgICogUHJlZmV0Y2ggdGhlIHByb3ZpZGVkIGhyZWYuXG4gICAqL1xuICBwcmVmZXRjaChocmVmOiBzdHJpbmcsIG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpOiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCBBcHBSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxBcHBSb3V0ZXJJbnN0YW5jZSB8IG51bGw+KFxuICBudWxsXG4pXG5leHBvcnQgY29uc3QgTGF5b3V0Um91dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8e1xuICBjaGlsZE5vZGVzOiBDYWNoZU5vZGVbJ3BhcmFsbGVsUm91dGVzJ11cbiAgdHJlZTogRmxpZ2h0Um91dGVyU3RhdGVcbiAgdXJsOiBzdHJpbmdcbiAgbG9hZGluZzogTG9hZGluZ01vZHVsZURhdGEgfCBQcm9taXNlPExvYWRpbmdNb2R1bGVEYXRhPlxufSB8IG51bGw+KG51bGwpXG5cbmV4cG9ydCBjb25zdCBHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDx7XG4gIHRyZWU6IEZsaWdodFJvdXRlclN0YXRlXG4gIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2U6IFJvdXRlckNoYW5nZUJ5U2VydmVyUmVzcG9uc2VcbiAgZm9jdXNBbmRTY3JvbGxSZWY6IEZvY3VzQW5kU2Nyb2xsUmVmXG4gIG5leHRVcmw6IHN0cmluZyB8IG51bGxcbn0+KG51bGwgYXMgYW55KVxuXG5leHBvcnQgY29uc3QgVGVtcGxhdGVDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxSZWFjdC5SZWFjdE5vZGU+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBBcHBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FwcFJvdXRlckNvbnRleHQnXG4gIExheW91dFJvdXRlckNvbnRleHQuZGlzcGxheU5hbWUgPSAnTGF5b3V0Um91dGVyQ29udGV4dCdcbiAgR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0J1xuICBUZW1wbGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnVGVtcGxhdGVDb250ZXh0J1xufVxuXG5leHBvcnQgY29uc3QgTWlzc2luZ1Nsb3RDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxTZXQ8c3RyaW5nPj4obmV3IFNldCgpKVxuIl0sIm5hbWVzIjpbIkFwcFJvdXRlckNvbnRleHQiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwiTGF5b3V0Um91dGVyQ29udGV4dCIsIk1pc3NpbmdTbG90Q29udGV4dCIsIlRlbXBsYXRlQ29udGV4dCIsIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImRpc3BsYXlOYW1lIiwiU2V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/router/utils/format-url.js":
/*!**********************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/utils/format-url.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    formatUrl: function() {\n        return formatUrl;\n    },\n    formatWithValidation: function() {\n        return formatWithValidation;\n    },\n    urlObjectKeys: function() {\n        return urlObjectKeys;\n    }\n});\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _querystring = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ./querystring */ \"./node_modules/next/dist/shared/lib/router/utils/querystring.js\"));\nconst slashedProtocols = /https?|ftp|gopher|file/;\nfunction formatUrl(urlObj) {\n    let { auth, hostname } = urlObj;\n    let protocol = urlObj.protocol || '';\n    let pathname = urlObj.pathname || '';\n    let hash = urlObj.hash || '';\n    let query = urlObj.query || '';\n    let host = false;\n    auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n    if (urlObj.host) {\n        host = auth + urlObj.host;\n    } else if (hostname) {\n        host = auth + (~hostname.indexOf(':') ? \"[\" + hostname + \"]\" : hostname);\n        if (urlObj.port) {\n            host += ':' + urlObj.port;\n        }\n    }\n    if (query && typeof query === 'object') {\n        query = String(_querystring.urlQueryToSearchParams(query));\n    }\n    let search = urlObj.search || query && \"?\" + query || '';\n    if (protocol && !protocol.endsWith(':')) protocol += ':';\n    if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {\n        host = '//' + (host || '');\n        if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n    } else if (!host) {\n        host = '';\n    }\n    if (hash && hash[0] !== '#') hash = '#' + hash;\n    if (search && search[0] !== '?') search = '?' + search;\n    pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n    search = search.replace('#', '%23');\n    return \"\" + protocol + host + pathname + search + hash;\n}\nconst urlObjectKeys = [\n    'auth',\n    'hash',\n    'host',\n    'hostname',\n    'href',\n    'path',\n    'pathname',\n    'port',\n    'protocol',\n    'query',\n    'search',\n    'slashes'\n];\nfunction formatWithValidation(url) {\n    if (true) {\n        if (url !== null && typeof url === 'object') {\n            Object.keys(url).forEach((key)=>{\n                if (!urlObjectKeys.includes(key)) {\n                    console.warn(\"Unknown key passed via urlObject into url.format: \" + key);\n                }\n            });\n        }\n    }\n    return formatUrl(url);\n} //# sourceMappingURL=format-url.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3V0aWxzL2Zvcm1hdC11cmwuanMiLCJtYXBwaW5ncyI6IkFBQUEsdUNBQXVDO0FBQ3ZDLHNEQUFzRDtBQUN0RCxFQUFFO0FBQ0YsMEVBQTBFO0FBQzFFLGdFQUFnRTtBQUNoRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLDRFQUE0RTtBQUM1RSxxRUFBcUU7QUFDckUsd0JBQXdCO0FBQ3hCLEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUseURBQXlEO0FBQ3pELEVBQUU7QUFDRiwwRUFBMEU7QUFDMUUsNkRBQTZEO0FBQzdELDRFQUE0RTtBQUM1RSwyRUFBMkU7QUFDM0Usd0VBQXdFO0FBQ3hFLDRFQUE0RTtBQUM1RSx5Q0FBeUM7Ozs7Ozs7Ozs7Ozs7SUFRekJBLFNBQVM7ZUFBVEE7O0lBNkRBQyxvQkFBb0I7ZUFBcEJBOztJQWZIQyxhQUFhO2VBQWJBOzs7O21GQWxEZ0I7QUFFN0IsTUFBTUMsbUJBQW1CO0FBRWxCLFNBQVNILFVBQVVJLE1BQWlCO0lBQ3pDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0Y7SUFDekIsSUFBSUcsV0FBV0gsT0FBT0csUUFBUSxJQUFJO0lBQ2xDLElBQUlDLFdBQVdKLE9BQU9JLFFBQVEsSUFBSTtJQUNsQyxJQUFJQyxPQUFPTCxPQUFPSyxJQUFJLElBQUk7SUFDMUIsSUFBSUMsUUFBUU4sT0FBT00sS0FBSyxJQUFJO0lBQzVCLElBQUlDLE9BQXVCO0lBRTNCTixPQUFPQSxPQUFPTyxtQkFBbUJQLE1BQU1RLE9BQU8sQ0FBQyxRQUFRLE9BQU8sTUFBTTtJQUVwRSxJQUFJVCxPQUFPTyxJQUFJLEVBQUU7UUFDZkEsT0FBT04sT0FBT0QsT0FBT08sSUFBSTtJQUMzQixPQUFPLElBQUlMLFVBQVU7UUFDbkJLLE9BQU9OLE9BQVEsRUFBQ0MsU0FBU1EsT0FBTyxDQUFDLE9BQVEsTUFBR1IsV0FBUyxNQUFLQSxRQUFBQSxDQUFPO1FBQ2pFLElBQUlGLE9BQU9XLElBQUksRUFBRTtZQUNmSixRQUFRLE1BQU1QLE9BQU9XLElBQUk7UUFDM0I7SUFDRjtJQUVBLElBQUlMLFNBQVMsT0FBT0EsVUFBVSxVQUFVO1FBQ3RDQSxRQUFRTSxPQUFPQyxhQUFZQyxzQkFBc0IsQ0FBQ1I7SUFDcEQ7SUFFQSxJQUFJUyxTQUFTZixPQUFPZSxNQUFNLElBQUtULFNBQVUsTUFBR0EsU0FBWTtJQUV4RCxJQUFJSCxZQUFZLENBQUNBLFNBQVNhLFFBQVEsQ0FBQyxNQUFNYixZQUFZO0lBRXJELElBQ0VILE9BQU9pQixPQUFPLElBQ1osRUFBQ2QsWUFBWUosaUJBQWlCbUIsSUFBSSxDQUFDZixTQUFBQSxDQUFRLElBQU1JLFNBQVMsT0FDNUQ7UUFDQUEsT0FBTyxPQUFRQSxDQUFBQSxRQUFRLEdBQUM7UUFDeEIsSUFBSUgsWUFBWUEsUUFBUSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxXQUFXLE1BQU1BO0lBQ3hELE9BQU8sSUFBSSxDQUFDRyxNQUFNO1FBQ2hCQSxPQUFPO0lBQ1Q7SUFFQSxJQUFJRixRQUFRQSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUtBLE9BQU8sTUFBTUE7SUFDMUMsSUFBSVUsVUFBVUEsTUFBTSxDQUFDLEVBQUUsS0FBSyxLQUFLQSxTQUFTLE1BQU1BO0lBRWhEWCxXQUFXQSxTQUFTSyxPQUFPLENBQUMsU0FBU0Q7SUFDckNPLFNBQVNBLE9BQU9OLE9BQU8sQ0FBQyxLQUFLO0lBRTdCLE9BQVEsS0FBRU4sV0FBV0ksT0FBT0gsV0FBV1csU0FBU1Y7QUFDbEQ7QUFFTyxNQUFNUCxnQkFBZ0I7SUFDM0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxTQUFTRCxxQkFBcUJzQixHQUFjO0lBQ2pELElBQUlDLElBQW9CLEVBQW9CO1FBQzFDLElBQUlELFFBQVEsUUFBUSxPQUFPQSxRQUFRLFVBQVU7WUFDM0NJLE9BQU9DLElBQUksQ0FBQ0wsS0FBS00sT0FBTyxDQUFDLENBQUNDO2dCQUN4QixJQUFJLENBQUM1QixjQUFjNkIsUUFBUSxDQUFDRCxNQUFNO29CQUNoQ0UsUUFBUUMsSUFBSSxDQUNULHVEQUFvREg7Z0JBRXpEO1lBQ0Y7UUFDRjtJQUNGO0lBRUEsT0FBTzlCLFVBQVV1QjtBQUNuQiIsInNvdXJjZXMiOlsiQzpcXHNyY1xcc2hhcmVkXFxsaWJcXHJvdXRlclxcdXRpbHNcXGZvcm1hdC11cmwudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRm9ybWF0IGZ1bmN0aW9uIG1vZGlmaWVkIGZyb20gbm9kZWpzXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHR5cGUgeyBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgdHlwZSB7IFBhcnNlZFVybFF1ZXJ5IH0gZnJvbSAncXVlcnlzdHJpbmcnXG5pbXBvcnQgKiBhcyBxdWVyeXN0cmluZyBmcm9tICcuL3F1ZXJ5c3RyaW5nJ1xuXG5jb25zdCBzbGFzaGVkUHJvdG9jb2xzID0gL2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRVcmwodXJsT2JqOiBVcmxPYmplY3QpIHtcbiAgbGV0IHsgYXV0aCwgaG9zdG5hbWUgfSA9IHVybE9ialxuICBsZXQgcHJvdG9jb2wgPSB1cmxPYmoucHJvdG9jb2wgfHwgJydcbiAgbGV0IHBhdGhuYW1lID0gdXJsT2JqLnBhdGhuYW1lIHx8ICcnXG4gIGxldCBoYXNoID0gdXJsT2JqLmhhc2ggfHwgJydcbiAgbGV0IHF1ZXJ5ID0gdXJsT2JqLnF1ZXJ5IHx8ICcnXG4gIGxldCBob3N0OiBzdHJpbmcgfCBmYWxzZSA9IGZhbHNlXG5cbiAgYXV0aCA9IGF1dGggPyBlbmNvZGVVUklDb21wb25lbnQoYXV0aCkucmVwbGFjZSgvJTNBL2ksICc6JykgKyAnQCcgOiAnJ1xuXG4gIGlmICh1cmxPYmouaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdXJsT2JqLmhvc3RcbiAgfSBlbHNlIGlmIChob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKH5ob3N0bmFtZS5pbmRleE9mKCc6JykgPyBgWyR7aG9zdG5hbWV9XWAgOiBob3N0bmFtZSlcbiAgICBpZiAodXJsT2JqLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdXJsT2JqLnBvcnRcbiAgICB9XG4gIH1cblxuICBpZiAocXVlcnkgJiYgdHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0Jykge1xuICAgIHF1ZXJ5ID0gU3RyaW5nKHF1ZXJ5c3RyaW5nLnVybFF1ZXJ5VG9TZWFyY2hQYXJhbXMocXVlcnkgYXMgUGFyc2VkVXJsUXVlcnkpKVxuICB9XG5cbiAgbGV0IHNlYXJjaCA9IHVybE9iai5zZWFyY2ggfHwgKHF1ZXJ5ICYmIGA/JHtxdWVyeX1gKSB8fCAnJ1xuXG4gIGlmIChwcm90b2NvbCAmJiAhcHJvdG9jb2wuZW5kc1dpdGgoJzonKSkgcHJvdG9jb2wgKz0gJzonXG5cbiAgaWYgKFxuICAgIHVybE9iai5zbGFzaGVzIHx8XG4gICAgKCghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29scy50ZXN0KHByb3RvY29sKSkgJiYgaG9zdCAhPT0gZmFsc2UpXG4gICkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpXG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lWzBdICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWVcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJ1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaFswXSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaFxuICBpZiAoc2VhcmNoICYmIHNlYXJjaFswXSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2hcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZW5jb2RlVVJJQ29tcG9uZW50KVxuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKVxuXG4gIHJldHVybiBgJHtwcm90b2NvbH0ke2hvc3R9JHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9YFxufVxuXG5leHBvcnQgY29uc3QgdXJsT2JqZWN0S2V5cyA9IFtcbiAgJ2F1dGgnLFxuICAnaGFzaCcsXG4gICdob3N0JyxcbiAgJ2hvc3RuYW1lJyxcbiAgJ2hyZWYnLFxuICAncGF0aCcsXG4gICdwYXRobmFtZScsXG4gICdwb3J0JyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3F1ZXJ5JyxcbiAgJ3NlYXJjaCcsXG4gICdzbGFzaGVzJyxcbl1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHVybDogVXJsT2JqZWN0KTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKCF1cmxPYmplY3RLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBgVW5rbm93biBrZXkgcGFzc2VkIHZpYSB1cmxPYmplY3QgaW50byB1cmwuZm9ybWF0OiAke2tleX1gXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmb3JtYXRVcmwodXJsKVxufVxuIl0sIm5hbWVzIjpbImZvcm1hdFVybCIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwidXJsT2JqZWN0S2V5cyIsInNsYXNoZWRQcm90b2NvbHMiLCJ1cmxPYmoiLCJhdXRoIiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInBhdGhuYW1lIiwiaGFzaCIsInF1ZXJ5IiwiaG9zdCIsImVuY29kZVVSSUNvbXBvbmVudCIsInJlcGxhY2UiLCJpbmRleE9mIiwicG9ydCIsIlN0cmluZyIsInF1ZXJ5c3RyaW5nIiwidXJsUXVlcnlUb1NlYXJjaFBhcmFtcyIsInNlYXJjaCIsImVuZHNXaXRoIiwic2xhc2hlcyIsInRlc3QiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/utils/format-url.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/shared/lib/utils.js":
/*!****************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/utils.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    DecodeError: function() {\n        return DecodeError;\n    },\n    MiddlewareNotFoundError: function() {\n        return MiddlewareNotFoundError;\n    },\n    MissingStaticPage: function() {\n        return MissingStaticPage;\n    },\n    NormalizeError: function() {\n        return NormalizeError;\n    },\n    PageNotFoundError: function() {\n        return PageNotFoundError;\n    },\n    SP: function() {\n        return SP;\n    },\n    ST: function() {\n        return ST;\n    },\n    WEB_VITALS: function() {\n        return WEB_VITALS;\n    },\n    execOnce: function() {\n        return execOnce;\n    },\n    getDisplayName: function() {\n        return getDisplayName;\n    },\n    getLocationOrigin: function() {\n        return getLocationOrigin;\n    },\n    getURL: function() {\n        return getURL;\n    },\n    isAbsoluteUrl: function() {\n        return isAbsoluteUrl;\n    },\n    isResSent: function() {\n        return isResSent;\n    },\n    loadGetInitialProps: function() {\n        return loadGetInitialProps;\n    },\n    normalizeRepeatedSlashes: function() {\n        return normalizeRepeatedSlashes;\n    },\n    stringifyError: function() {\n        return stringifyError;\n    }\n});\nconst WEB_VITALS = [\n    'CLS',\n    'FCP',\n    'FID',\n    'INP',\n    'LCP',\n    'TTFB'\n];\nfunction execOnce(fn) {\n    let used = false;\n    let result;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (!used) {\n            used = true;\n            result = fn(...args);\n        }\n        return result;\n    };\n}\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nconst isAbsoluteUrl = (url)=>ABSOLUTE_URL_REGEX.test(url);\nfunction getLocationOrigin() {\n    const { protocol, hostname, port } = window.location;\n    return protocol + \"//\" + hostname + (port ? ':' + port : '');\n}\nfunction getURL() {\n    const { href } = window.location;\n    const origin = getLocationOrigin();\n    return href.substring(origin.length);\n}\nfunction getDisplayName(Component) {\n    return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';\n}\nfunction isResSent(res) {\n    return res.finished || res.headersSent;\n}\nfunction normalizeRepeatedSlashes(url) {\n    const urlParts = url.split('?');\n    const urlNoQuery = urlParts[0];\n    return urlNoQuery // first we replace any non-encoded backslashes with forward\n    // then normalize repeated forward slashes\n    .replace(/\\\\/g, '/').replace(/\\/\\/+/g, '/') + (urlParts[1] ? \"?\" + urlParts.slice(1).join('?') : '');\n}\nasync function loadGetInitialProps(App, ctx) {\n    if (true) {\n        var _App_prototype;\n        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {\n            const message = '\"' + getDisplayName(App) + '.getInitialProps()\" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';\n            throw new Error(message);\n        }\n    }\n    // when called from _app `ctx` is nested in `ctx`\n    const res = ctx.res || ctx.ctx && ctx.ctx.res;\n    if (!App.getInitialProps) {\n        if (ctx.ctx && ctx.Component) {\n            // @ts-ignore pageProps default\n            return {\n                pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)\n            };\n        }\n        return {};\n    }\n    const props = await App.getInitialProps(ctx);\n    if (res && isResSent(res)) {\n        return props;\n    }\n    if (!props) {\n        const message = '\"' + getDisplayName(App) + '.getInitialProps()\" should resolve to an object. But found \"' + props + '\" instead.';\n        throw new Error(message);\n    }\n    if (true) {\n        if (Object.keys(props).length === 0 && !ctx.ctx) {\n            console.warn(\"\" + getDisplayName(App) + \" returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps\");\n        }\n    }\n    return props;\n}\nconst SP = typeof performance !== 'undefined';\nconst ST = SP && [\n    'mark',\n    'measure',\n    'getEntriesByName'\n].every((method)=>typeof performance[method] === 'function');\nclass DecodeError extends Error {\n}\nclass NormalizeError extends Error {\n}\nclass PageNotFoundError extends Error {\n    constructor(page){\n        super();\n        this.code = 'ENOENT';\n        this.name = 'PageNotFoundError';\n        this.message = \"Cannot find module for page: \" + page;\n    }\n}\nclass MissingStaticPage extends Error {\n    constructor(page, message){\n        super();\n        this.message = \"Failed to load static file for page: \" + page + \" \" + message;\n    }\n}\nclass MiddlewareNotFoundError extends Error {\n    constructor(){\n        super();\n        this.code = 'ENOENT';\n        this.message = \"Cannot find the middleware module\";\n    }\n}\nfunction stringifyError(error) {\n    return JSON.stringify({\n        message: error.message,\n        stack: error.stack\n    });\n} //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0lBb2FhQSxXQUFXO2VBQVhBOztJQW9CQUMsdUJBQXVCO2VBQXZCQTs7SUFQQUMsaUJBQWlCO2VBQWpCQTs7SUFaQUMsY0FBYztlQUFkQTs7SUFDQUMsaUJBQWlCO2VBQWpCQTs7SUFUQUMsRUFBRTtlQUFGQTs7SUFDQUMsRUFBRTtlQUFGQTs7SUFsWEFDLFVBQVU7ZUFBVkE7O0lBc1FHQyxRQUFRO2VBQVJBOztJQStCQUMsY0FBYztlQUFkQTs7SUFYQUMsaUJBQWlCO2VBQWpCQTs7SUFLQUMsTUFBTTtlQUFOQTs7SUFQSEMsYUFBYTtlQUFiQTs7SUFtQkdDLFNBQVM7ZUFBVEE7O0lBa0JNQyxtQkFBbUI7ZUFBbkJBOztJQWROQyx3QkFBd0I7ZUFBeEJBOztJQStHQUMsY0FBYztlQUFkQTs7O0FBOVpULE1BQU1ULGFBQWE7SUFBQztJQUFPO0lBQU87SUFBTztJQUFPO0lBQU87Q0FBTztBQXNROUQsU0FBU0MsU0FDZFMsRUFBSztJQUVMLElBQUlDLE9BQU87SUFDWCxJQUFJQztJQUVKLE9BQVE7eUNBQUlDLE9BQUFBLElBQUFBLE1BQUFBLE9BQUFBLE9BQUFBLEdBQUFBLE9BQUFBLE1BQUFBLE9BQUFBO1lBQUFBLElBQUFBLENBQUFBLEtBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEtBQUFBOztRQUNWLElBQUksQ0FBQ0YsTUFBTTtZQUNUQSxPQUFPO1lBQ1BDLFNBQVNGLE1BQU1HO1FBQ2pCO1FBQ0EsT0FBT0Q7SUFDVDtBQUNGO0FBRUEsMERBQTBEO0FBQzFELGdFQUFnRTtBQUNoRSxNQUFNRSxxQkFBcUI7QUFDcEIsTUFBTVQsZ0JBQWdCLENBQUNVLE1BQWdCRCxtQkFBbUJFLElBQUksQ0FBQ0Q7QUFFL0QsU0FBU1o7SUFDZCxNQUFNLEVBQUVjLFFBQVEsRUFBRUMsUUFBUSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsT0FBT0MsUUFBUTtJQUNw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QUFZQyxJQUFZLEVBQUVaLE9BQWUsQ0FBRTtRQUN6QyxLQUFLO1FBQ0wsSUFBSSxDQUFDQSxPQUFPLEdBQUksMENBQXVDWSxPQUFLLE1BQUdaO0lBQ2pFO0FBQ0Y7QUFFTyxNQUFNbkQsZ0NBQWdDb0Q7SUFFM0NVLGFBQWM7UUFDWixLQUFLO1FBQ0wsSUFBSSxDQUFDRSxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNiLE9BQU8sR0FBSTtJQUNsQjtBQUNGO0FBV08sU0FBU3BDLGVBQWVrRCxLQUFZO0lBQ3pDLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQztRQUFFaEIsU0FBU2MsTUFBTWQsT0FBTztRQUFFaUIsT0FBT0gsTUFBTUcsS0FBSztJQUFDO0FBQ3JFIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGxlb25hXFxzcmNcXHNoYXJlZFxcbGliXFx1dGlscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEh0bWxQcm9wcyB9IGZyb20gJy4vaHRtbC1jb250ZXh0LnNoYXJlZC1ydW50aW1lJ1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRUeXBlLCBKU1ggfSBmcm9tICdyZWFjdCdcbmltcG9ydCB0eXBlIHsgRG9tYWluTG9jYWxlIH0gZnJvbSAnLi4vLi4vc2VydmVyL2NvbmZpZydcbmltcG9ydCB0eXBlIHsgRW52IH0gZnJvbSAnQG5leHQvZW52J1xuaW1wb3J0IHR5cGUgeyBJbmNvbWluZ01lc3NhZ2UsIFNlcnZlclJlc3BvbnNlIH0gZnJvbSAnaHR0cCdcbmltcG9ydCB0eXBlIHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB0eXBlIHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB0eXBlIHsgUHJldmlld0RhdGEgfSBmcm9tICcuLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgQ09NUElMRVJfTkFNRVMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB0eXBlIGZzIGZyb20gJ2ZzJ1xuXG5leHBvcnQgdHlwZSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQ29udGV4dCBleHRlbmRzIEJhc2VDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0LFxuICBJbml0aWFsUHJvcHMgPSB7fSxcbiAgUHJvcHMgPSB7fSxcbj4gPSBDb21wb25lbnRUeXBlPFByb3BzPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGNvbnRleHQgQ29udGV4dCBvZiBgcGFnZWBcbiAgICovXG4gIGdldEluaXRpYWxQcm9wcz8oY29udGV4dDogQ29udGV4dCk6IEluaXRpYWxQcm9wcyB8IFByb21pc2U8SW5pdGlhbFByb3BzPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPlxuXG5leHBvcnQgdHlwZSBBcHBUeXBlPFAgPSB7fT4gPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgQXBwQ29udGV4dFR5cGUsXG4gIFAsXG4gIEFwcFByb3BzVHlwZTxhbnksIFA+XG4+XG5cbmV4cG9ydCB0eXBlIEFwcFRyZWVUeXBlID0gQ29tcG9uZW50VHlwZTxcbiAgQXBwSW5pdGlhbFByb3BzICYgeyBbbmFtZTogc3RyaW5nXTogYW55IH1cbj5cblxuLyoqXG4gKiBXZWIgdml0YWxzIHByb3ZpZGVkIHRvIF9hcHAucmVwb3J0V2ViVml0YWxzIGJ5IENvcmUgV2ViIFZpdGFscyBwbHVnaW4gZGV2ZWxvcGVkIGJ5IEdvb2dsZSBDaHJvbWUgdGVhbS5cbiAqIGh0dHBzOi8vbmV4dGpzLm9yZy9ibG9nL25leHQtOS00I2ludGVncmF0ZWQtd2ViLXZpdGFscy1yZXBvcnRpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFdFQl9WSVRBTFMgPSBbJ0NMUycsICdGQ1AnLCAnRklEJywgJ0lOUCcsICdMQ1AnLCAnVFRGQiddIGFzIGNvbnN0XG5leHBvcnQgdHlwZSBOZXh0V2ViVml0YWxzTWV0cmljID0ge1xuICBpZDogc3RyaW5nXG4gIHN0YXJ0VGltZTogbnVtYmVyXG4gIHZhbHVlOiBudW1iZXJcbiAgYXR0cmlidXRpb24/OiB7IFtrZXk6IHN0cmluZ106IHVua25vd24gfVxufSAmIChcbiAgfCB7XG4gICAgICBsYWJlbDogJ3dlYi12aXRhbCdcbiAgICAgIG5hbWU6ICh0eXBlb2YgV0VCX1ZJVEFMUylbbnVtYmVyXVxuICAgIH1cbiAgfCB7XG4gICAgICBsYWJlbDogJ2N1c3RvbSdcbiAgICAgIG5hbWU6XG4gICAgICAgIHwgJ05leHQuanMtaHlkcmF0aW9uJ1xuICAgICAgICB8ICdOZXh0LmpzLXJvdXRlLWNoYW5nZS10by1yZW5kZXInXG4gICAgICAgIHwgJ05leHQuanMtcmVuZGVyJ1xuICAgIH1cbilcblxuZXhwb3J0IHR5cGUgRW5oYW5jZXI8Qz4gPSAoQ29tcG9uZW50OiBDKSA9PiBDXG5cbmV4cG9ydCB0eXBlIENvbXBvbmVudHNFbmhhbmNlciA9XG4gIHwge1xuICAgICAgZW5oYW5jZUFwcD86IEVuaGFuY2VyPEFwcFR5cGU+XG4gICAgICBlbmhhbmNlQ29tcG9uZW50PzogRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG4gICAgfVxuICB8IEVuaGFuY2VyPE5leHRDb21wb25lbnRUeXBlPlxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlUmVzdWx0ID0ge1xuICBodG1sOiBzdHJpbmdcbiAgaGVhZD86IEFycmF5PEpTWC5FbGVtZW50IHwgbnVsbD5cbn1cblxuZXhwb3J0IHR5cGUgUmVuZGVyUGFnZSA9IChcbiAgb3B0aW9ucz86IENvbXBvbmVudHNFbmhhbmNlclxuKSA9PiBEb2N1bWVudEluaXRpYWxQcm9wcyB8IFByb21pc2U8RG9jdW1lbnRJbml0aWFsUHJvcHM+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcGFnZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBidWlsZElkOiBzdHJpbmdcbiAgYXNzZXRQcmVmaXg/OiBzdHJpbmdcbiAgcnVudGltZUNvbmZpZz86IHsgW2tleTogc3RyaW5nXTogYW55IH1cbiAgbmV4dEV4cG9ydD86IGJvb2xlYW5cbiAgYXV0b0V4cG9ydD86IGJvb2xlYW5cbiAgaXNGYWxsYmFjaz86IGJvb2xlYW5cbiAgaXNFeHBlcmltZW50YWxDb21waWxlPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogKHN0cmluZyB8IG51bWJlcilbXVxuICBlcnI/OiBFcnJvciAmIHtcbiAgICBzdGF0dXNDb2RlPzogbnVtYmVyXG4gICAgc291cmNlPzogdHlwZW9mIENPTVBJTEVSX05BTUVTLnNlcnZlciB8IHR5cGVvZiBDT01QSUxFUl9OQU1FUy5lZGdlU2VydmVyXG4gIH1cbiAgZ3NwPzogYm9vbGVhblxuICBnc3NwPzogYm9vbGVhblxuICBjdXN0b21TZXJ2ZXI/OiBib29sZWFuXG4gIGdpcD86IGJvb2xlYW5cbiAgYXBwR2lwPzogYm9vbGVhblxuICBsb2NhbGU/OiBzdHJpbmdcbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIGRlZmF1bHRMb2NhbGU/OiBzdHJpbmdcbiAgZG9tYWluTG9jYWxlcz86IERvbWFpbkxvY2FsZVtdXG4gIHNjcmlwdExvYWRlcj86IGFueVtdXG4gIGlzUHJldmlldz86IGJvb2xlYW5cbiAgbm90Rm91bmRTcmNQYWdlPzogc3RyaW5nXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0UGFnZUNvbnRleHQge1xuICAvKipcbiAgICogRXJyb3Igb2JqZWN0IGlmIGVuY291bnRlcmVkIGR1cmluZyByZW5kZXJpbmdcbiAgICovXG4gIGVycj86IChFcnJvciAmIHsgc3RhdHVzQ29kZT86IG51bWJlciB9KSB8IG51bGxcbiAgLyoqXG4gICAqIGBIVFRQYCByZXF1ZXN0IG9iamVjdC5cbiAgICovXG4gIHJlcT86IEluY29taW5nTWVzc2FnZVxuICAvKipcbiAgICogYEhUVFBgIHJlc3BvbnNlIG9iamVjdC5cbiAgICovXG4gIHJlcz86IFNlcnZlclJlc3BvbnNlXG4gIC8qKlxuICAgKiBQYXRoIHNlY3Rpb24gb2YgYFVSTGAuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nXG4gIC8qKlxuICAgKiBRdWVyeSBzdHJpbmcgc2VjdGlvbiBvZiBgVVJMYCBwYXJzZWQgYXMgYW4gb2JqZWN0LlxuICAgKi9cbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIC8qKlxuICAgKiBgU3RyaW5nYCBvZiB0aGUgYWN0dWFsIHBhdGggaW5jbHVkaW5nIHF1ZXJ5LlxuICAgKi9cbiAgYXNQYXRoPzogc3RyaW5nXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBsb2NhbGVcbiAgICovXG4gIGxvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogQWxsIGNvbmZpZ3VyZWQgbG9jYWxlc1xuICAgKi9cbiAgbG9jYWxlcz86IHN0cmluZ1tdXG4gIC8qKlxuICAgKiBUaGUgY29uZmlndXJlZCBkZWZhdWx0IGxvY2FsZVxuICAgKi9cbiAgZGVmYXVsdExvY2FsZT86IHN0cmluZ1xuICAvKipcbiAgICogYENvbXBvbmVudGAgdGhlIHRyZWUgb2YgdGhlIEFwcCB0byB1c2UgaWYgbmVlZGluZyB0byByZW5kZXIgc2VwYXJhdGVseVxuICAgKi9cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbn1cblxuZXhwb3J0IHR5cGUgQXBwQ29udGV4dFR5cGU8Um91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXI+ID0ge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dD5cbiAgQXBwVHJlZTogQXBwVHJlZVR5cGVcbiAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgcm91dGVyOiBSb3V0ZXJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzPFBhZ2VQcm9wcyA9IGFueT4gPSB7XG4gIHBhZ2VQcm9wczogUGFnZVByb3BzXG59XG5cbmV4cG9ydCB0eXBlIEFwcFByb3BzVHlwZTxcbiAgUm91dGVyIGV4dGVuZHMgTmV4dFJvdXRlciA9IE5leHRSb3V0ZXIsXG4gIFBhZ2VQcm9wcyA9IHt9LFxuPiA9IEFwcEluaXRpYWxQcm9wczxQYWdlUHJvcHM+ICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBhbnk+XG4gIHJvdXRlcjogUm91dGVyXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50Q29udGV4dCA9IE5leHRQYWdlQ29udGV4dCAmIHtcbiAgcmVuZGVyUGFnZTogUmVuZGVyUGFnZVxuICBkZWZhdWx0R2V0SW5pdGlhbFByb3BzKFxuICAgIGN0eDogRG9jdW1lbnRDb250ZXh0LFxuICAgIG9wdGlvbnM/OiB7IG5vbmNlPzogc3RyaW5nIH1cbiAgKTogUHJvbWlzZTxEb2N1bWVudEluaXRpYWxQcm9wcz5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRJbml0aWFsUHJvcHMgPSBSZW5kZXJQYWdlUmVzdWx0ICYge1xuICBzdHlsZXM/OiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB8IEl0ZXJhYmxlPFJlYWN0LlJlYWN0Tm9kZT4gfCBKU1guRWxlbWVudFxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFByb3BzID0gRG9jdW1lbnRJbml0aWFsUHJvcHMgJiBIdG1sUHJvcHNcblxuLyoqXG4gKiBOZXh0IGBBUElgIHJvdXRlIHJlcXVlc3RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBOZXh0QXBpUmVxdWVzdCBleHRlbmRzIEluY29taW5nTWVzc2FnZSB7XG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgYHF1ZXJ5YCB2YWx1ZXMgZnJvbSB1cmxcbiAgICovXG4gIHF1ZXJ5OiBQYXJ0aWFsPHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBzdHJpbmdbXVxuICB9PlxuICAvKipcbiAgICogT2JqZWN0IG9mIGBjb29raWVzYCBmcm9tIGhlYWRlclxuICAgKi9cbiAgY29va2llczogUGFydGlhbDx7XG4gICAgW2tleTogc3RyaW5nXTogc3RyaW5nXG4gIH0+XG5cbiAgYm9keTogYW55XG5cbiAgZW52OiBFbnZcblxuICBkcmFmdE1vZGU/OiBib29sZWFuXG5cbiAgcHJldmlldz86IGJvb2xlYW5cbiAgLyoqXG4gICAqIFByZXZpZXcgZGF0YSBzZXQgb24gdGhlIHJlcXVlc3QsIGlmIGFueVxuICAgKiAqL1xuICBwcmV2aWV3RGF0YT86IFByZXZpZXdEYXRhXG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8RGF0YSA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPERhdGE+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8RGF0YT5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3QodXJsOiBzdHJpbmcpOiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cbiAgcmVkaXJlY3Qoc3RhdHVzOiBudW1iZXIsIHVybDogc3RyaW5nKTogTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIFNldCBkcmFmdCBtb2RlXG4gICAqL1xuICBzZXREcmFmdE1vZGU6IChvcHRpb25zOiB7IGVuYWJsZTogYm9vbGVhbiB9KSA9PiBOZXh0QXBpUmVzcG9uc2U8RGF0YT5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICAgIC8qKlxuICAgICAgICogU3BlY2lmaWVzIHRoZSBwYXRoIGZvciB0aGUgcHJldmlldyBzZXNzaW9uIHRvIHdvcmsgdW5kZXIuIEJ5IGRlZmF1bHQsXG4gICAgICAgKiB0aGUgcGF0aCBpcyBjb25zaWRlcmVkIHRoZSBcImRlZmF1bHQgcGF0aFwiLCBpLmUuLCBhbnkgcGFnZXMgdW5kZXIgXCIvXCIuXG4gICAgICAgKi9cbiAgICAgIHBhdGg/OiBzdHJpbmdcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPERhdGE+XG5cbiAgLyoqXG4gICAqIENsZWFyIHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIGNsZWFyUHJldmlld0RhdGE6IChvcHRpb25zPzogeyBwYXRoPzogc3RyaW5nIH0pID0+IE5leHRBcGlSZXNwb25zZTxEYXRhPlxuXG4gIC8qKlxuICAgKiBSZXZhbGlkYXRlIGEgc3BlY2lmaWMgcGFnZSBhbmQgcmVnZW5lcmF0ZSBpdCB1c2luZyBPbi1EZW1hbmQgSW5jcmVtZW50YWxcbiAgICogU3RhdGljIFJlZ2VuZXJhdGlvbi5cbiAgICogVGhlIHBhdGggc2hvdWxkIGJlIGFuIGFjdHVhbCBwYXRoLCBub3QgYSByZXdyaXR0ZW4gcGF0aC4gRS5nLiBmb3JcbiAgICogXCIvYmxvZy9bc2x1Z11cIiB0aGlzIHNob3VsZCBiZSBcIi9ibG9nL3Bvc3QtMVwiLlxuICAgKiBAbGluayBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9kYXRhLWZldGNoaW5nL2luY3JlbWVudGFsLXN0YXRpYy1yZWdlbmVyYXRpb24jb24tZGVtYW5kLXJldmFsaWRhdGlvbi13aXRoLXJldmFsaWRhdGVwYXRoXG4gICAqL1xuICByZXZhbGlkYXRlOiAoXG4gICAgdXJsUGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiB7XG4gICAgICB1bnN0YWJsZV9vbmx5R2VuZXJhdGVkPzogYm9vbGVhblxuICAgIH1cbiAgKSA9PiBQcm9taXNlPHZvaWQ+XG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSBoYW5kbGVyXG4gKi9cbmV4cG9ydCB0eXBlIE5leHRBcGlIYW5kbGVyPFQgPSBhbnk+ID0gKFxuICByZXE6IE5leHRBcGlSZXF1ZXN0LFxuICByZXM6IE5leHRBcGlSZXNwb25zZTxUPlxuKSA9PiB1bmtub3duIHwgUHJvbWlzZTx1bmtub3duPlxuXG4vKipcbiAqIFV0aWxzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT25jZTxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBSZXR1cm5UeXBlPFQ+PihcbiAgZm46IFRcbik6IFQge1xuICBsZXQgdXNlZCA9IGZhbHNlXG4gIGxldCByZXN1bHQ6IFJldHVyblR5cGU8VD5cblxuICByZXR1cm4gKCguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGlmICghdXNlZCkge1xuICAgICAgdXNlZCA9IHRydWVcbiAgICAgIHJlc3VsdCA9IGZuKC4uLmFyZ3MpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSkgYXMgVFxufVxuXG4vLyBTY2hlbWU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMy4xXG4vLyBBYnNvbHV0ZSBVUkw6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNC4zXG5jb25zdCBBQlNPTFVURV9VUkxfUkVHRVggPSAvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo/Oi9cbmV4cG9ydCBjb25zdCBpc0Fic29sdXRlVXJsID0gKHVybDogc3RyaW5nKSA9PiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh1cmwpXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb2NhdGlvbk9yaWdpbigpIHtcbiAgY29uc3QgeyBwcm90b2NvbCwgaG9zdG5hbWUsIHBvcnQgfSA9IHdpbmRvdy5sb2NhdGlvblxuICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2hvc3RuYW1lfSR7cG9ydCA/ICc6JyArIHBvcnQgOiAnJ31gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVUkwoKSB7XG4gIGNvbnN0IHsgaHJlZiB9ID0gd2luZG93LmxvY2F0aW9uXG4gIGNvbnN0IG9yaWdpbiA9IGdldExvY2F0aW9uT3JpZ2luKClcbiAgcmV0dXJuIGhyZWYuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZTxQPihDb21wb25lbnQ6IENvbXBvbmVudFR5cGU8UD4pIHtcbiAgcmV0dXJuIHR5cGVvZiBDb21wb25lbnQgPT09ICdzdHJpbmcnXG4gICAgPyBDb21wb25lbnRcbiAgICA6IENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnVW5rbm93bidcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUmVzU2VudChyZXM6IFNlcnZlclJlc3BvbnNlKSB7XG4gIHJldHVybiByZXMuZmluaXNoZWQgfHwgcmVzLmhlYWRlcnNTZW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVSZXBlYXRlZFNsYXNoZXModXJsOiBzdHJpbmcpIHtcbiAgY29uc3QgdXJsUGFydHMgPSB1cmwuc3BsaXQoJz8nKVxuICBjb25zdCB1cmxOb1F1ZXJ5ID0gdXJsUGFydHNbMF1cblxuICByZXR1cm4gKFxuICAgIHVybE5vUXVlcnlcbiAgICAgIC8vIGZpcnN0IHdlIHJlcGxhY2UgYW55IG5vbi1lbmNvZGVkIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZFxuICAgICAgLy8gdGhlbiBub3JtYWxpemUgcmVwZWF0ZWQgZm9yd2FyZCBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnLycpXG4gICAgICAucmVwbGFjZSgvXFwvXFwvKy9nLCAnLycpICtcbiAgICAodXJsUGFydHNbMV0gPyBgPyR7dXJsUGFydHMuc2xpY2UoMSkuam9pbignPycpfWAgOiAnJylcbiAgKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZEdldEluaXRpYWxQcm9wczxcbiAgQyBleHRlbmRzIEJhc2VDb250ZXh0LFxuICBJUCA9IHt9LFxuICBQID0ge30sXG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCBTUCA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCdcbmV4cG9ydCBjb25zdCBTVCA9XG4gIFNQICYmXG4gIChbJ21hcmsnLCAnbWVhc3VyZScsICdnZXRFbnRyaWVzQnlOYW1lJ10gYXMgY29uc3QpLmV2ZXJ5KFxuICAgIChtZXRob2QpID0+IHR5cGVvZiBwZXJmb3JtYW5jZVttZXRob2RdID09PSAnZnVuY3Rpb24nXG4gIClcblxuZXhwb3J0IGNsYXNzIERlY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmV4cG9ydCBjbGFzcyBOb3JtYWxpemVFcnJvciBleHRlbmRzIEVycm9yIHt9XG5leHBvcnQgY2xhc3MgUGFnZU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHBhZ2U6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvZGUgPSAnRU5PRU5UJ1xuICAgIHRoaXMubmFtZSA9ICdQYWdlTm90Rm91bmRFcnJvcidcbiAgICB0aGlzLm1lc3NhZ2UgPSBgQ2Fubm90IGZpbmQgbW9kdWxlIGZvciBwYWdlOiAke3BhZ2V9YFxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNaXNzaW5nU3RhdGljUGFnZSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IocGFnZTogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5tZXNzYWdlID0gYEZhaWxlZCB0byBsb2FkIHN0YXRpYyBmaWxlIGZvciBwYWdlOiAke3BhZ2V9ICR7bWVzc2FnZX1gXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1pZGRsZXdhcmVOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb2RlOiBzdHJpbmdcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuY29kZSA9ICdFTk9FTlQnXG4gICAgdGhpcy5tZXNzYWdlID0gYENhbm5vdCBmaW5kIHRoZSBtaWRkbGV3YXJlIG1vZHVsZWBcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhY2hlRnMge1xuICBleGlzdHNTeW5jOiB0eXBlb2YgZnMuZXhpc3RzU3luY1xuICByZWFkRmlsZTogdHlwZW9mIGZzLnByb21pc2VzLnJlYWRGaWxlXG4gIHJlYWRGaWxlU3luYzogdHlwZW9mIGZzLnJlYWRGaWxlU3luY1xuICB3cml0ZUZpbGUoZjogc3RyaW5nLCBkOiBhbnkpOiBQcm9taXNlPHZvaWQ+XG4gIG1rZGlyKGRpcjogc3RyaW5nKTogUHJvbWlzZTx2b2lkIHwgc3RyaW5nPlxuICBzdGF0KGY6IHN0cmluZyk6IFByb21pc2U8eyBtdGltZTogRGF0ZSB9PlxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IoZXJyb3I6IEVycm9yKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh7IG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsIHN0YWNrOiBlcnJvci5zdGFjayB9KVxufVxuIl0sIm5hbWVzIjpbIkRlY29kZUVycm9yIiwiTWlkZGxld2FyZU5vdEZvdW5kRXJyb3IiLCJNaXNzaW5nU3RhdGljUGFnZSIsIk5vcm1hbGl6ZUVycm9yIiwiUGFnZU5vdEZvdW5kRXJyb3IiLCJTUCIsIlNUIiwiV0VCX1ZJVEFMUyIsImV4ZWNPbmNlIiwiZ2V0RGlzcGxheU5hbWUiLCJnZXRMb2NhdGlvbk9yaWdpbiIsImdldFVSTCIsImlzQWJzb2x1dGVVcmwiLCJpc1Jlc1NlbnQiLCJsb2FkR2V0SW5pdGlhbFByb3BzIiwibm9ybWFsaXplUmVwZWF0ZWRTbGFzaGVzIiwic3RyaW5naWZ5RXJyb3IiLCJmbiIsInVzZWQiLCJyZXN1bHQiLCJhcmdzIiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwidXJsIiwidGVzdCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0Iiwid2luZG93IiwibG9jYXRpb24iLCJocmVmIiwib3JpZ2luIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwiQ29tcG9uZW50IiwiZGlzcGxheU5hbWUiLCJuYW1lIiwicmVzIiwiZmluaXNoZWQiLCJoZWFkZXJzU2VudCIsInVybFBhcnRzIiwic3BsaXQiLCJ1cmxOb1F1ZXJ5IiwicmVwbGFjZSIsInNsaWNlIiwiam9pbiIsIkFwcCIsImN0eCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsInByb3RvdHlwZSIsImdldEluaXRpYWxQcm9wcyIsIm1lc3NhZ2UiLCJFcnJvciIsInBhZ2VQcm9wcyIsInByb3BzIiwiT2JqZWN0Iiwia2V5cyIsImNvbnNvbGUiLCJ3YXJuIiwicGVyZm9ybWFuY2UiLCJldmVyeSIsIm1ldGhvZCIsImNvbnN0cnVjdG9yIiwicGFnZSIsImNvZGUiLCJlcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJzdGFjayJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/utils.js\n"));

/***/ })

});